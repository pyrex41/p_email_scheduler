This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.py, **/*.html
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
templates/
  html/
    aep/
      email.html
    birthday/
      email.html
  base.html
  dashboard.html
  email_table.html
  error.html
  home.html
  index.html
  organization.html
  results.html
  simulator.html
  state_info.html
  timeline.html
app.py
contact_rule_engine.py
email_scheduler_common.py
email_scheduler_optimized.py
email_template_engine.py
org_utils.py
send_scheduled_emails.py
sendgrid_client.py
test_email_scheduler.py
z.py

================================================================
Files
================================================================

================
File: templates/html/aep/email.html
================
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{ subject }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            color: #0066cc;
            margin-bottom: 20px;
        }
        .content {
            margin-bottom: 30px;
        }
        .benefits {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .benefits ul {
            margin: 0;
            padding-left: 20px;
        }
        .cta {
            background-color: #0066cc;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin: 20px 0;
        }
        .signature {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .footer {
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 30px;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ subject }}</h1>
    </div>

    <div class="content">
        <p>{{ greeting }}</p>

        <p>The Annual Enrollment Period (AEP) is approaching, and we want to help you make the most of this important time. From {{ aep_start | date }} to {{ aep_end | date }}, you'll have the opportunity to review and adjust your Medicare coverage.</p>

        <div class="benefits">
            <p>Here's what we'll cover in your AEP review:</p>
            <ul>
            {% for benefit in aep_benefits %}
                <li>{{ benefit }}</li>
            {% endfor %}
            </ul>
        </div>

        <div class="cta">
            <h2>{{ call_to_action }}</h2>
            <p>Call us at {{ signature_phone | phone }} to schedule your review.</p>
        </div>

        <div class="signature">
            <p>Best regards,<br>
            {{ signature_name }}</p>
        </div>
    </div>

    <div class="footer">
        <p>{{ company_name }}<br>
        Phone: {{ phone | phone }}<br>
        Website: {{ website }}<br>
        {% if contact.id %}Contact ID: {{ contact.id }}{% endif %}</p>
    </div>
</body>
</html>

================
File: templates/html/birthday/email.html
================
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{ subject }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            color: #0066cc;
            margin-bottom: 20px;
        }
        .content {
            margin-bottom: 30px;
        }
        .benefits {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .benefits ul {
            margin: 0;
            padding-left: 20px;
        }
        .cta {
            background-color: #0066cc;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin: 20px 0;
        }
        .cta a {
            color: white;
            text-decoration: none;
        }
        .signature {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .footer {
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 30px;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ subject }}</h1>
    </div>

    <div class="content">
        <p>Dear {{ first_name }},</p>

        <p>Happy birthday month! As your Medicare insurance specialists, we want to ensure you're getting the most from your coverage during this special time.</p>

        <div class="benefits">
            <p>Your birthday month is a perfect opportunity for a comprehensive review of your Medicare coverage. Here's what we'll cover:</p>
            <ul>
            {% for benefit in review_benefits %}
                <li>{{ benefit }}</li>
            {% endfor %}
            </ul>
        </div>

        <div class="cta">
            <h2>{{ call_to_action }}</h2>
            <p>Call us at {{ signature_phone | phone }} to schedule your review.</p>
        </div>

        <div class="signature">
            <p>Best regards,<br>
            {{ signature_name }}</p>
        </div>
    </div>

    <div class="footer">
        <p>{{ company_name }}<br>
        Phone: {{ phone | phone }}<br>
        Website: {{ website }}<br>
        {% if contact.id %}Contact ID: {{ contact.id }}{% endif %}</p>
    </div>
</body>
</html>

================
File: templates/base.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Schedule Checker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Card styles */
        .contact-card {
            margin-bottom: 2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .contact-card .card-header {
            font-weight: bold;
        }
        
        /* Email styling */
        .email-row {
            margin-bottom: 0.5rem;
        }
        .skipped {
            color: #dc3545;
        }
        
        /* Dashboard styles */
        .card {
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }
        .card-header h5 {
            margin-bottom: 0;
        }
        .progress {
            height: 30px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,.2);
        }
        .progress-bar {
            font-weight: bold;
            font-size: 0.9rem;
            line-height: 30px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        
        /* Table styles */
        .table-responsive {
            overflow-x: auto;
        }
        .table th {
            background-color: #f8f9fa;
            position: sticky;
            top: 0;
        }
        
        /* Badge styling */
        .badge {
            font-size: 85%;
            padding: 0.35em 0.65em;
        }
        
        /* Nav tabs */
        .nav-tabs .nav-link {
            font-weight: 500;
        }
        
        /* Add responsive elements */
        @media (max-width: 768px) {
            .display-4 {
                font-size: 2.5rem;
            }
        }
    </style>
    {% block head %}{% endblock %}
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">Email Schedule Checker</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/dashboard">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/simulator">Simulator</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        {% block content %}{% endblock %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/dashboard.js"></script>
    {% block scripts %}{% endblock %}
</body>
</html>

================
File: templates/dashboard.html
================
{% extends "base.html" %}

{% block content %}
<h1 class="mb-4">Email Scheduling Dashboard</h1>

<!-- Summary cards -->
<div class="row mb-4">
    <div class="col-md-3">
        <div class="card bg-primary text-white">
            <div class="card-body">
                <h5 class="card-title">Total Emails Scheduled</h5>
                <h2 class="display-4">{{ total_emails }}</h2>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-success text-white">
            <div class="card-body">
                <h5 class="card-title">Birthday Emails</h5>
                <h2 class="display-4">{{ email_type_totals.birthday }}</h2>
                <p class="card-text">
                    {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}% of total
                </p>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-info text-white">
            <div class="card-body">
                <h5 class="card-title">Effective Date Emails</h5>
                <h2 class="display-4">{{ email_type_totals.effective_date }}</h2>
                <p class="card-text">
                    {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}% of total
                </p>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-warning text-dark">
            <div class="card-body">
                <h5 class="card-title">Skipped Emails</h5>
                <h2 class="display-4">{{ total_skipped }}</h2>
            </div>
        </div>
    </div>
</div>

<!-- Email type distribution -->
<div class="row mb-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h5 class="card-title mb-0">Email Types Distribution</h5>
            </div>
            <div class="card-body">
                <div class="progress" style="height: 30px;">
                    <div class="progress-bar bg-primary" role="progressbar" 
                        style="width: {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.birthday }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Birthday: {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-success" role="progressbar" 
                        style="width: {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.effective_date }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Effective: {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-info" role="progressbar" 
                        style="width: {{ (email_type_totals.aep / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.aep }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        AEP: {{ (email_type_totals.aep / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-warning" role="progressbar" 
                        style="width: {{ (email_type_totals.post_window / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.post_window }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Post: {{ (email_type_totals.post_window / total_emails * 100) | round(1) }}%
                    </div>
                </div>
                <div class="row mt-3 text-center">
                    <div class="col">
                        <span class="badge bg-primary">Birthday: {{ email_type_totals.birthday }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-success">Effective Date: {{ email_type_totals.effective_date }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-info">AEP: {{ email_type_totals.aep }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-warning text-dark">Post-Window: {{ email_type_totals.post_window }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- States table -->
<div class="row">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header">
                <ul class="nav nav-tabs card-header-tabs" id="statesTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="all-states-tab" data-bs-toggle="tab" data-bs-target="#all-states" type="button" role="tab" aria-controls="all-states" aria-selected="true">All States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="special-states-tab" data-bs-toggle="tab" data-bs-target="#special-states" type="button" role="tab" aria-controls="special-states" aria-selected="false">Special Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="birthday-states-tab" data-bs-toggle="tab" data-bs-target="#birthday-states" type="button" role="tab" aria-controls="birthday-states" aria-selected="false">Birthday Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="effective-date-states-tab" data-bs-toggle="tab" data-bs-target="#effective-date-states" type="button" role="tab" aria-controls="effective-date-states" aria-selected="false">Effective Date Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="year-round-states-tab" data-bs-toggle="tab" data-bs-target="#year-round-states" type="button" role="tab" aria-controls="year-round-states" aria-selected="false">Year-Round Enrollment States</button>
                    </li>
                </ul>
            </div>
            <div class="card-body">
                <div class="tab-content" id="statesTabsContent">
                    <!-- All States Tab -->
                    <div class="tab-pane fade show active" id="all-states" role="tabpanel" aria-labelledby="all-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                        <th>Special Rules</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in all_states %}
                                    {% if email_counts[state].total > 0 %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                        <td>
                                            {% if state in special_rule_states %}
                                            <span class="badge bg-info">Yes</span>
                                            {% else %}
                                            <span class="badge bg-secondary">No</span>
                                            {% endif %}
                                        </td>
                                    </tr>
                                    {% endif %}
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Special Rule States Tab -->
                    <div class="tab-pane fade" id="special-states" role="tabpanel" aria-labelledby="special-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                        <th>Rules</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in special_rule_states %}
                                    {% if email_counts[state].total > 0 %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                        <td>
                                            {% if state in birthday_rule_states %}
                                            <span class="badge bg-primary">Birthday</span>
                                            {% endif %}
                                            {% if state in effective_date_rule_states %}
                                            <span class="badge bg-success">Effective Date</span>
                                            {% endif %}
                                            {% if state in year_round_enrollment_states %}
                                            <span class="badge bg-warning text-dark">Year-Round</span>
                                            {% endif %}
                                        </td>
                                    </tr>
                                    {% endif %}
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Birthday Rule States Tab -->
                    <div class="tab-pane fade" id="birthday-states" role="tabpanel" aria-labelledby="birthday-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Window Before</th>
                                        <th>Window After</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in birthday_rule_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ birthday_rule_states[state].window_before }} days</td>
                                        <td>{{ birthday_rule_states[state].window_after }} days</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Effective Date Rule States Tab -->
                    <div class="tab-pane fade" id="effective-date-states" role="tabpanel" aria-labelledby="effective-date-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Window Before</th>
                                        <th>Window After</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in effective_date_rule_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ effective_date_rule_states[state].window_before }} days</td>
                                        <td>{{ effective_date_rule_states[state].window_after }} days</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Year-Round Enrollment States Tab -->
                    <div class="tab-pane fade" id="year-round-states" role="tabpanel" aria-labelledby="year-round-states-tab">
                        <div class="alert alert-warning mb-3">
                            <strong>Note:</strong> Year-round enrollment states should have no AEP or post-window emails scheduled.
                        </div>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in year_round_enrollment_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>
                                            {% if email_counts[state].aep > 0 %}
                                            <span class="text-danger">{{ email_counts[state].aep }}</span>
                                            {% else %}
                                            0
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if email_counts[state].post_window > 0 %}
                                            <span class="text-danger">{{ email_counts[state].post_window }}</span>
                                            {% else %}
                                            0
                                            {% endif %}
                                        </td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: templates/email_table.html
================
<div class="table-responsive">
    <table class="table table-sm">
        <thead>
            <tr>
                <th>Type</th>
                <th>Date</th>
                <th>Status</th>
                <th>Default Date</th>
                <th>Reason</th>
                <th>Link</th>
            </tr>
        </thead>
        <tbody>
            {% for email in contact_data.emails %}
            <tr {% if email.skipped == 'Yes' %}class="table-danger"{% endif %}>
                <td>
                    {% if email.type == 'birthday' %}
                    <span class="badge bg-primary">Birthday</span>
                    {% elif email.type == 'effective_date' %}
                    <span class="badge bg-success">Effective Date</span>
                    {% elif email.type == 'aep' %}
                    <span class="badge bg-info">AEP</span>
                    {% elif email.type == 'post_window' %}
                    <span class="badge bg-warning">Post Window</span>
                    {% else %}
                    {{ email.type }}
                    {% endif %}
                </td>
                <td>{{ email.date }}</td>
                <td>
                    {% if email.skipped == 'Yes' %}
                    <span class="badge bg-danger">Skipped</span>
                    {% else %}
                    <span class="badge bg-success">Scheduled</span>
                    {% endif %}
                </td>
                <td>
                    {% if email.type == 'birthday' and contact_data.contact_info.birth_date and '-' in contact_data.contact_info.birth_date %}
                        {% set date_str = email.date|string %}
                        {% if '-' in date_str %}
                            {% set birthday_parts = contact_data.contact_info.birth_date.split('-') %}
                            {% set current_year = date_str.split('-')[0] %}
                            {% if birthday_parts|length >= 3 %}
                                {% set default_date = current_year + '-' + birthday_parts[1] + '-' + birthday_parts[2] %}
                                {% if email.date < default_date %}
                                    {{ (current_year|int - 1)|string + '-' + birthday_parts[1] + '-' + birthday_parts[2] }}
                                {% else %}
                                    {{ default_date }}
                                {% endif %}
                            {% else %}
                                N/A (birth date format error)
                            {% endif %}
                        {% else %}
                            N/A (email date format error)
                        {% endif %}
                    {% elif email.type == 'effective_date' and contact_data.contact_info.effective_date and '-' in contact_data.contact_info.effective_date %}
                        {% set date_str = email.date|string %}
                        {% if '-' in date_str %}
                            {% set effective_parts = contact_data.contact_info.effective_date.split('-') %}
                            {% set current_year = date_str.split('-')[0] %}
                            {% if effective_parts|length >= 3 %}
                                {% set default_date = current_year + '-' + effective_parts[1] + '-' + effective_parts[2] %}
                                {% if email.date < default_date %}
                                    {{ (current_year|int - 1)|string + '-' + effective_parts[1] + '-' + effective_parts[2] }}
                                {% else %}
                                    {{ default_date }}
                                {% endif %}
                            {% else %}
                                N/A (effective date format error)
                            {% endif %}
                        {% else %}
                            N/A (email date format error)
                        {% endif %}
                    {% else %}
                    N/A
                    {% endif %}
                </td>
                <td>
                    {% if email.reason %}
                    <span class="text-danger">{{ email.reason }}</span>
                    {% elif email.skipped == 'Yes' %}
                    <span class="text-danger">Unknown</span>
                    {% else %}
                    <span class="text-success">Normal schedule</span>
                    {% endif %}
                </td>
                <td>
                    {% if email.link and email.skipped != 'Yes' %}
                    <a href="{{ email.link }}" target="_blank" class="btn btn-sm btn-primary">View</a>
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            
            {% if not contact_data.emails|selectattr('type', 'equalto', 'birthday')|list and contact_data.contact_info.birth_date %}
            <tr class="table-info">
                <td><span class="badge bg-primary">Birthday</span></td>
                <td>-</td>
                <td><span class="badge bg-danger">Skipped</span></td>
                <td>N/A</td>
                <td><span class="text-danger">Check birthday calculation</span></td>
                <td></td>
            </tr>
            {% endif %}
            
            {% if not contact_data.emails|selectattr('type', 'equalto', 'effective_date')|list and contact_data.contact_info.effective_date %}
            <tr class="table-info">
                <td><span class="badge bg-success">Effective Date</span></td>
                <td>-</td>
                <td><span class="badge bg-danger">Skipped</span></td>
                <td>N/A</td>
                <td><span class="text-danger">Check effective date calculation</span></td>
                <td></td>
            </tr>
            {% endif %}
        </tbody>
    </table>
</div>

================
File: templates/error.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error - Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --error-color: #ea4335;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
        }
        
        .error-icon {
            width: 40px;
            height: 40px;
            margin-right: 16px;
            color: var(--error-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--error-color);
        }
        
        .error-message {
            background-color: #fdede9;
            border-left: 4px solid var(--error-color);
            padding: 16px;
            margin-bottom: 24px;
            border-radius: 4px;
        }
        
        .error-details {
            background-color: #f1f3f4;
            padding: 16px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            margin-bottom: 24px;
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .home-link {
            display: inline-flex;
            align-items: center;
        }
        
        .home-link svg {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <svg class="error-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h1>Error Occurred</h1>
        </header>
        
        <div class="error-message">
            {{ error }}
        </div>
        
        {% if error_details %}
        <div class="error-details">
            {{ error_details }}
        </div>
        {% endif %}
        
        <a href="/" class="btn home-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
            Back to Home
        </a>
    </div>
</body>
</html>

================
File: templates/home.html
================
{% extends "base.html" %}

{% block content %}
<h1 class="mb-4">Email Schedule Checker</h1>

<div class="card mb-4">
    <div class="card-header bg-primary text-white">
        <h5 class="card-title mb-0">Calculate Email Schedule</h5>
    </div>
    <div class="card-body">
        <form action="/check" method="post" id="scheduleForm">
            <div class="mb-3">
                <label for="org_id" class="form-label">Organization ID</label>
                <input type="number" class="form-control" id="org_id" name="org_id" value="37" required>
                <div class="form-text">Enter the organization ID to check email schedules</div>
            </div>
            
            <div class="row mb-3">
                <div class="col-md-4">
                    <label for="sample_size" class="form-label">Sample Size</label>
                    <select class="form-select" id="sample_size" name="sample_size">
                        {% for size in sample_sizes %}
                        <option value="{{ size }}" {% if size == 10 %}selected{% endif %}>{{ size }} contacts</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            
            <div class="mb-3">
                <label for="contact_search" class="form-label">Search by Email or Contact ID (Optional)</label>
                <input type="text" class="form-control" id="contact_search" name="contact_search" placeholder="Enter email or contact ID">
                <small class="form-text text-muted">If provided, other filters will be ignored</small>
            </div>
            
            <div class="mb-3">
                <label class="form-label">State Filter</label>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_none" value="none" checked>
                    <label class="form-check-label" for="filter_none">
                        Show all states
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_state" value="state">
                    <label class="form-check-label" for="filter_state">
                        Filter by specific state
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_special" value="special">
                    <label class="form-check-label" for="filter_special">
                        Show only states with special rules
                    </label>
                </div>
                <select class="form-select mt-2" id="state" name="state" disabled>
                    <option value="">Select a state...</option>
                    {% for state in all_states %}
                    <option value="{{ state }}">
                        {{ state }}
                        {% if state in special_rule_states %}
                            (Special Rules:
                            {% if state_rules[state].has_birthday_rule %}Birthday{% endif %}
                            {% if state_rules[state].has_effective_date_rule %}Effective Date{% endif %}
                            {% if state_rules[state].has_year_round_enrollment %}Year-Round{% endif %}
                            )
                        {% endif %}
                    </option>
                    {% endfor %}
                </select>
                <input type="hidden" name="special_rules_only" id="special_rules_only" value="false">
            </div>
            
            <button type="submit" class="btn btn-primary" id="submitBtn">
                <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                Check Schedules
            </button>
        </form>
    </div>
</div>

<div class="card mb-4">
    <div class="card-header bg-info text-white">
        <h5 class="card-title mb-0">Special State Rules</h5>
    </div>
    <div class="card-body">
        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead>
                    <tr>
                        <th>State</th>
                        <th>Birthday Rule</th>
                        <th>Effective Date Rule</th>
                        <th>Year-Round Enrollment</th>
                    </tr>
                </thead>
                <tbody>
                    {% for state in all_states %}
                    {% if state_rules[state].has_birthday_rule or state_rules[state].has_effective_date_rule or state_rules[state].has_year_round_enrollment %}
                    <tr class="table-info">
                    {% else %}
                    <tr>
                    {% endif %}
                        <td>{{ state }}</td>
                        <td>
                            {% if state_rules[state].has_birthday_rule %}
                            <span class="badge bg-primary">Yes</span>
                            {% else %}
                            <span class="text-muted">No</span>
                            {% endif %}
                        </td>
                        <td>
                            {% if state_rules[state].has_effective_date_rule %}
                            <span class="badge bg-success">Yes</span>
                            {% else %}
                            <span class="text-muted">No</span>
                            {% endif %}
                        </td>
                        <td>
                            {% if state_rules[state].has_year_round_enrollment %}
                            <span class="badge bg-warning">No</span>
                            {% else %}
                            <span class="text-muted">Yes</span>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<div class="card">
    <div class="card-header bg-secondary text-white">
        <h5 class="card-title mb-0">Help & Information</h5>
    </div>
    <div class="card-body">
        <h6>Standard Email Scheduling Rules:</h6>
        <ul>
            <li><strong>Birthday emails:</strong> Sent 14 days before birthday</li>
            <li><strong>Effective date emails:</strong> Sent 30 days before policy anniversary</li>
            <li><strong>AEP emails:</strong> Distributed across August/September weeks</li>
            <li><strong>Post-window emails:</strong> Sent the day after exclusion period ends</li>
        </ul>
        
        <h6>Special State Rules:</h6>
        <ul>
            <li><strong>Birthday Rules:</strong> Special rules for states like CA, ID, IL, KY, LA, MD, NV, OK, OR that control when emails can be sent around a birthday</li>
            <li><strong>Effective Date Rules:</strong> Special rules for states like MO that control email timing around policy anniversary dates</li>
            <li><strong>Year-Round Enrollment:</strong> States like CT, MA, NY, WA that have year-round enrollment (no scheduled emails)</li>
        </ul>
    </div>
</div>

<script>
document.getElementById('scheduleForm').addEventListener('submit', function(e) {
    // Show loading spinner
    const button = document.getElementById('submitBtn');
    const spinner = button.querySelector('.spinner-border');
    button.disabled = true;
    spinner.classList.remove('d-none');
    
    // Handle state filtering
    const filterType = document.querySelector('input[name="filter_type"]:checked').value;
    const stateSelect = document.getElementById('state');
    const specialRulesOnly = document.getElementById('special_rules_only');
    
    if (filterType === 'none') {
        stateSelect.value = '';
        specialRulesOnly.value = 'false';
    } else if (filterType === 'special') {
        stateSelect.value = '';
        specialRulesOnly.value = 'true';
    } else if (filterType === 'state') {
        specialRulesOnly.value = 'false';
        if (!stateSelect.value) {
            e.preventDefault();
            alert('Please select a state');
            button.disabled = false;
            spinner.classList.add('d-none');
            return;
        }
    }
});

// Handle radio button changes
document.querySelectorAll('input[name="filter_type"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const stateSelect = document.getElementById('state');
        if (this.value === 'state') {
            stateSelect.disabled = false;
            stateSelect.required = true;
        } else {
            stateSelect.disabled = true;
            stateSelect.required = false;
            stateSelect.value = '';
        }
    });
});

// Initialize state select state
document.getElementById('state').disabled = true;
</script>
{% endblock %}

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--text-color);
        }
        
        .subtitle {
            margin-top: 8px;
            color: var(--text-secondary);
            font-size: 16px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
            background-color: var(--card-bg);
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .org-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-top: 16px;
        }
        
        .org-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .org-item:last-child {
            border-bottom: none;
        }
        
        .org-item:hover {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .org-name {
            font-weight: 500;
            color: var(--text-color);
        }
        
        .org-id {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .org-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .org-link:hover {
            text-decoration: underline;
        }
        
        .search-box {
            display: flex;
            align-items: center;
            position: relative;
            margin-bottom: 16px;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .no-orgs {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
        }
        
        .dashboard-link {
            display: inline-flex;
            align-items: center;
            margin-top: 16px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .dashboard-link:hover {
            text-decoration: underline;
        }
        
        .dashboard-link svg {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Email Scheduler</h1>
            <p class="subtitle">Schedule emails for Medicare services communications</p>
        </header>
        
        <div class="card">
            <h2 class="card-title">Select an Organization</h2>
            
            <div class="search-box">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="search-orgs" placeholder="Search organizations...">
            </div>
            
            <div class="org-list">
                {% if organizations %}
                    {% for org in organizations %}
                    <div class="org-item">
                        <div class="org-info">
                            <div class="org-name">{{ org.name }}</div>
                            <div class="org-id">ID: {{ org.id }}</div>
                        </div>
                        <a href="/org/{{ org.id }}" class="org-link">Select</a>
                    </div>
                    {% endfor %}
                {% else %}
                    <div class="no-orgs">
                        <p>No organizations found.</p>
                    </div>
                {% endif %}
            </div>
            
            <a href="/dashboard" class="dashboard-link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="3" y1="9" x2="21" y2="9"></line>
                    <line x1="9" y1="21" x2="9" y2="9"></line>
                </svg>
                View Dashboard
            </a>
        </div>
        
        <div class="card">
            <h2 class="card-title">Email Scheduling Rules</h2>
            <p>The system schedules four types of emails based on specific business rules:</p>
            <ul>
                <li><strong>Birthday Emails:</strong> Sent 14 days before a contact's birthday</li>
                <li><strong>Effective Date Emails:</strong> Sent 30 days before a policy effective date</li>
                <li><strong>AEP Emails:</strong> Sent during the Annual Enrollment Period (August-September)</li>
                <li><strong>Post-Window Emails:</strong> Sent after rule windows end, with special state handling</li>
            </ul>
            <p>Special rule states include: CA, ID, IL, KY, LA, MD, NV, OK, OR (birthday rules) and MO (effective date rule).</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-orgs');
            const orgItems = document.querySelectorAll('.org-item');
            
            // Search organizations
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                orgItems.forEach(item => {
                    const orgName = item.querySelector('.org-name').textContent.toLowerCase();
                    const orgId = item.querySelector('.org-id').textContent.toLowerCase();
                    
                    if (orgName.includes(searchTerm) || orgId.includes(searchTerm)) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });
        });
    </script>
</body>
</html>

================
File: templates/organization.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ org.name }} - Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            --birthday-color: #4285F4;
            --effective-date-color: #34A853;
            --aep-color: #FBBC05;
            --post-window-color: #EA4335;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--text-color);
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 16px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .back-link svg {
            margin-right: 8px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
        }
        
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
            background-color: var(--card-bg);
        }
        
        .date-inputs {
            display: flex;
            gap: 16px;
        }
        
        .date-inputs .form-group {
            flex: 1;
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        
        .btn-secondary:hover {
            background-color: rgba(26, 115, 232, 0.04);
        }
        
        .contacts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }
        
        .contacts-table th,
        .contacts-table td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .contacts-table th {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .contacts-table tr:hover {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .contacts-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .contact-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .search-box {
            display: flex;
            align-items: center;
            max-width: 300px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .select-all {
            display: flex;
            align-items: center;
            margin-left: 16px;
            font-size: 14px;
        }
        
        .select-all input {
            margin-right: 8px;
        }
        
        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            color: white;
        }
        
        .tag.birthday {
            background-color: var(--birthday-color);
        }
        
        .tag.effective-date {
            background-color: var(--effective-date-color);
        }
        
        .tag.aep {
            background-color: var(--aep-color);
            color: var(--text-color);
        }
        
        .tag.post-window {
            background-color: var(--post-window-color);
        }
        
        .state-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin-left: 8px;
        }
        
        .state-badge.special::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
            margin-right: 4px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-contacts {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 24px;
        }
        
        @media (max-width: 768px) {
            .date-inputs {
                flex-direction: column;
                gap: 8px;
            }
            
            .contacts-table th:nth-child(3),
            .contacts-table td:nth-child(3) {
                display: none;
            }
            
            .table-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .search-box {
                max-width: 100%;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="back-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Back to Organizations
        </a>
        
        <header>
            <h1>{{ org.name }}</h1>
        </header>
        
        <div class="card">
            <h2 class="card-title">Schedule Emails</h2>
            
            <form id="schedule-form" action="/schedule" method="post">
                <input type="hidden" name="session_id" value="{{ session_id }}">
                
                <div class="date-inputs">
                    <div class="form-group">
                        <label for="start-date" class="form-label">Start Date</label>
                        <input type="date" id="start-date" name="start_date" class="form-input" value="{{ today.isoformat() if today else '' }}">
                    </div>
                    
                    <div class="form-group">
                        <label for="end-date" class="form-label">End Date</label>
                        <input type="date" id="end-date" name="end_date" class="form-input" value="{{ (today + timedelta(days=365)).isoformat() if today else '' }}">
                    </div>
                </div>
                
                <div class="contacts-selection">
                    <div class="table-controls">
                        <div class="search-box">
                            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            </svg>
                            <input type="text" id="search-contacts" placeholder="Search contacts...">
                        </div>
                        
                        <div class="select-all">
                            <input type="checkbox" id="select-all-checkbox">
                            <label for="select-all-checkbox">Select All</label>
                        </div>
                    </div>
                    
                    <div class="contacts-container">
                        {% if contacts %}
                        <table class="contacts-table">
                            <thead>
                                <tr>
                                    <th width="50"></th>
                                    <th>Name</th>
                                    <th>Email</th>
                                    <th>State</th>
                                    <th>Birth Date</th>
                                    <th>Effective Date</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for contact in contacts %}
                                <tr class="contact-row">
                                    <td>
                                        <input type="checkbox" name="contact_ids" value="{{ contact.id }}" class="contact-checkbox">
                                    </td>
                                    <td>{{ contact.first_name }} {{ contact.last_name }}</td>
                                    <td>{{ contact.email }}</td>
                                    <td>
                                        {{ contact.state }}
                                        {% if contact.state in special_rule_states %}
                                        <span class="state-badge special" title="Special rules apply">Rule</span>
                                        {% endif %}
                                    </td>
                                    <td>{{ contact.birth_date }}</td>
                                    <td>{{ contact.effective_date }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                        {% else %}
                        <div class="no-contacts">
                            <p>No contacts found for this organization.</p>
                        </div>
                        {% endif %}
                    </div>
                </div>
                
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Scheduling emails...</p>
                </div>
                
                <div class="actions">
                    <button type="button" id="cancel-btn" class="btn btn-secondary">Cancel</button>
                    <button type="submit" id="schedule-btn" class="btn">Schedule Emails</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-contacts');
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
            const scheduleForm = document.getElementById('schedule-form');
            const scheduleBtn = document.getElementById('schedule-btn');
            const cancelBtn = document.getElementById('cancel-btn');
            const loading = document.getElementById('loading');
            
            // Search contacts
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const rows = document.querySelectorAll('.contact-row');
                
                rows.forEach(row => {
                    const contactName = row.children[1].textContent.toLowerCase();
                    const contactEmail = row.children[2].textContent.toLowerCase();
                    const contactState = row.children[3].textContent.toLowerCase();
                    
                    if (contactName.includes(searchTerm) || 
                        contactEmail.includes(searchTerm) || 
                        contactState.includes(searchTerm)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            });
            
            // Select all contacts
            selectAllCheckbox.addEventListener('change', function() {
                const isChecked = this.checked;
                
                // Only select visible contacts
                const visibleCheckboxes = Array.from(contactCheckboxes).filter(checkbox => {
                    return checkbox.closest('tr').style.display !== 'none';
                });
                
                visibleCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
            });
            
            // Update "Select All" state when individual contacts are selected/deselected
            contactCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateSelectAllState);
            });
            
            function updateSelectAllState() {
                const visibleCheckboxes = Array.from(contactCheckboxes).filter(checkbox => {
                    return checkbox.closest('tr').style.display !== 'none';
                });
                
                const allChecked = visibleCheckboxes.every(checkbox => checkbox.checked);
                const someChecked = visibleCheckboxes.some(checkbox => checkbox.checked);
                
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = someChecked && !allChecked;
            }
            
            // Form submission
            scheduleForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Validate that at least one contact is selected
                const selectedContacts = document.querySelectorAll('.contact-checkbox:checked');
                if (selectedContacts.length === 0) {
                    alert('Please select at least one contact.');
                    return;
                }
                
                // Show loading
                loading.style.display = 'block';
                scheduleBtn.disabled = true;
                
                // Submit form via AJAX
                const formData = new FormData(this);
                
                fetch('/schedule', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        loading.style.display = 'none';
                        scheduleBtn.disabled = false;
                    } else if (data.redirect) {
                        window.location.href = data.redirect;
                    } else {
                        alert(data.message || 'Emails scheduled successfully!');
                        loading.style.display = 'none';
                        scheduleBtn.disabled = false;
                    }
                })
                .catch(error => {
                    alert('An error occurred: ' + error.message);
                    loading.style.display = 'none';
                    scheduleBtn.disabled = false;
                });
            });
            
            // Cancel button
            cancelBtn.addEventListener('click', function() {
                window.location.href = '/';
            });
        });
    </script>
</body>
</html>

================
File: templates/results.html
================
{% extends "base.html" %}

{% block head %}
<!-- Add vis-timeline CSS and JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />

<style>
.vis-timeline {
    border: none;
    font-family: system-ui, -apple-system, sans-serif;
}

.timeline-birthday {
    color: #FF69B4;
    font-weight: bold;
}

.timeline-effective {
    color: #4169E1;
    font-weight: bold;
}

.timeline-email-birthday {
    color: #FF1493;
    background-color: #FFE4E1;
    border-color: #FF69B4;
}

.timeline-email-effective_date {
    color: #0000CD;
    background-color: #E6E6FA;
    border-color: #4169E1;
}

.timeline-email-aep {
    color: #228B22;
    background-color: #F0FFF0;
    border-color: #32CD32;
}

.timeline-email-post_window {
    color: #8B4513;
    background-color: #FFF8DC;
    border-color: #DEB887;
}

.timeline-aep-window {
    background-color: rgba(144, 238, 144, 0.2);
}

.timeline-exclusion-window {
    background-color: rgba(211, 211, 211, 0.3);
}

.vis-item.vis-background.timeline-exclusion-window {
    background-color: rgba(169, 169, 169, 0.2);
}

.vis-item.vis-background.timeline-aep-window {
    background-color: rgba(144, 238, 144, 0.15);
}

.vis-group-level-0 {
    font-weight: bold;
    font-size: 14px;
}

.vis-item.vis-point {
    border-width: 2px;
    border-radius: 5px;
    padding: 5px;
}

.vis-item.vis-point.vis-selected {
    background-color: #FFF;
    border-width: 3px;
}

.year-divider {
    background-color: #f8f9fa !important;
    border-top: 2px solid #dee2e6;
    border-bottom: 1px solid #dee2e6;
}

.year-divider td {
    padding: 0.5rem 1rem !important;
    font-weight: 500;
    color: #495057;
}

.first-row-of-year {
    border-top: 1px solid #dee2e6;
}
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1>{{ org_name }} (ID: {{ org_id }})</h1>
    <p>Showing {{ sample_size }} contacts out of {{ total_contacts }} total contacts</p>
    
    <!-- Controls -->
    <div class="row mb-4">
        <div class="col">
            <form action="/check" method="post" class="form-inline">
                <input type="hidden" name="org_id" value="{{ org_id }}">
                <div class="form-group mr-2">
                    <label for="sample_size" class="mr-2">Show</label>
                    <select name="sample_size" id="sample_size" class="form-control">
                        {% for size in sample_sizes %}
                        <option value="{{ size }}" {% if size == sample_size %}selected{% endif %}>{{ size }} contacts</option>
                        {% endfor %}
                    </select>
                </div>
                <button type="submit" class="btn btn-primary">Resample Contacts</button>
            </form>
        </div>
    </div>

    <!-- Search -->
    <div class="row mb-4">
        <div class="col">
            <form action="/check" method="post" class="form-inline">
                <input type="hidden" name="org_id" value="{{ org_id }}">
                <div class="form-group mr-2">
                    <label for="contact_search" class="mr-2">Search by Email or Contact ID</label>
                    <input type="text" class="form-control" id="contact_search" name="contact_search" 
                           placeholder="Enter email address or contact ID" value="{{ contact_search }}">
                </div>
                <button type="submit" class="btn btn-secondary">Search</button>
            </form>
        </div>
    </div>

    <!-- Contact Cards -->
    {% for contact_id, contact in contacts.items() %}
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">
                {{ contact.contact_info.name }} (ID: {{ contact.contact_info.id }})
            </h5>
        </div>
        <div class="card-body">
            <div class="row">
                <div class="col-md-4">
                    <p><strong>Email:</strong> {{ contact.contact_info.email }}</p>
                    <p><strong>Birth Date:</strong> {{ contact.contact_info.birth_date }}</p>
                    <p><strong>Effective Date:</strong> {{ contact.contact_info.effective_date }}</p>
                </div>
                <div class="col-md-8">
                    <div class="alert alert-info">
                        <h6>State: {{ contact.contact_info.state }} {% if contact.contact_info.state in special_rule_states %}<span class="badge badge-warning">Special Rules Apply</span>{% endif %}</h6>
                        {% if contact.scheduling_rules %}
                        <ul class="mb-0">
                            {% for rule in contact.scheduling_rules %}
                            <li>{{ rule }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                </div>
            </div>

            <h6 class="mt-3">Scheduled Emails:</h6>
            <table class="table table-sm table-hover">
                <thead class="thead-light">
                    <tr>
                        <th style="width: 20%">Type</th>
                        <th style="width: 15%">Date</th>
                        <th style="width: 15%">Default Date</th>
                        <th style="width: 15%">Status</th>
                        <th style="width: 35%">Details</th>
                    </tr>
                </thead>
                <tbody>
                    {% set ns = namespace(current_year=none) %}
                    {% for email in contact.timeline_data.email_list %}
                        {% set email_year = email.start.year if email.start is not string else email.start.split('-')[0] %}
                        {% if email_year != ns.current_year %}
                            {% if not loop.first %}
                                <tr><td colspan="5" style="padding: 0.5rem 0;"></td></tr>
                            {% endif %}
                            {% set ns.current_year = email_year %}
                            <tr class="year-divider">
                                <td colspan="5">
                                    <i class="fas fa-calendar-alt mr-2"></i>
                                    <strong>{{ email_year }}</strong>
                                </td>
                            </tr>
                        {% endif %}
                        <tr {% if email.skipped %}class="table-warning{% if loop.first or email_year != prev_year %} first-row-of-year{% endif %}"
                            {% else %}class="{% if loop.first or email_year != prev_year %}first-row-of-year{% endif %}"{% endif %}>
                            <td>
                                <span class="badge {% if email.type == 'birthday' %}bg-info
                                               {% elif email.type == 'effective_date' %}bg-primary
                                               {% elif email.type == 'aep' %}bg-success
                                               {% elif email.type == 'post_window' %}bg-warning
                                               {% else %}bg-secondary{% endif %}"
                                      style="font-size: 90%; padding: 5px 10px;">
                                    {{ email.type_display }}
                                </span>
                            </td>
                            <td>
                                <strong>{{ email.start.strftime('%b %d') if email.start is not string else email.start.split('-')[1:]|join(' ')|replace('-', ' ') }}</strong>
                            </td>
                            <td>
                                {% if email.default_date %}
                                    {% if email.default_date is string %}
                                        <small class="text-muted">{{ email.default_date }}</small>
                                    {% else %}
                                        <small class="text-muted">{{ email.default_date.strftime('%b %d, %Y') if email.default_date is not string else email.default_date }}</small>
                                    {% endif %}
                                {% endif %}
                            </td>
                            <td>
                                {% if email.skipped %}
                                <span class="badge bg-danger">Cancelled</span>
                                {% else %}
                                <span class="badge bg-success">Scheduled</span>
                                {% endif %}
                            </td>
                            <td>
                                {% if email.skipped %}
                                    <span class="text-danger">
                                        <i class="fas fa-info-circle"></i>
                                        {{ email.reason if email.reason and email.reason != 'nan' else 'Cancelled - No reason provided' }}
                                    </span>
                                {% else %}
                                    <div class="d-flex justify-content-between align-items-center">
                                        <span class="text-success">
                                            <i class="fas fa-check-circle"></i>
                                            Will be sent as scheduled
                                        </span>
                                        {% if email.link %}
                                        <a href="{{ email.link }}" class="btn btn-sm btn-outline-primary">
                                            <i class="fas fa-envelope"></i> View
                                        </a>
                                        {% endif %}
                                    </div>
                                {% endif %}
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endfor %}
</div>
{% endblock %}

================
File: templates/simulator.html
================
{% extends "base.html" %}

{% block head %}
<style>
    .year-divider {
        background-color: #f8f9fa !important;
        border-top: 2px solid #dee2e6;
        border-bottom: 1px solid #dee2e6;
    }
    
    .year-divider td {
        padding: 0.5rem 1rem !important;
        font-weight: 500;
        color: #495057;
    }
    
    .first-row-of-year {
        border-top: 1px solid #dee2e6;
    }
    
    #results {
        display: none;
    }
    
    .state-rules {
        margin-top: 1rem;
        padding: 1rem;
        background-color: #e3f2fd;
        border-radius: 0.25rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <h1 class="mb-4">Email Scheduler Simulator</h1>
    
    <div class="row">
        <div class="col-md-5">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="card-title mb-0">Contact Information</h5>
                </div>
                <div class="card-body">
                    <form id="simulatorForm" method="post" action="/simulate">
                        <div class="mb-3">
                            <label for="state" class="form-label">State</label>
                            <select class="form-select" id="state" name="state" required>
                                <option value="" selected disabled>Select a state...</option>
                                {% for state in all_states %}
                                <option value="{{ state }}" 
                                    {% if state in special_rule_states %}data-special="true"{% endif %}
                                    data-birthday="{% if state in birthday_rule_states %}true{% else %}false{% endif %}"
                                    data-effective="{% if state in effective_date_rule_states %}true{% else %}false{% endif %}"
                                    data-yearround="{% if state in year_round_enrollment_states %}true{% else %}false{% endif %}">
                                    {{ state }}
                                    {% if state in special_rule_states %}
                                        (Special Rules)
                                    {% endif %}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="birth_date" class="form-label">Birth Date</label>
                            <input type="date" class="form-control" id="birth_date" name="birth_date" value="1955-01-01" required>
                        </div>
                        
                        <div class="mb-3">
                            <label for="effective_date" class="form-label">Effective Date</label>
                            <input type="date" class="form-control" id="effective_date" name="effective_date" value="2022-01-01">
                            <div class="form-text">Policy effective/anniversary date</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="start_date" class="form-label">Start Date</label>
                            <input type="date" class="form-control" id="start_date" name="start_date" value="{{ today }}" required>
                            <div class="form-text">Beginning of scheduling window</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="end_date" class="form-label">End Date</label>
                            <input type="date" class="form-control" id="end_date" name="end_date" value="{{ next_year }}" required>
                            <div class="form-text">End of scheduling window</div>
                        </div>
                        
                        <button type="submit" class="btn btn-primary" id="calculateBtn">
                            <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                            Calculate Scheduled Emails
                        </button>
                    </form>
                </div>
            </div>
            
            <div id="stateRules" class="card mt-4 d-none">
                <div class="card-header bg-info text-white">
                    <h5 class="card-title mb-0">State Rules</h5>
                </div>
                <div class="card-body">
                    <div id="birthdayRuleInfo" class="d-none">
                        <h6>Birthday Rule</h6>
                        <div id="birthdayRuleDetails"></div>
                    </div>
                    
                    <div id="effectiveDateRuleInfo" class="d-none">
                        <h6>Effective Date Rule</h6>
                        <div id="effectiveDateRuleDetails"></div>
                    </div>
                    
                    <div id="yearRoundInfo" class="d-none">
                        <div class="alert alert-warning">
                            <strong>Year-Round Enrollment State</strong>
                            <p>No AEP or post-window emails are sent in this state.</p>
                        </div>
                    </div>
                    
                    <div id="regularRuleInfo" class="d-none">
                        <div class="alert alert-info">
                            <strong>Standard Rules</strong>
                            <p>This state follows the standard email scheduling rules:</p>
                            <ul class="mb-0">
                                <li>Birthday emails: 14 days before birthday</li>
                                <li>Effective date emails: 30 days before anniversary</li>
                                <li>AEP emails: Distributed across August/September</li>
                                <li>Post-window emails: Day after exclusion period</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-7 mt-3 mt-md-0">
            <!-- New Results Container that matches our JavaScript -->
            <div id="results" class="card">
                <div class="card-header bg-success text-white">
                    <h5 class="card-title mb-0">Simulation Results</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <h6>Contact Details</h6>
                            <p><strong>State:</strong> <span id="result-state"></span></p>
                            <p><strong>Birth Date:</strong> <span id="result-birth-date"></span></p>
                            <p><strong>Effective Date:</strong> <span id="result-effective-date"></span></p>
                        </div>
                        <div class="col-md-8">
                            <div class="state-rules">
                                <h6>State Rules</h6>
                                <ul id="state-rules-list"></ul>
                            </div>
                        </div>
                    </div>

                    <h6 class="mt-4">Scheduled Emails:</h6>
                    <table class="table table-sm table-hover">
                        <thead class="thead-light">
                            <tr>
                                <th style="width: 20%">Type</th>
                                <th style="width: 15%">Date</th>
                                <th style="width: 15%">Default Date</th>
                                <th style="width: 15%">Status</th>
                                <th style="width: 35%">Details</th>
                            </tr>
                        </thead>
                        <tbody id="email-results">
                            <!-- Email results will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Keep the old results container for backward compatibility -->
            <div id="resultsContainer" class="d-none">
                <div class="card">
                    <div class="card-header bg-success text-white">
                        <h5 class="card-title mb-0">Scheduled Emails</h5>
                    </div>
                    <div class="card-body">
                        <div id="emailResults"></div>
                    </div>
                </div>
                
                <div class="card mt-4">
                    <div class="card-header bg-secondary text-white">
                        <h5 class="card-title mb-0">Exclusion Periods</h5>
                    </div>
                    <div class="card-body">
                        <div id="exclusionResults"></div>
                    </div>
                </div>
                
                <div class="card mt-4">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="card-title mb-0">Important Dates</h5>
                    </div>
                    <div class="card-body">
                        <div id="birthdayResults" class="mb-4">
                            <h6>Birthdays in Period</h6>
                            <div id="birthdayDatesList"></div>
                        </div>
                        
                        <div id="effectiveDateResults" class="mb-4">
                            <h6>Effective Dates in Period</h6>
                            <div id="effectiveDatesList"></div>
                        </div>
                        
                        <div id="aepDateResults">
                            <h6>AEP Dates</h6>
                            <div id="aepDatesList"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Debug info panel -->
            <div class="card mt-4">
                <div class="card-header bg-dark text-white">
                    <h5 class="card-title mb-0">Debug Information</h5>
                </div>
                <div class="card-body">
                    <div id="debug-panel">
                        <pre id="debug-output" style="max-height: 200px; overflow-y: auto;"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Debugging helper
    function debugLog(message, data) {
        const debugOutput = document.getElementById('debug-output');
        const timestamp = new Date().toISOString().substring(11, 19);
        
        if (typeof data === 'object') {
            debugOutput.innerHTML += `[${timestamp}] ${message}:\n${JSON.stringify(data, null, 2)}\n\n`;
        } else {
            debugOutput.innerHTML += `[${timestamp}] ${message}: ${data}\n`;
        }
        
        // Auto-scroll to bottom
        debugOutput.scrollTop = debugOutput.scrollHeight;
        
        // Also log to console
        console.log(`[${timestamp}] ${message}:`, data);
    }

    debugLog('Page loaded', 'Simulator initialized');
    
    // Check if all necessary elements exist
    ['results', 'result-state', 'result-birth-date', 'result-effective-date', 
     'state-rules-list', 'email-results'].forEach(id => {
        const element = document.getElementById(id);
        debugLog(`Element #${id} exists`, element ? 'Yes' : 'No');
    });
    
    // Show loading spinner on form submit
    document.getElementById('simulatorForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const button = document.getElementById('calculateBtn');
        const spinner = button.querySelector('.spinner-border');
        button.disabled = true;
        spinner.classList.remove('d-none');
        
        // Collect form data
        const formData = new FormData(this);
        const jsonData = Object.fromEntries(formData);
        
        debugLog('Form submitted with data', jsonData);
        
        // Make API call to calculate scheduled emails
        fetch('/simulate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(jsonData),
        })
        .then(response => {
            debugLog('Response status', response.status);
            return response.json();
        })
        .then(data => {
            debugLog('Response data received', data);
            displayResults(data);
            button.disabled = false;
            spinner.classList.add('d-none');
        })
        .catch(error => {
            debugLog('Error in fetch', error.toString());
            alert('An error occurred while calculating scheduled emails.');
            button.disabled = false;
            spinner.classList.add('d-none');
        });
    });
    
    // Display state-specific rules when state is selected
    document.getElementById('state').addEventListener('change', function() {
        const selectedOption = this.options[this.selectedIndex];
        const hasBirthdayRule = selectedOption.getAttribute('data-birthday') === 'true';
        const hasEffectiveDateRule = selectedOption.getAttribute('data-effective') === 'true';
        const hasYearRoundEnrollment = selectedOption.getAttribute('data-yearround') === 'true';
        const stateCode = this.value;
        
        debugLog('State selected', {
            state: stateCode,
            hasBirthdayRule,
            hasEffectiveDateRule,
            hasYearRoundEnrollment
        });
        
        // Show state rules card
        document.getElementById('stateRules').classList.remove('d-none');
        
        // Reset all rule displays
        document.getElementById('birthdayRuleInfo').classList.add('d-none');
        document.getElementById('effectiveDateRuleInfo').classList.add('d-none');
        document.getElementById('yearRoundInfo').classList.add('d-none');
        document.getElementById('regularRuleInfo').classList.add('d-none');
        
        // Update rule displays based on state
        if (hasBirthdayRule) {
            document.getElementById('birthdayRuleInfo').classList.remove('d-none');
            updateBirthdayRuleInfo(stateCode);
        }
        
        if (hasEffectiveDateRule) {
            document.getElementById('effectiveDateRuleInfo').classList.remove('d-none');
            updateEffectiveDateRuleInfo(stateCode);
        }
        
        if (hasYearRoundEnrollment) {
            document.getElementById('yearRoundInfo').classList.remove('d-none');
        }
        
        if (!hasBirthdayRule && !hasEffectiveDateRule && !hasYearRoundEnrollment) {
            document.getElementById('regularRuleInfo').classList.remove('d-none');
        }
    });
    
    // Helper functions for state rule info
    function updateBirthdayRuleInfo(state) {
        const birthdayRuleDetails = document.getElementById('birthdayRuleDetails');
        
        // Define rule descriptions based on state
        const birthdayRules = {
            'CA': '60-day exclusion period: 30 days before and 30 days after birthday.',
            'ID': '63-day exclusion period: Starting on birthday and ending 63 days after.',
            'IL': '45-day exclusion period: Starting on birthday and ending 45 days after.',
            'KY': '60-day exclusion period: Starting on birthday and ending 60 days after.',
            'LA': '93-day exclusion period: 30 days before and 63 days after birthday.',
            'MD': '31-day exclusion period: Starting on birthday and ending 31 days after.',
            'NV': '60-day exclusion period: Starting on first day of birth month.',
            'OK': '60-day exclusion period: Starting on birthday and ending 60 days after.',
            'OR': '31-day exclusion period: Starting on birthday and ending 31 days after.'
        };
        
        birthdayRuleDetails.textContent = birthdayRules[state] || 'State has special birthday rules.';
    }
    
    function updateEffectiveDateRuleInfo(state) {
        const effectiveDateRuleDetails = document.getElementById('effectiveDateRuleDetails');
        
        // Define rule descriptions based on state
        const effectiveDateRules = {
            'MO': '63-day exclusion period: 30 days before and 33 days after the policy anniversary.',
        };
        
        effectiveDateRuleDetails.textContent = effectiveDateRules[state] || 'State has special effective date rules.';
    }
    
    // Function to display simulation results
    function displayResults(data) {
        debugLog('DisplayResults called with data', data);
        
        try {
            // Show results section
            const resultsElement = document.getElementById('results');
            if (resultsElement) {
                resultsElement.style.display = 'block';
                debugLog('Results element displayed', 'Success');
            } else {
                debugLog('Results element not found', 'ERROR');
            }
            
            // Update contact details
            const stateElement = document.getElementById('result-state');
            const birthDateElement = document.getElementById('result-birth-date');
            const effectiveDateElement = document.getElementById('result-effective-date');
            
            if (stateElement && data.contact_info && data.contact_info.state) {
                stateElement.textContent = data.contact_info.state;
                debugLog('Updated state', data.contact_info.state);
            } else {
                debugLog('State update failed', {
                    elementExists: !!stateElement,
                    contactInfoExists: !!data.contact_info,
                    stateExists: data.contact_info && !!data.contact_info.state
                });
            }
            
            if (birthDateElement && data.contact_info) {
                birthDateElement.textContent = data.contact_info.birth_date;
                debugLog('Updated birth date', data.contact_info.birth_date);
            }
            
            if (effectiveDateElement && data.contact_info) {
                effectiveDateElement.textContent = data.contact_info.effective_date || 'Not set';
                debugLog('Updated effective date', data.contact_info.effective_date || 'Not set');
            }
            
            // Update state rules
            const rulesListElement = document.getElementById('state-rules-list');
            if (rulesListElement && data.scheduling_rules) {
                rulesListElement.innerHTML = data.scheduling_rules.map(rule => `<li>${rule}</li>`).join('');
                debugLog('Updated rules list', data.scheduling_rules);
            } else {
                debugLog('Rules list update failed', {
                    elementExists: !!rulesListElement,
                    rulesExist: !!data.scheduling_rules
                });
            }
            
            // Update email results
            const emailResultsElement = document.getElementById('email-results');
            if (!emailResultsElement) {
                debugLog('Email results element not found', 'ERROR');
                return;
            }
            
            emailResultsElement.innerHTML = '';
            debugLog('Cleared email results', 'Success');
            
            // Check if email_list exists and has items
            const emailList = data.timeline_data && data.timeline_data.email_list ? data.timeline_data.email_list : [];
            debugLog('Email list', {
                exists: !!(data.timeline_data && data.timeline_data.email_list),
                length: emailList.length
            });
            
            if (emailList.length === 0) {
                emailResultsElement.innerHTML = '<tr><td colspan="5" class="text-center">No emails scheduled for this contact.</td></tr>';
                debugLog('No emails in list', 'Added placeholder row');
                return;
            }
            
            let currentYear = null;
            
            emailList.forEach((email, index) => {
                try {
                    // Extract year from the email date
                    const emailDate = new Date(email.start);
                    const emailYear = emailDate.getFullYear();
                    
                    debugLog(`Processing email ${index}`, {
                        type: email.type,
                        date: email.start,
                        year: emailYear
                    });
                    
                    if (emailYear !== currentYear) {
                        if (index > 0) {
                            emailResultsElement.innerHTML += `
                                <tr><td colspan="5" style="padding: 0.5rem 0;"></td></tr>
                            `;
                        }
                        
                        emailResultsElement.innerHTML += `
                            <tr class="year-divider">
                                <td colspan="5">
                                    <i class="fas fa-calendar-alt mr-2"></i>
                                    <strong>${emailYear}</strong>
                                </td>
                            </tr>
                        `;
                        currentYear = emailYear;
                        debugLog(`Added year divider for ${emailYear}`, 'Success');
                    }
                    
                    const formattedDate = emailDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    
                    let defaultDate = email.default_date;
                    if (defaultDate && typeof defaultDate !== 'string') {
                        defaultDate = new Date(defaultDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    }
                    
                    const typeDisplay = email.type_display || email.type;
                    const badgeClass = getBadgeClass(email.type);
                    
                    emailResultsElement.innerHTML += `
                        <tr class="${email.skipped ? 'table-warning' : ''} ${index === 0 || emailYear !== currentYear ? 'first-row-of-year' : ''}">
                            <td>
                                <span class="badge ${badgeClass}" style="font-size: 90%; padding: 5px 10px;">
                                    ${typeDisplay}
                                </span>
                            </td>
                            <td>
                                <strong>${formattedDate}</strong>
                            </td>
                            <td>
                                <small class="text-muted">${defaultDate || ''}</small>
                            </td>
                            <td>
                                <span class="badge ${email.skipped ? 'bg-danger' : 'bg-success'}">
                                    ${email.skipped ? 'Cancelled' : 'Scheduled'}
                                </span>
                            </td>
                            <td>
                                ${email.skipped ? 
                                    `<span class="text-danger">
                                        <i class="fas fa-info-circle"></i>
                                        ${email.reason || 'No reason provided'}
                                    </span>` :
                                    `<div class="d-flex justify-content-between align-items-center">
                                        <span class="text-success">
                                            <i class="fas fa-check-circle"></i>
                                            Will be sent as scheduled
                                        </span>
                                        ${email.link ? 
                                            `<a href="${email.link}" class="btn btn-sm btn-outline-primary">
                                                <i class="fas fa-envelope"></i> View
                                            </a>` : ''
                                        }
                                    </div>`
                                }
                            </td>
                        </tr>
                    `;
                    debugLog(`Added email row for ${email.type}`, 'Success');
                } catch (rowError) {
                    debugLog(`Error processing email row ${index}`, rowError.toString());
                }
            });
        } catch (error) {
            debugLog('Error in displayResults', error.toString());
            throw error;
        }
    }

    function getBadgeClass(type) {
        debugLog('Getting badge class for type', type);
        switch (type) {
            case 'birthday': return 'bg-info';
            case 'effective_date': return 'bg-primary';
            case 'aep': return 'bg-success';
            case 'post_window': return 'bg-warning';
            default: return 'bg-secondary';
        }
    }
});
</script>
{% endblock %}

================
File: templates/state_info.html
================
<div class="card border-info mb-3">
    <div class="card-header bg-info text-white">
        <strong>State: {{ contact_data.contact_info.state }}</strong>
        {% if contact_data.contact_info.state_info.has_birthday_rule or 
            contact_data.contact_info.state_info.has_effective_date_rule or 
            contact_data.contact_info.state_info.has_year_round_enrollment %}
        <span class="badge bg-light text-dark">Special Rules Apply</span>
        {% endif %}
    </div>
    <div class="card-body">
        {% if contact_data.contact_info.state_info.has_year_round_enrollment %}
        <div class="alert alert-warning">
            <strong>Year-Round Enrollment State</strong>
            <p class="mb-0 small">All emails are skipped because this state allows year-round enrollment.</p>
        </div>
        {% endif %}
        
        {% if contact_data.contact_info.state_info.has_birthday_rule %}
        <div class="mb-2">
            <strong class="text-primary">Birthday Rule</strong>
            <p class="mb-0 small">
                {% if contact_data.contact_info.state == "CA" %}
                60-day exclusion period: 30 days before and 30 days after birthday.
                {% elif contact_data.contact_info.state == "ID" %}
                63-day exclusion period: Starting on birthday and ending 63 days after.
                {% elif contact_data.contact_info.state == "IL" %}
                45-day exclusion period: Starting on birthday and ending 45 days after.
                {% elif contact_data.contact_info.state == "KY" %}
                60-day exclusion period: Starting on birthday and ending 60 days after.
                {% elif contact_data.contact_info.state == "LA" %}
                93-day exclusion period: 30 days before and 63 days after birthday.
                {% elif contact_data.contact_info.state == "MD" %}
                31-day exclusion period: Starting on birthday and ending 31 days after.
                {% elif contact_data.contact_info.state == "NV" %}
                60-day exclusion period: Starting on first day of birth month.
                {% elif contact_data.contact_info.state == "OK" %}
                60-day exclusion period: Starting on birthday and ending 60 days after.
                {% elif contact_data.contact_info.state == "OR" %}
                31-day exclusion period: Starting on birthday and ending 31 days after.
                {% endif %}
            </p>
        </div>
        {% endif %}
        
        {% if contact_data.contact_info.state_info.has_effective_date_rule %}
        <div class="mb-2">
            <strong class="text-success">Effective Date Rule</strong>
            <p class="mb-0 small">
                {% if contact_data.contact_info.state == "MO" %}
                63-day exclusion period: 30 days before and 33 days after the policy anniversary.
                {% endif %}
            </p>
        </div>
        {% endif %}
        
        <div class="mb-0 small text-muted">
            <p class="mb-0"><strong>Standard Scheduling Rules:</strong></p>
            <ul class="ps-3 mb-0">
                <li>Birthday emails: 14 days before birthday</li>
                <li>Effective date emails: 30 days before anniversary</li>
                <li>AEP emails: Distributed across August/September</li>
                <li>Post-window emails: Day after exclusion period</li>
            </ul>
        </div>
    </div>
</div>

================
File: templates/timeline.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Schedule Timeline - {{ org.name }}</title>
    <style>
        :root {
            --birthday-color: #4285F4;    /* Blue */
            --effective-date-color: #34A853; /* Green */
            --aep-color: #FBBC05;         /* Yellow */
            --post-window-color: #EA4335; /* Red */
            --rule-window-color: #9C27B0; /* Purple */
            --exclusion-color: #9AA0A6;   /* Gray */
            --skipped-opacity: 0.5;
            --timeline-background: #f8f9fa;
            --timeline-line: #dadce0;
            --font-primary: 'Google Sans', 'Roboto', Arial, sans-serif;
            --font-color: #202124;
            --font-color-secondary: #5f6368;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-primary);
            margin: 0;
            padding: 20px;
            color: var(--font-color);
            background-color: var(--timeline-background);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            padding: 24px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        h1 {
            color: var(--font-color);
            margin: 0;
            font-size: 24px;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            margin-bottom: 20px;
            color: #1a73e8;
            text-decoration: none;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .back-link svg {
            margin-right: 6px;
        }
        
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 24px;
            padding: 16px;
            background-color: var(--timeline-background);
            border-radius: 8px;
        }
        
        .filter-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid transparent;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            color: var(--font-color);
        }
        
        .filter-btn .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .filter-btn.active {
            background-color: #e8f0fe;
            border-color: #1a73e8;
        }
        
        .filter-btn:hover {
            background-color: #f1f3f4;
        }
        
        .filter-btn.birthday .color-dot {
            background-color: var(--birthday-color);
        }
        
        .filter-btn.effective_date .color-dot {
            background-color: var(--effective-date-color);
        }
        
        .filter-btn.aep .color-dot {
            background-color: var(--aep-color);
        }
        
        .filter-btn.post_window .color-dot {
            background-color: var(--post-window-color);
        }
        
        .filter-btn.rule_window .color-dot {
            background-color: var(--rule-window-color);
        }
        
        .filter-btn.exclusion .color-dot {
            background-color: var(--exclusion-color);
        }
        
        .timeline-header {
            position: relative;
            margin-bottom: 24px;
            margin-left: 200px;
        }
        
        .timeline-axis {
            position: relative;
            display: flex;
            border-bottom: 1px solid var(--timeline-line);
            padding-bottom: 4px;
        }
        
        .timeline-axis .month {
            font-size: 12px;
            color: var(--font-color-secondary);
            text-align: center;
            text-transform: uppercase;
            flex: 1;
        }
        
        .timeline-ruler {
            position: relative;
            height: 20px;
        }
        
        .timeline-ruler .tick {
            position: absolute;
            width: 1px;
            height: 6px;
            background-color: var(--timeline-line);
            top: 0;
        }
        
        .timeline-ruler .tick.first-of-month {
            height: 10px;
        }
        
        .timeline-ruler .date-label {
            position: absolute;
            font-size: 10px;
            color: var(--font-color-secondary);
            top: 12px;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        .contacts-container {
            max-height: 700px;
            overflow-y: auto;
            padding-right: 16px;
        }
        
        .contact-timeline {
            margin-bottom: 32px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 1px 2px rgba(60,64,67,0.3);
            overflow: hidden;
        }
        
        .contact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background-color: #f8f9fa;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        .contact-info h3 {
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 500;
        }
        
        .contact-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: var(--font-color-secondary);
        }
        
        .contact-details .detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .detail-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }
        
        .view-quote-btn {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .view-quote-btn:hover {
            background-color: #1765cc;
        }
        
        .timeline-lanes {
            position: relative;
            padding: 24px 16px 24px 200px;
        }
        
        .lane {
            position: relative;
            height: 40px;
            margin-bottom: 16px;
        }
        
        .lane-label {
            position: absolute;
            left: -180px;
            top: 10px;
            width: 160px;
            text-align: right;
            font-size: 14px;
            color: var(--font-color-secondary);
            font-weight: 500;
        }
        
        .lane-track {
            position: relative;
            height: 100%;
            background-color: #f1f3f4;
            border-radius: 4px;
        }
        
        .timeline-item {
            position: absolute;
            height: 28px;
            top: 6px;
            border-radius: 14px;
            color: white;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 12px;
            cursor: pointer;
            z-index: 3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 70px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .timeline-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 4;
        }
        
        .timeline-item.birthday {
            background-color: var(--birthday-color);
        }
        
        .timeline-item.effective_date {
            background-color: var(--effective-date-color);
        }
        
        .timeline-item.aep {
            background-color: var(--aep-color);
            color: #202124;
        }
        
        .timeline-item.post_window {
            background-color: var(--post-window-color);
        }
        
        .timeline-item.skipped {
            opacity: var(--skipped-opacity);
            border: 2px dashed rgba(255,255,255,0.8);
        }
        
        .rule-window {
            position: absolute;
            height: 20px;
            top: 10px;
            background-color: var(--rule-window-color);
            opacity: 0.3;
            border-radius: 4px;
            z-index: 1;
            cursor: pointer;
        }
        
        .exclusion-window {
            position: absolute;
            height: 40px;
            top: 0;
            background-color: var(--exclusion-color);
            opacity: 0.3;
            border-radius: 4px;
            z-index: 2;
            cursor: pointer;
        }
        
        .tooltip {
            position: fixed;
            background-color: white;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
            min-width: 220px;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .tooltip-header {
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--font-color);
            padding-bottom: 4px;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        .tooltip-content {
            font-size: 13px;
            color: var(--font-color-secondary);
        }
        
        .tooltip-row {
            display: flex;
            margin-bottom: 4px;
        }
        
        .tooltip-label {
            flex: 0 0 70px;
            font-weight: 500;
        }
        
        .tooltip-value {
            flex: 1;
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: var(--font-color-secondary);
            background-color: var(--timeline-background);
            border-radius: 8px;
            font-size: 16px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #1a73e8;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--timeline-line);
        }
        
        .action-btn {
            padding: 8px 16px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
        }
        
        .action-btn:hover {
            background-color: #1765cc;
        }
        
        .action-btn svg {
            margin-right: 8px;
        }
        
        @media (max-width: 768px) {
            .timeline-header {
                margin-left: 0;
            }
            
            .timeline-lanes {
                padding-left: 16px;
            }
            
            .lane-label {
                position: relative;
                left: 0;
                top: 0;
                width: 100%;
                text-align: left;
                margin-bottom: 4px;
            }
            
            .lane {
                height: auto;
                margin-bottom: 24px;
            }
            
            .lane-track {
                margin-top: 24px;
            }
            
            .contact-details {
                flex-direction: column;
                gap: 4px;
            }
            
            .contact-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .view-quote-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/org/{{ org.id }}" class="back-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Back to Organization
        </a>
        
        <header>
            <h1>Email Schedule Timeline - {{ org.name }}</h1>
            <div class="controls">
                <label for="zoom-level">Zoom:</label>
                <select id="zoom-level">
                    <option value="5">5 days/px</option>
                    <option value="3">3 days/px</option>
                    <option value="2" selected>2 days/px</option>
                    <option value="1">1 day/px</option>
                    <option value="0.5">0.5 days/px</option>
                </select>
            </div>
        </header>
        
        <div class="filters" id="filters">
            <button class="filter-btn birthday active" data-type="birthday">
                <span class="color-dot"></span>
                <span>Birthday</span>
            </button>
            <button class="filter-btn effective_date active" data-type="effective_date">
                <span class="color-dot"></span>
                <span>Effective Date</span>
            </button>
            <button class="filter-btn aep active" data-type="aep">
                <span class="color-dot"></span>
                <span>AEP</span>
            </button>
            <button class="filter-btn post_window active" data-type="post_window">
                <span class="color-dot"></span>
                <span>Post Window</span>
            </button>
            <button class="filter-btn rule_window active" data-type="rule_window">
                <span class="color-dot"></span>
                <span>Rule Windows</span>
            </button>
            <button class="filter-btn exclusion active" data-type="exclusion">
                <span class="color-dot"></span>
                <span>Exclusion Windows</span>
            </button>
        </div>
        
        <div class="timeline-header" id="timeline-header"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing data...</p>
        </div>
        
        <div class="contacts-container" id="contacts-container">
            <div class="no-data" id="no-data">
                <p>Loading timeline data...</p>
            </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
        
        <div class="actions">
            <a href="/export/csv/{{ session_id }}" class="action-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Export CSV
            </a>
        </div>
    </div>

    <script>
        // Constants
        const MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const MONTH_NAMES_SHORT = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // State
        let timelineData = {{ timeline_data|safe }};
        let startDate = new Date();
        startDate.setDate(1);
        startDate.setMonth(startDate.getMonth() - 1);
        
        let endDate = new Date(startDate);
        endDate.setFullYear(endDate.getFullYear() + 1);
        
        let zoomLevel = 2; // days per pixel
        
        let filters = {
            birthday: true,
            effective_date: true,
            aep: true,
            post_window: true,
            rule_window: true,
            exclusion: true
        };
        
        // DOM Elements
        const timelineHeader = document.getElementById('timeline-header');
        const contactsContainer = document.getElementById('contacts-container');
        const tooltip = document.getElementById('tooltip');
        const noData = document.getElementById('no-data');
        const loading = document.getElementById('loading');
        const zoomSelect = document.getElementById('zoom-level');
        const filtersContainer = document.getElementById('filters');
        
        // Event Listeners
        zoomSelect.addEventListener('change', (e) => {
            zoomLevel = parseFloat(e.target.value);
            renderTimeline();
        });
        
        filtersContainer.addEventListener('click', (e) => {
            const button = e.target.closest('.filter-btn');
            if (button) {
                const type = button.dataset.type;
                filters[type] = !filters[type];
                button.classList.toggle('active');
                updateVisibility();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (tooltip.style.opacity !== '0') {
                tooltip.style.left = (e.pageX + 10) + 'px';
                tooltip.style.top = (e.pageY + 10) + 'px';
            }
        });
        
        // Functions
        function parseDate(dateString) {
            if (!dateString || dateString.trim() === '') return null;
            
            // Try standard ISO format
            const date = new Date(dateString);
            if (!isNaN(date.getTime())) return date;
            
            // Try MM/DD/YYYY format
            const parts = dateString.split(/[\/\-]/);
            if (parts.length === 3) {
                // Check if month is first (MM/DD/YYYY)
                if (parseInt(parts[0]) <= 12) {
                    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));
                }
                // Check if year is first (YYYY/MM/DD)
                else if (parseInt(parts[0]) > 31) {
                    return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                }
            }
            
            console.warn(`Could not parse date: ${dateString}`);
            return null;
        }
        
        function updateDateRange() {
            if (timelineData.length === 0) return;
            
            // Find earliest and latest dates in the data
            let earliestDate = new Date();
            let latestDate = new Date(0);
            
            timelineData.forEach(item => {
                if (item.date) {
                    const date = parseDate(item.date);
                    if (date && date < earliestDate) {
                        earliestDate = date;
                    }
                    if (date && date > latestDate) {
                        latestDate = date;
                    }
                }
                
                if (item.end_date) {
                    const endDate = parseDate(item.end_date);
                    if (endDate && endDate > latestDate) {
                        latestDate = endDate;
                    }
                }
            });
            
            // Set start date to beginning of month of earliest date
            startDate = new Date(earliestDate);
            startDate.setDate(1);
            startDate.setMonth(startDate.getMonth() - 1);
            
            // Set end date to end of month of latest date
            endDate = new Date(latestDate);
            endDate.setMonth(endDate.getMonth() + 2, 0);
        }
        
        function renderTimeline() {
            // Show loading
            loading.style.display = 'block';
            noData.style.display = 'none';
            
            // Update date range based on data
            updateDateRange();
            
            // Clear containers
            timelineHeader.innerHTML = '';
            contactsContainer.innerHTML = '';
            
            if (timelineData.length === 0) {
                noData.style.display = 'block';
                loading.style.display = 'none';
                return;
            }
            
            // Render timeline header
            renderTimelineHeader();
            
            // Group data by contact
            const contactsMap = groupByContact(timelineData);
            
            // Render contact timelines
            Object.values(contactsMap).forEach(contact => {
                renderContactTimeline(contact);
            });
            
            // Update visibility based on filters
            updateVisibility();
            
            // Hide loading
            loading.style.display = 'none';
        }
        
        function renderTimelineHeader() {
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            const totalWidth = Math.ceil(totalDays / zoomLevel);
            
            // Create months axis
            const timelineAxis = document.createElement('div');
            timelineAxis.className = 'timeline-axis';
            timelineAxis.style.width = totalWidth + 'px';
            
            // Add months
            let currentDate = new Date(startDate);
            while (currentDate < endDate) {
                const monthStart = new Date(currentDate);
                
                currentDate.setMonth(currentDate.getMonth() + 1);
                
                const daysInMonth = Math.floor((currentDate - monthStart) / (1000 * 60 * 60 * 24));
                const monthWidth = Math.ceil(daysInMonth / zoomLevel);
                
                const month = document.createElement('div');
                month.className = 'month';
                month.textContent = MONTH_NAMES_SHORT[monthStart.getMonth()];
                month.style.width = monthWidth + 'px';
                
                timelineAxis.appendChild(month);
            }
            
            // Create ruler
            const timelineRuler = document.createElement('div');
            timelineRuler.className = 'timeline-ruler';
            timelineRuler.style.width = totalWidth + 'px';
            
            // Add ticks for days
            currentDate = new Date(startDate);
            let position = 0;
            
            while (currentDate <= endDate) {
                if (currentDate.getDate() % 5 === 1 || currentDate.getDate() === 1) {
                    const tick = document.createElement('div');
                    tick.className = `tick ${currentDate.getDate() === 1 ? 'first-of-month' : ''}`;
                    tick.style.left = position + 'px';
                    
                    if (currentDate.getDate() === 1 || (zoomLevel <= 1 && currentDate.getDate() % 5 === 1)) {
                        const dateLabel = document.createElement('div');
                        dateLabel.className = 'date-label';
                        dateLabel.textContent = currentDate.getDate() === 1 
                            ? `${MONTH_NAMES_SHORT[currentDate.getMonth()]} 1` 
                            : currentDate.getDate();
                        dateLabel.style.left = position + 'px';
                        timelineRuler.appendChild(dateLabel);
                    }
                    
                    timelineRuler.appendChild(tick);
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
                position = Math.ceil((currentDate - startDate) / (1000 * 60 * 60 * 24) / zoomLevel);
            }
            
            timelineHeader.appendChild(timelineAxis);
            timelineHeader.appendChild(timelineRuler);
        }
        
        function groupByContact(data) {
            const contacts = {};
            
            data.forEach(item => {
                const contactId = item.contact_id;
                
                if (!contacts[contactId]) {
                    contacts[contactId] = {
                        org_id: item.org_id,
                        contact_id: contactId,
                        first_name: item.first_name,
                        last_name: item.last_name,
                        email: item.email,
                        state: item.state,
                        birth_date: item.birth_date,
                        effective_date: item.effective_date,
                        items: []
                    };
                }
                
                contacts[contactId].items.push(item);
            });
            
            return contacts;
        }
        
        function renderContactTimeline(contact) {
            const contactTimeline = document.createElement('div');
            contactTimeline.className = 'contact-timeline';
            contactTimeline.dataset.contactId = contact.contact_id;
            
            // Create contact header
            const contactHeader = document.createElement('div');
            contactHeader.className = 'contact-header';
            
            const contactInfo = document.createElement('div');
            contactInfo.className = 'contact-info';
            
            const contactName = document.createElement('h3');
            contactName.textContent = `${contact.first_name} ${contact.last_name}`;
            
            const contactDetails = document.createElement('div');
            contactDetails.className = 'contact-details';
            
            // Email
            const emailDetail = document.createElement('div');
            emailDetail.className = 'detail';
            emailDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                    <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
                <span>${contact.email}</span>
            `;
            
            // State
            const stateDetail = document.createElement('div');
            stateDetail.className = 'detail';
            stateDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                <span>${contact.state}</span>
            `;
            
            // Contact ID
            const idDetail = document.createElement('div');
            idDetail.className = 'detail';
            idDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
                <span>ID: ${contact.contact_id}</span>
            `;
            
            contactDetails.appendChild(emailDetail);
            contactDetails.appendChild(stateDetail);
            contactDetails.appendChild(idDetail);
            
            contactInfo.appendChild(contactName);
            contactInfo.appendChild(contactDetails);
            
            // Create quote button
            const quoteBtn = document.createElement('button');
            quoteBtn.className = 'view-quote-btn';
            quoteBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M16 12l-4 4-4-4M12 8v7"></path>
                </svg>
                View Quote
            `;
            
            // Find first email with a link
            const firstItemWithLink = contact.items.find(item => item.link && item.link.trim() !== '');
            const quoteLink = firstItemWithLink ? firstItemWithLink.link : `https://example.com/quote/${contact.org_id}/${contact.contact_id}`;
            
            quoteBtn.addEventListener('click', () => {
                window.open(quoteLink, '_blank');
            });
            
            contactHeader.appendChild(contactInfo);
            contactHeader.appendChild(quoteBtn);
            
            contactTimeline.appendChild(contactHeader);
            
            // Create timeline lanes
            const timelineLanes = document.createElement('div');
            timelineLanes.className = 'timeline-lanes';
            
            // Create lanes for email types
            const laneTypes = ['birthday', 'effective_date', 'aep', 'post_window'];
            
            laneTypes.forEach(type => {
                const lane = createLane(type, contact);
                timelineLanes.appendChild(lane);
            });
            
            contactTimeline.appendChild(timelineLanes);
            contactsContainer.appendChild(contactTimeline);
        }
        
        function createLane(type, contact) {
            const lane = document.createElement('div');
            lane.className = 'lane';
            lane.dataset.type = type;
            
            const laneLabel = document.createElement('div');
            laneLabel.className = 'lane-label';
            laneLabel.textContent = formatLaneLabel(type);
            
            const laneTrack = document.createElement('div');
            laneTrack.className = 'lane-track';
            
            // Calculate total width
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            const totalWidth = Math.ceil(totalDays / zoomLevel);
            laneTrack.style.width = totalWidth + 'px';
            
            // Add exclusion windows
            const exclusionItems = contact.items.filter(item => 
                item.item_type === 'exclusion' && 
                item.date && 
                item.end_date
            );
            
            exclusionItems.forEach(item => {
                const startDateObj = parseDate(item.date);
                const endDateObj = parseDate(item.end_date);
                
                if (startDateObj && endDateObj) {
                    const exclusion = document.createElement('div');
                    exclusion.className = 'exclusion-window';
                    exclusion.dataset.type = 'exclusion';
                    
                    const position = getPositionFromDate(startDateObj);
                    const width = getWidthBetweenDates(startDateObj, endDateObj);
                    
                    exclusion.style.left = position + 'px';
                    exclusion.style.width = width + 'px';
                    
                    exclusion.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: 'Exclusion Window',
                            date: formatDate(startDateObj),
                            end_date: formatDate(endDateObj),
                            description: item.description
                        });
                    });
                    
                    exclusion.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(exclusion);
                }
            });
            
            // Add rule windows
            const ruleWindowItems = contact.items.filter(item => 
                item.item_type === 'rule_window' && 
                item.date && 
                item.end_date
            );
            
            ruleWindowItems.forEach(item => {
                const startDateObj = parseDate(item.date);
                const endDateObj = parseDate(item.end_date);
                
                if (startDateObj && endDateObj) {
                    const ruleWindow = document.createElement('div');
                    ruleWindow.className = 'rule-window';
                    ruleWindow.dataset.type = 'rule_window';
                    
                    const position = getPositionFromDate(startDateObj);
                    const width = getWidthBetweenDates(startDateObj, endDateObj);
                    
                    ruleWindow.style.left = position + 'px';
                    ruleWindow.style.width = width + 'px';
                    
                    ruleWindow.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: 'Rule Window',
                            date: formatDate(startDateObj),
                            end_date: formatDate(endDateObj),
                            description: item.description
                        });
                    });
                    
                    ruleWindow.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(ruleWindow);
                }
            });
            
            // Add email items
            const emailItems = contact.items.filter(item => 
                item.item_type === type && 
                item.date
            );
            
            emailItems.forEach(item => {
                const dateObj = parseDate(item.date);
                
                if (dateObj) {
                    const timelineItem = document.createElement('div');
                    timelineItem.className = `timeline-item ${type}`;
                    timelineItem.dataset.type = type;
                    
                    if (item.skipped === 'Yes') {
                        timelineItem.classList.add('skipped');
                    }
                    
                    const position = getPositionFromDate(dateObj);
                    timelineItem.style.left = position + 'px';
                    
                    timelineItem.textContent = formatDate(dateObj, true);
                    
                    timelineItem.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: `${formatLaneLabel(type)} Email${item.skipped === 'Yes' ? ' (Skipped)' : ''}`,
                            date: formatDate(dateObj),
                            reason: item.reason,
                            description: item.description
                        });
                    });
                    
                    timelineItem.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(timelineItem);
                }
            });
            
            lane.appendChild(laneLabel);
            lane.appendChild(laneTrack);
            
            return lane;
        }
        
        function getPositionFromDate(date) {
            const daysSinceStart = Math.ceil((date - startDate) / (1000 * 60 * 60 * 24));
            return Math.floor(daysSinceStart / zoomLevel);
        }
        
        function getWidthBetweenDates(startDate, endDate) {
            const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            return Math.max(Math.floor(daysDiff / zoomLevel), 1);
        }
        
        function formatLaneLabel(type) {
            switch (type) {
                case 'birthday': return 'Birthday';
                case 'effective_date': return 'Effective Date';
                case 'aep': return 'AEP';
                case 'post_window': return 'Post Window';
                default: return type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
        }
        
        function formatDate(date, short = false) {
            if (!date) return '';
            
            if (short) {
                return `${MONTH_NAMES_SHORT[date.getMonth()]} ${date.getDate()}`;
            }
            
            return `${MONTH_NAMES[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }
        
        function showTooltip(data) {
            tooltip.innerHTML = `
                <div class="tooltip-header">${data.title}</div>
                <div class="tooltip-content">
                    <div class="tooltip-row">
                        <div class="tooltip-label">Date:</div>
                        <div class="tooltip-value">${data.date}</div>
                    </div>
                    ${data.end_date ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">End Date:</div>
                        <div class="tooltip-value">${data.end_date}</div>
                    </div>
                    ` : ''}
                    ${data.reason ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">Reason:</div>
                        <div class="tooltip-value">${data.reason}</div>
                    </div>
                    ` : ''}
                    ${data.description ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">Details:</div>
                        <div class="tooltip-value">${data.description}</div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            tooltip.style.opacity = '1';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = '0';
        }
        
        function updateVisibility() {
            // Update visibility based on filters
            for (const type in filters) {
                const visible = filters[type];
                
                // Update items
                document.querySelectorAll(`[data-type="${type}"]`).forEach(el => {
                    el.style.display = visible ? '' : 'none';
                });
            }
        }
        
        // Initialize
        function init() {
            // Set initial zoom level
            zoomSelect.value = zoomLevel.toString();
            
            // Add an event listener for escape key to hide tooltip
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideTooltip();
                }
            });
            
            // Render timeline
            renderTimeline();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>

================
File: app.py
================
from fastapi import FastAPI, Request, Form, Body
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from pydantic import BaseModel
import pandas as pd
import tempfile
import os
from datetime import date, datetime, timedelta
import asyncio
from typing import Optional, List, Dict, Any
import random
import json
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class CustomJSONEncoder(json.JSONEncoder):
    """Custom JSON encoder to handle dates and other special types"""
    def default(self, obj):
        if isinstance(obj, (date, datetime)):
            return obj.isoformat()
        if isinstance(obj, type):
            return str(obj)
        if callable(obj):
            return str(obj)
        return super().default(obj)

# Import our updated email scheduling code
from email_scheduler_optimized import (
    EmailScheduler,
    AsyncEmailProcessor,
    main_async,
    main_sync
)

from contact_rule_engine import ContactRuleEngine
from email_scheduler_common import (
    ALL_STATES,
)

# Import our database and formatting functions
from org_utils import (
    get_organization_details,
    get_contacts_from_org_db,
    format_contact_data,
)

# Database paths setup
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
main_db = os.path.join(BASE_DIR, "main.db")
org_db_dir = os.path.join(BASE_DIR, "org_dbs")

# Create org_dbs directory if it doesn't exist
os.makedirs(org_db_dir, exist_ok=True)

reload_db = False # set to True to refresh the database

async def refresh_databases(org_id: int) -> None:
    """
    Refresh databases by running dump_and_convert.sh script if reload is enabled
    
    Args:
        org_id: Organization ID to refresh
    """
    if reload_db:
        # Run dump_and_convert.sh with the org ID
        print(f"Refreshing database for org {org_id}")
        process = await asyncio.create_subprocess_shell(
            f"./dump_and_convert.sh {org_id}",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        # Wait for process to complete
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            # Log error but continue
            print(f"Warning: Database refresh failed for org {org_id}")
            if stderr:
                print(f"Error: {stderr.decode()}")
    else:
        print(f"Skipping database refresh for org {org_id}")


app = FastAPI(title="Email Schedule Checker")

# Set up Jinja2 templates
templates = Jinja2Templates(directory="templates")

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Store DataFrames in memory (key: org_id)
org_data_store = {}

# Initialize our rule engine and scheduler
rule_engine = ContactRuleEngine()
email_scheduler = EmailScheduler()

# Get list of states with special rules from rule engine
SPECIAL_RULE_STATES = sorted(rule_engine.get_special_rule_states())

# Get state rules
BIRTHDAY_RULE_STATES = {state: rule_engine.get_state_rule(state) for state in rule_engine.state_rules if rule_engine.get_state_rule(state).get('type') == 'birthday'}
EFFECTIVE_DATE_RULE_STATES = {state: rule_engine.get_state_rule(state) for state in rule_engine.state_rules if rule_engine.get_state_rule(state).get('type') == 'effective_date'}
YEAR_ROUND_ENROLLMENT_STATES = [state for state in rule_engine.state_rules if rule_engine.is_year_round_enrollment_state(state)]

def get_all_occurrences(base_date: date, start_date: date, end_date: date) -> List[date]:
    """
    Get all yearly occurrences of a date between start_date and end_date
    
    Args:
        base_date: The reference date
        start_date: Start of the range
        end_date: End of the range
        
    Returns:
        List of dates for each yearly occurrence
    """
    if not base_date or not start_date or not end_date:
        return []
        
    dates = []
    current_year = start_date.year
    while current_year <= end_date.year:
        try:
            yearly_date = date(current_year, base_date.month, base_date.day)
            if start_date <= yearly_date <= end_date:
                dates.append(yearly_date)
        except ValueError:
            # Handle Feb 29 in non-leap years
            if base_date.month == 2 and base_date.day == 29:
                yearly_date = date(current_year, 2, 28)
                if start_date <= yearly_date <= end_date:
                    dates.append(yearly_date)
        current_year += 1
    return dates

def sample_contacts_from_states(unique_contacts: pd.DataFrame, sample_size: int, state: Optional[str] = None) -> List[str]:
    """
    Sample contacts ensuring a good distribution across states
    
    Args:
        unique_contacts: DataFrame of unique contacts with their states
        sample_size: Number of contacts to sample
        state: Optional specific state to filter by
        
    Returns:
        List of sampled contact IDs
    """
    sample_ids = []
    
    # If filtering by specific state, do simple random sample
    if state and state.strip():
        state_contacts = unique_contacts[unique_contacts['state'] == state]
        if len(state_contacts) > 0:
            sample_ids = random.sample(
                list(state_contacts['contact_id']), 
                min(sample_size, len(state_contacts))
            )
        return sample_ids
    
    # Get contacts grouped by state
    states_contacts = {
        state: group['contact_id'].tolist() 
        for state, group in unique_contacts.groupby('state')
    }
    
    # If we have fewer states than sample size, adjust distribution
    states_count = len(states_contacts)
    if states_count == 0:
        return []
    
    # Calculate initial distribution
    if states_count >= sample_size:
        # If we have more states than sample size, randomly select states
        selected_states = random.sample(list(states_contacts.keys()), sample_size)
        # Take one contact from each selected state
        for state in selected_states:
            if states_contacts[state]:
                contact = random.choice(states_contacts[state])
                sample_ids.append(contact)
    else:
        # Distribute samples across states as evenly as possible
        base_per_state = sample_size // states_count
        extra = sample_size % states_count
        
        # Shuffle states to randomize which ones get extra samples
        state_list = list(states_contacts.keys())
        random.shuffle(state_list)
        
        # Distribute samples
        for i, state in enumerate(state_list):
            # Calculate how many samples for this state
            state_sample_size = base_per_state + (1 if i < extra else 0)
            state_contacts = states_contacts[state]
            
            # If we don't have enough contacts in this state, take what we can
            state_sample_size = min(state_sample_size, len(state_contacts))
            
            if state_sample_size > 0:
                state_samples = random.sample(state_contacts, state_sample_size)
                sample_ids.extend(state_samples)
    
    # If we still need more samples, take them randomly from remaining contacts
    if len(sample_ids) < sample_size:
        remaining_contacts = [
            cid for cid in unique_contacts['contact_id'] 
            if cid not in sample_ids
        ]
        if remaining_contacts:
            additional_needed = sample_size - len(sample_ids)
            additional_samples = random.sample(
                remaining_contacts,
                min(additional_needed, len(remaining_contacts))
            )
            sample_ids.extend(additional_samples)
    
    return sample_ids

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Render the home page with organization input form"""
    return templates.TemplateResponse(
        "home.html",
        {
            "request": request,
            "title": "Email Schedule Checker",
            "sample_sizes": [5, 10, 25, 50, 100],
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "state_rules": {
                state: {
                    "has_birthday_rule": state in BIRTHDAY_RULE_STATES,
                    "has_effective_date_rule": state in EFFECTIVE_DATE_RULE_STATES,
                    "has_year_round_enrollment": state in YEAR_ROUND_ENROLLMENT_STATES
                }
                for state in ALL_STATES
            }
        }
    )

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Display a live dashboard of scheduled emails by state"""
    # Initialize data counters
    email_counts_by_state = {state: {
        "birthday": 0,
        "effective_date": 0,
        "aep": 0,
        "post_window": 0,
        "total": 0,
        "skipped": 0,
        "has_special_rule": state in SPECIAL_RULE_STATES
    } for state in ALL_STATES}
    
    # Placeholder data - in a real app, this would come from database
    total_emails = 0
    total_skipped = 0
    
    # Add dummy data for demonstration
    for state in SPECIAL_RULE_STATES:
        email_counts_by_state[state]["birthday"] = random.randint(10, 50)
        email_counts_by_state[state]["effective_date"] = random.randint(5, 40)
        email_counts_by_state[state]["aep"] = random.randint(0, 30) if state not in YEAR_ROUND_ENROLLMENT_STATES else 0
        email_counts_by_state[state]["post_window"] = random.randint(0, 20) if state not in YEAR_ROUND_ENROLLMENT_STATES else 0
        email_counts_by_state[state]["skipped"] = random.randint(1, 10)
        email_counts_by_state[state]["total"] = (
            email_counts_by_state[state]["birthday"] + 
            email_counts_by_state[state]["effective_date"] + 
            email_counts_by_state[state]["aep"] + 
            email_counts_by_state[state]["post_window"]
        )
        
        total_emails += email_counts_by_state[state]["total"]
        total_skipped += email_counts_by_state[state]["skipped"]
    
    # Add some data for non-special states
    for i, state in enumerate(list(set(ALL_STATES) - set(SPECIAL_RULE_STATES))):
        if i < 10:  # Only populate some non-special states
            email_counts_by_state[state]["birthday"] = random.randint(5, 30)
            email_counts_by_state[state]["effective_date"] = random.randint(3, 25)
            email_counts_by_state[state]["aep"] = random.randint(0, 20)
            email_counts_by_state[state]["post_window"] = random.randint(0, 15)
            email_counts_by_state[state]["skipped"] = random.randint(0, 5)
            email_counts_by_state[state]["total"] = (
                email_counts_by_state[state]["birthday"] + 
                email_counts_by_state[state]["effective_date"] + 
                email_counts_by_state[state]["aep"] + 
                email_counts_by_state[state]["post_window"]
            )
            
            total_emails += email_counts_by_state[state]["total"]
            total_skipped += email_counts_by_state[state]["skipped"]
    
    # Calculate percentages for total stats
    email_type_totals = {
        "birthday": sum(state_data["birthday"] for state_data in email_counts_by_state.values()),
        "effective_date": sum(state_data["effective_date"] for state_data in email_counts_by_state.values()),
        "aep": sum(state_data["aep"] for state_data in email_counts_by_state.values()),
        "post_window": sum(state_data["post_window"] for state_data in email_counts_by_state.values()),
    }
    
    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "title": "Email Scheduling Dashboard",
            "email_counts": email_counts_by_state,
            "total_emails": total_emails,
            "total_skipped": total_skipped,
            "email_type_totals": email_type_totals,
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "birthday_rule_states": BIRTHDAY_RULE_STATES,
            "effective_date_rule_states": EFFECTIVE_DATE_RULE_STATES,
            "year_round_enrollment_states": YEAR_ROUND_ENROLLMENT_STATES
        }
    )

# Simulator data model
class SimulationRequest(BaseModel):
    state: str
    birth_date: str
    effective_date: Optional[str] = None
    start_date: str
    end_date: str

@app.get("/simulator", response_class=HTMLResponse)
async def simulator(request: Request):
    """Display email scheduling simulator"""
    # Default dates
    today = date.today()
    next_year = today + timedelta(days=365)
    
    return templates.TemplateResponse(
        "simulator.html",
        {
            "request": request,
            "title": "Email Scheduler Simulator",
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "birthday_rule_states": BIRTHDAY_RULE_STATES,
            "effective_date_rule_states": EFFECTIVE_DATE_RULE_STATES,
            "year_round_enrollment_states": YEAR_ROUND_ENROLLMENT_STATES,
            "today": today.isoformat(),
            "next_year": next_year.isoformat()
        }
    )

@app.post("/simulate")
async def simulate_emails(data: SimulationRequest):
    """Simulate email scheduling for a given contact"""
    try:
        # Parse dates - ensure we're working with date objects
        try:
            birth_date = datetime.strptime(data.birth_date, "%Y-%m-%d").date() if isinstance(data.birth_date, str) else data.birth_date
            start_date = datetime.strptime(data.start_date, "%Y-%m-%d").date() if isinstance(data.start_date, str) else data.start_date
            end_date = datetime.strptime(data.end_date, "%Y-%m-%d").date() if isinstance(data.end_date, str) else data.end_date
            
            effective_date = None
            if data.effective_date:
                effective_date = datetime.strptime(data.effective_date, "%Y-%m-%d").date() if isinstance(data.effective_date, str) else data.effective_date
        except (TypeError, ValueError) as e:
            logger.error(f"Date parsing error: {str(e)}")
            return JSONResponse(
                status_code=400,
                content={"error": "Invalid date format. Please use YYYY-MM-DD format."}
            )
            
        # Set up contact data with dates as strings for the scheduler
        contact = {
            "id": "12345",  # Dummy ID
            "birth_date": birth_date.isoformat() if birth_date else None,
            "effective_date": effective_date.isoformat() if effective_date else None,
            "state": data.state,
            "first_name": "Test",
            "last_name": "Contact",
            "email": "test@example.com"
        }
        
        logger.debug("Processing contact with birth_date=%s, effective_date=%s", 
                    contact["birth_date"], contact["effective_date"])
        
        # Use the scheduler to process the contact
        try:
            result = email_scheduler.process_contact(contact, start_date, end_date)
            if not result:
                return JSONResponse(
                    status_code=400,
                    content={"error": "No results returned from email scheduler"}
                )
            logger.debug("Scheduler result: %s", result)  # Add debug logging
        except Exception as e:
            logger.error(f"Scheduler error: {str(e)}")
            return JSONResponse(
                status_code=500,
                content={"error": f"Error processing contact: {str(e)}"}
            )
        
        # Format the result for the response
        email_list = []
        
        # Add scheduled emails
        for email in result.get("scheduled", []):
            try:
                email_date = email.get('scheduled_date') or email.get('date')
                if not email_date:
                    logger.warning(f"No date found in email data: {email}")
                    continue
                    
                email_info = {
                    'type': email.get('type', 'unknown'),
                    'type_display': {
                        'birthday': 'Birthday Email',
                        'effective_date': 'Anniversary Email',
                        'aep': 'AEP Email',
                        'post_window': 'Post-Window Email'
                    }.get(email.get('type', 'unknown'), email.get('type', 'unknown').replace('_', ' ').title()),
                    'start': email_date.isoformat() if isinstance(email_date, date) else email_date,
                    'skipped': False,
                    'reason': '',
                    'link': f"/contact/12345/email/{email.get('type', 'unknown')}/{email_date}",
                    'default_date': None
                }
                
                # Set default dates based on type
                if email.get('type') == 'birthday':
                    email_info['default_date'] = birth_date.isoformat()
                elif email.get('type') == 'effective_date':
                    email_info['default_date'] = effective_date.isoformat() if effective_date else None
                elif email.get('type') == 'aep':
                    email_info['default_date'] = 'AEP Window'
                elif email.get('type') == 'post_window':
                    email_info['default_date'] = 'Post Exclusion Period'
                    
                email_list.append(email_info)
            except Exception as e:
                logger.error(f"Error processing scheduled email: {e}\nEmail data: {email}")
                continue
            
        # Add skipped emails
        for email in result.get("skipped", []):
            try:
                email_date = email.get('scheduled_date') or email.get('date')
                if not email_date:
                    logger.warning(f"No date found in skipped email data: {email}")
                    continue
                    
                email_info = {
                    'type': email.get('type', 'unknown'),
                    'type_display': {
                        'birthday': 'Birthday Email',
                        'effective_date': 'Anniversary Email',
                        'aep': 'AEP Email',
                        'post_window': 'Post-Window Email'
                    }.get(email.get('type', 'unknown'), email.get('type', 'unknown').replace('_', ' ').title()),
                    'start': email_date.isoformat() if isinstance(email_date, date) else email_date,
                    'skipped': True,
                    'reason': email.get('reason', 'No reason provided'),
                    'link': '',
                    'default_date': None
                }
                
                # Set default dates based on type
                if email.get('type') == 'birthday':
                    email_info['default_date'] = birth_date.isoformat()
                elif email.get('type') == 'effective_date':
                    email_info['default_date'] = effective_date.isoformat() if effective_date else None
                elif email.get('type') == 'aep':
                    email_info['default_date'] = 'AEP Window'
                elif email.get('type') == 'post_window':
                    email_info['default_date'] = 'Post Exclusion Period'
                    
                email_list.append(email_info)
            except Exception as e:
                logger.error(f"Error processing skipped email: {e}\nEmail data: {email}")
                continue
        
        # Sort email list by date
        email_list.sort(key=lambda x: x['start'])
        
        # Get state rules
        rules = []
        if data.state in BIRTHDAY_RULE_STATES:
            window = BIRTHDAY_RULE_STATES[data.state]
            rules.append(f"Birthday emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after birthday")
        if data.state in EFFECTIVE_DATE_RULE_STATES:
            window = EFFECTIVE_DATE_RULE_STATES[data.state]
            rules.append(f"Effective date emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after anniversary")
        if data.state in YEAR_ROUND_ENROLLMENT_STATES:
            rules.append("Year-round enrollment state - no scheduled emails")
        else:
            rules.append("AEP emails: Distributed across August/September")
            rules.append("Post-window emails: Day after exclusion period")
        
        response = {
            "contact_info": {
                "id": "12345",
                "name": "Test Contact",
                "email": "test@example.com",
                "state": data.state,
                "birth_date": birth_date.isoformat(),
                "effective_date": effective_date.isoformat() if effective_date else None
            },
            "timeline_data": {
                "email_list": email_list
            },
            "scheduling_rules": rules,
            "state_info": {
                "code": data.state,
                "has_birthday_rule": data.state in BIRTHDAY_RULE_STATES,
                "has_effective_date_rule": data.state in EFFECTIVE_DATE_RULE_STATES,
                "has_year_round_enrollment": data.state in YEAR_ROUND_ENROLLMENT_STATES
            }
        }
        
        return response
        
    except Exception as e:
        # Log the error and return an error response
        import traceback
        error_trace = traceback.format_exc()
        logger.error("Error in simulate_emails: %s\n%s", str(e), error_trace)
        return JSONResponse(
            status_code=500,
            content={"error": f"An error occurred while calculating scheduled emails: {str(e)}"}
        )

@app.post("/resample/{org_id}")
async def resample_contacts(
    org_id: int, 
    sample_size: int = 10,
    state: Optional[str] = None,
    special_rules_only: bool = False,
    contact_search: Optional[str] = None
):
    """Resample contacts from existing data"""
    try:
        logger.debug("Starting resample_contacts with org_id=%s, sample_size=%s, state=%s", 
                    org_id, sample_size, state)
        
        # Set date range
        current_date = date.today()
        end_date = date(current_date.year + 2, current_date.month, current_date.day)
        
        if org_id not in org_data_store:
            logger.warning("Organization data not found for org_id=%s", org_id)
            return JSONResponse(
                status_code=404,
                content={"error": "Organization data not found. Please run the initial check first."}
            )
            
        df = org_data_store[org_id]
        logger.debug("Retrieved dataframe with %d rows", len(df))
        
        # Apply contact search if provided
        if contact_search and contact_search.strip():
            search_term = contact_search.strip()
            logger.debug("Applying contact search with term: %s", search_term)
            # Search by email (case insensitive) or by contact ID
            filtered_df = df[(df['email'].str.lower() == search_term.lower()) | 
                             (df['contact_id'].astype(str) == search_term)]
            
            if len(filtered_df) == 0:
                logger.warning("No contacts found matching search term: %s", search_term)
                return JSONResponse(
                    status_code=404,
                    content={"error": f"No contact found with email or ID: {search_term}"}
                )
        else:
            # Apply state filtering
            filtered_df = df.copy()
            if special_rules_only:
                logger.debug("Filtering for special rules states")
                filtered_df = filtered_df[filtered_df['state'].isin(SPECIAL_RULE_STATES)]
            elif state and state.strip():
                logger.debug("Filtering for state: %s", state)
                filtered_df = filtered_df[filtered_df['state'] == state]
                
            # Get unique contacts with their states
            unique_contacts = filtered_df.groupby('contact_id').first().reset_index()
            logger.debug("Found %d unique contacts after filtering", len(unique_contacts))
            
            if len(unique_contacts) == 0:
                logger.warning("No contacts found after state filtering")
                return JSONResponse(
                    status_code=404,
                    content={"error": "No contacts found matching the state filter criteria."}
                )
            
            # Sample contacts ensuring good state distribution
            sample_ids = sample_contacts_from_states(unique_contacts, sample_size, state if state and state.strip() else None)
            logger.debug("Sampled %d contact IDs", len(sample_ids))
            
            # Filter dataframe to only include sampled contacts
            filtered_df = filtered_df[filtered_df['contact_id'].isin(sample_ids)]
        
        # Convert DataFrame to list of dicts, handling NaN values
        sample_data = filtered_df.replace({pd.NA: None}).to_dict('records')
        logger.debug("Converted filtered data to %d records", len(sample_data))
        
        # Group data by contact with improved organization
        contacts_data = {}
        
        # First pass: Initialize contact data and calculate dates
        for row in sample_data:
            contact_id = row['contact_id']
            if contact_id not in contacts_data:
                state_code = row['state']
                state_info = {
                    "code": state_code,
                    "has_birthday_rule": state_code in BIRTHDAY_RULE_STATES,
                    "has_effective_date_rule": state_code in EFFECTIVE_DATE_RULE_STATES,
                    "has_year_round_enrollment": state_code in YEAR_ROUND_ENROLLMENT_STATES,
                    "rule_details": {
                        "birthday": BIRTHDAY_RULE_STATES.get(state_code, {}),
                        "effective_date": EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                    }
                }
                
                # Get birth_date and effective_date
                birth_date = row.get('birth_date')
                effective_date = row.get('effective_date')
                
                logger.debug("Processing contact %s with birth_date=%s, effective_date=%s", 
                           contact_id, birth_date, effective_date)
                
                # Calculate birthdays and effective dates in range
                birthdays = []
                effective_dates = []
                if birth_date:
                    try:
                        birthdays = get_all_occurrences(pd.to_datetime(birth_date).date(), current_date, end_date)
                        logger.debug("Calculated %d birthdays for contact %s", len(birthdays), contact_id)
                    except Exception as e:
                        logger.error("Error calculating birthdays for contact %s: %s", contact_id, e)
                if effective_date:
                    try:
                        effective_dates = get_all_occurrences(pd.to_datetime(effective_date).date(), current_date, end_date)
                        logger.debug("Calculated %d effective dates for contact %s", len(effective_dates), contact_id)
                    except Exception as e:
                        logger.error("Error calculating effective dates for contact %s: %s", contact_id, e)
                
                # Initialize contact data structure
                contacts_data[contact_id] = {
                    'contact_info': {
                        'id': contact_id,
                        'name': f"{row['first_name']} {row['last_name']}",
                        'email': row['email'],
                        'state': state_code,
                        'state_info': state_info,
                        'birth_date': birth_date,
                        'effective_date': effective_date
                    },
                    'timeline_data': {
                        'groups': [
                            {'id': 'key_dates', 'content': 'Key Dates'},
                            {'id': 'emails', 'content': 'Scheduled Emails'},
                            {'id': 'windows', 'content': 'Special Windows'}
                        ],
                        'items': []
                    }
                }
                
                # Add applicable scheduling rules based on state
                rules = []
                if state_info['has_birthday_rule']:
                    window = BIRTHDAY_RULE_STATES.get(state_code, {})
                    rules.append(f"Birthday emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after birthday")
                if state_info['has_effective_date_rule']:
                    window = EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                    rules.append(f"Effective date emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after anniversary")
                if state_info['has_year_round_enrollment']:
                    rules.append("Year-round enrollment state - no scheduled emails")
                else:
                    rules.append("AEP emails: Distributed across August/September")
                    rules.append("Post-window emails: Day after exclusion period")
                contacts_data[contact_id]['scheduling_rules'] = rules

        logger.debug("Processed %d contacts into contacts_data", len(contacts_data))
        
        # Log the structure of contacts_data for one contact
        if contacts_data:
            sample_contact_id = next(iter(contacts_data))
            logger.debug("Sample contact data structure: %s", 
                        json.dumps(contacts_data[sample_contact_id], default=str))

        # Use custom encoder for response
        response_data = {
            "contacts": contacts_data,
            "total_contacts": len(df.groupby('contact_id')),
            "sample_size": len(contacts_data),
            "contact_search": contact_search if contact_search else ""
        }
        
        return JSONResponse(
            content=response_data,
            encoder=CustomJSONEncoder
        )
        
    except Exception as e:
        logger.exception("Error in resample_contacts")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.post("/check", response_class=HTMLResponse)
async def check_schedules(
    request: Request,
    org_id: int = Form(...),
    sample_size: int = Form(10),
    state: Optional[str] = Form(default=None),
    special_rules_only: bool = Form(default=False),
    contact_search: Optional[str] = Form(default=None)
):
    """Process organization's contacts and display sample results"""
    try:
        # Set date range
        current_date = date.today()
        end_date = date(current_date.year + 2, current_date.month, current_date.day)

        await refresh_databases(org_id)
        
        # Get organization details and contacts
        org = get_organization_details(main_db, org_id)
        org_db_path = os.path.join(org_db_dir, f"org-{org_id}.db")
        contacts = get_contacts_from_org_db(org_db_path, org_id)
        formatted_contacts = format_contact_data(contacts)

        if not formatted_contacts:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": "No valid contacts found for scheduling"
                }
            )

        # Ensure dates are in ISO string format for the scheduler
        for contact in formatted_contacts:
            if contact.get('birth_date') and not isinstance(contact['birth_date'], str):
                contact['birth_date'] = contact['birth_date'].isoformat()
            if contact.get('effective_date') and not isinstance(contact['effective_date'], str):
                contact['effective_date'] = contact['effective_date'].isoformat()

        # Process contacts using the simplified async approach
        try:
            sample_ids = random.sample(range(len(formatted_contacts)), sample_size)
            sampled_contacts = [formatted_contacts[i] for i in sample_ids]
            if sample_size < 100:
                results = main_sync(sampled_contacts, current_date, end_date)
            elif sample_size < 1000:
                results = await main_async(sampled_contacts, current_date, end_date, batch_size=sample_size // 10)
            else:
                results = await main_async(sampled_contacts, current_date, end_date, batch_size=1000)
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to process contacts: {str(e)}\nTrace:\n{error_trace}"
                }
            )

        # Convert results to DataFrame for easier filtering and sampling
        df_data = []
        for result in results:
            contact_id = result['contact_id']
            contact = next((c for c in formatted_contacts if c['id'] == contact_id), None)
            if contact:
                # Add scheduled emails
                for email in result.get('scheduled', []):
                    df_data.append({
                        'contact_id': contact_id,
                        'first_name': contact.get('first_name', ''),
                        'last_name': contact.get('last_name', ''),
                        'email': contact.get('email', ''),
                        'state': contact.get('state', ''),
                        'birth_date': contact.get('birth_date'),
                        'effective_date': contact.get('effective_date'),
                        'email_type': email['type'],
                        'email_date': email['date'],
                        'skipped': 'No',
                        'reason': '',
                        'link': f"/contact/{contact_id}/email/{email['type']}/{email['date']}"
                    })
                
                # Add skipped emails
                for email in result.get('skipped', []):
                    df_data.append({
                        'contact_id': contact_id,
                        'first_name': contact.get('first_name', ''),
                        'last_name': contact.get('last_name', ''),
                        'email': contact.get('email', ''),
                        'state': contact.get('state', ''),
                        'birth_date': contact.get('birth_date'),
                        'effective_date': contact.get('effective_date'),
                        'email_type': email['type'],
                        'email_date': email.get('date', current_date),
                        'skipped': 'Yes',
                        'reason': email.get('reason', ''),
                        'link': ''
                    })

        # Create DataFrame and store in memory
        df = pd.DataFrame(df_data)
        org_data_store[org_id] = df

        # Apply filtering and sampling
        if contact_search and contact_search.strip():
            search_term = contact_search.strip()
            filtered_df = df[(df['email'].str.lower() == search_term.lower()) | 
                             (df['contact_id'].astype(str) == search_term)]
            
            if len(filtered_df) == 0:
                return templates.TemplateResponse(
                    "error.html",
                    {
                        "request": request,
                        "error": f"No contact found with email or ID: {search_term}"
                    }
                )
        else:
            filtered_df = df.copy()
            if special_rules_only:
                filtered_df = filtered_df[filtered_df['state'].isin(SPECIAL_RULE_STATES)]
            elif state and state.strip():
                filtered_df = filtered_df[filtered_df['state'] == state]

        # Sample contacts
        unique_contacts = filtered_df.groupby('contact_id').first().reset_index()
        if len(unique_contacts) == 0:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": "No contacts found matching the filter criteria."
                }
            )

        sample_ids = sample_contacts_from_states(unique_contacts, sample_size, state if state and state.strip() else None)
        filtered_df = filtered_df[filtered_df['contact_id'].isin(sample_ids)]

        # Prepare contact data for display
        contacts_data = {}
        for contact_id in sample_ids:
            contact_rows = filtered_df[filtered_df['contact_id'] == contact_id]
            if len(contact_rows) == 0:
                continue

            first_row = contact_rows.iloc[0]
            state_code = first_row['state']
            
            # Initialize contact data structure
            contacts_data[contact_id] = {
                'contact_info': {
                    'id': contact_id,
                    'name': f"{first_row['first_name']} {first_row['last_name']}",
                    'email': first_row['email'],
                    'state': state_code,
                    'birth_date': first_row['birth_date'],
                    'effective_date': first_row['effective_date']
                },
                'timeline_data': {
                    'email_list': []
                }
            }

            # Add applicable scheduling rules based on state
            rules = []
            if state_code in BIRTHDAY_RULE_STATES:
                window = BIRTHDAY_RULE_STATES[state_code]
                rules.append(f"Birthday emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after birthday")
            if state_code in EFFECTIVE_DATE_RULE_STATES:
                window = EFFECTIVE_DATE_RULE_STATES[state_code]
                rules.append(f"Effective date emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after anniversary")
            if state_code in YEAR_ROUND_ENROLLMENT_STATES:
                rules.append("Year-round enrollment state - no scheduled emails")
            else:
                rules.append("AEP emails: Distributed across August/September")
                rules.append("Post-window emails: Day after exclusion period")
            contacts_data[contact_id]['scheduling_rules'] = rules

            # Add emails to timeline data
            email_list = []
            for _, row in contact_rows.iterrows():
                email_type = row['email_type']
                # Map email types to human-readable names and determine default dates
                email_info = {
                    'type': email_type,
                    'type_display': {
                        'birthday': 'Birthday Email',
                        'effective_date': 'Anniversary Email',
                        'aep': 'AEP Email',
                        'post_window': 'Post-Window Email'
                    }.get(email_type, email_type.replace('_', ' ').title()),
                    'start': row['email_date'],
                    'skipped': row['skipped'] == 'Yes',
                    'reason': row['reason'] if row['skipped'] == 'Yes' else '',
                    'link': row['link'],
                    'default_date': None  # Will be populated based on type
                }
                
                # Set default dates based on type
                if email_type == 'birthday' and first_row['birth_date']:
                    email_info['default_date'] = first_row['birth_date']
                elif email_type == 'effective_date' and first_row['effective_date']:
                    email_info['default_date'] = first_row['effective_date']
                elif email_type == 'aep':
                    email_info['default_date'] = 'AEP Window'
                elif email_type == 'post_window':
                    email_info['default_date'] = 'Post Exclusion Period'
                
                email_list.append(email_info)
            
            # Sort email list by date
            email_list.sort(key=lambda x: x['start'])
            contacts_data[contact_id]['timeline_data']['email_list'] = email_list

        return templates.TemplateResponse(
            "results.html",
            {
                "request": request,
                "org_name": org['name'],
                "org_id": org_id,
                "contacts": contacts_data,
                "total_contacts": len(df.groupby('contact_id')),
                "sample_size": len(contacts_data),
                "sample_sizes": [5, 10, 25, 50, 100],
                "special_rule_states": SPECIAL_RULE_STATES,
                "current_date": current_date.isoformat(),
                "end_date": end_date.isoformat()
            }
        )
        
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        return templates.TemplateResponse(
            "error.html",
            {
                "request": request,
                "error": f"Unexpected error: {str(e)}\nTrace:\n{error_trace}"
            }
        )

if __name__ == "__main__":
    import uvicorn
    import argparse
    
    parser = argparse.ArgumentParser(description="Email Scheduler App")
    parser.add_argument("--port", type=int, default=8000, help="Port to run the server on")
    args = parser.parse_args()
    
    uvicorn.run(app, host="0.0.0.0", port=args.port)

================
File: contact_rule_engine.py
================
import yaml
from datetime import date, datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple
import logging

logger = logging.getLogger(__name__)

class ContactRuleEngine:
    def __init__(self, config_file: str = 'contact_rules_config.yaml'):
        """Initialize the rule engine with configuration"""
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)
        self.state_rules = self.config.get('state_rules', {})
        self.timing_constants = self.config.get('timing_constants', {})
        self.aep_config = self.config.get('aep_config', {})

    def get_state_rule(self, state: str) -> Dict[str, Any]:
        """Get rules for a specific state"""
        return self.state_rules.get(state, {})

    def is_year_round_enrollment_state(self, state: str) -> bool:
        """Check if a state has year-round enrollment"""
        state_rule = self.get_state_rule(state)
        return state_rule.get('type') == 'year_round'

    def get_aep_dates(self, year: int) -> List[date]:
        """Get AEP dates for a specific year"""
        if year not in self.aep_config.get('years', []):
            return []
        
        dates = []
        for date_config in self.aep_config.get('default_dates', []):
            dates.append(date(year, date_config['month'], date_config['day']))
        return sorted(dates)

    def handle_leap_year_date(self, target_date: date, target_year: int) -> date:
        """Handle leap year date adjustments"""
        if target_date.month == 2 and target_date.day == 29:
            # If not a leap year, use February 28
            if not self._is_leap_year(target_year):
                return date(target_year, 2, 28)
        return date(target_year, target_date.month, target_date.day)

    def _is_leap_year(self, year: int) -> bool:
        """Check if a year is a leap year"""
        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

    def calculate_exclusion_window(self, base_date: date, state_rule: Dict[str, Any]) -> Tuple[date, date]:
        """Calculate exclusion window based on state rule"""
        pre_window_days = self.timing_constants.get('pre_window_exclusion_days', 60)
        window_before = state_rule.get('window_before', 0)
        window_after = state_rule.get('window_after', 0)
        
        window_start = base_date - timedelta(days=pre_window_days + window_before)
        window_end = base_date + timedelta(days=window_after)
        
        return window_start, window_end

    def calculate_email_dates(self, contact: Dict[str, Any], current_date: date, end_date: date, 
                            total_contacts: int = 1, contact_index: int = 0) -> Dict[str, List[Dict[str, Any]]]:
        """
        Calculate all email dates for a contact, applying state rules and exclusions.
        Returns dict with 'scheduled' and 'skipped' email lists.
        """
        result = {
            'scheduled': [],
            'skipped': []
        }

        # Skip everything for year-round enrollment states
        state = contact.get('state', '')
        if self.is_year_round_enrollment_state(state):
            return result

        state_rule = self.get_state_rule(state)
        rule_type = state_rule.get('type')

        # Calculate base dates first
        emails_to_schedule = []
        
        # 1. Birthday emails
        if contact.get('birth_date'):
            birth_date = datetime.strptime(contact['birth_date'], '%Y-%m-%d').date()
            days_before = self.timing_constants.get('birthday_email_days_before', 14)
            
            # Calculate for current and next year
            for year in range(current_date.year, end_date.year + 1):
                yearly_birth_date = self.handle_leap_year_date(birth_date, year)
                email_date = yearly_birth_date - timedelta(days=days_before)
                
                if current_date <= email_date <= end_date:
                    emails_to_schedule.append({
                        'type': 'birthday',
                        'date': email_date,
                        'base_date': yearly_birth_date
                    })

        # 2. Effective date emails
        if contact.get('effective_date'):
            eff_date = datetime.strptime(contact['effective_date'], '%Y-%m-%d').date()
            days_before = self.timing_constants.get('effective_date_days_before', 30)
            
            for year in range(current_date.year, end_date.year + 1):
                yearly_eff_date = date(year, eff_date.month, eff_date.day)
                email_date = yearly_eff_date - timedelta(days=days_before)
                
                if current_date <= email_date <= end_date:
                    emails_to_schedule.append({
                        'type': 'effective_date',
                        'date': email_date,
                        'base_date': yearly_eff_date
                    })

        # 3. AEP emails
        for year in range(current_date.year, end_date.year + 1):
            aep_dates = self.get_aep_dates(year)
            if aep_dates:
                # Distribute contacts evenly across AEP dates if batching
                if total_contacts > 1:
                    aep_index = contact_index % len(aep_dates)
                else:
                    aep_index = 0
                
                aep_date = aep_dates[aep_index]
                if current_date <= aep_date <= end_date:
                    emails_to_schedule.append({
                        'type': 'aep',
                        'date': aep_date,
                        'base_date': aep_date
                    })

        # Apply state rules and exclusions
        if rule_type in ('birthday', 'effective_date'):
            # Calculate exclusion windows
            exclusion_windows = []
            base_date_type = 'birth_date' if rule_type == 'birthday' else 'effective_date'
            
            if contact.get(base_date_type):
                base_date = datetime.strptime(contact[base_date_type], '%Y-%m-%d').date()
                
                for year in range(current_date.year, end_date.year + 1):
                    yearly_base_date = self.handle_leap_year_date(base_date, year)
                    window_start, window_end = self.calculate_exclusion_window(yearly_base_date, state_rule)
                    
                    # Only include windows that overlap with our date range
                    if window_end >= current_date and window_start <= end_date:
                        exclusion_windows.append((window_start, window_end))
                        
                        # Add post-window email
                        post_window_date = window_end + timedelta(days=1)
                        if current_date <= post_window_date <= end_date:
                            result['scheduled'].append({
                                'type': 'post_window',
                                'date': post_window_date
                            })

            # Check each email against exclusion windows
            for email in emails_to_schedule:
                email_date = email['date']
                is_excluded = False
                
                for window_start, window_end in exclusion_windows:
                    if window_start <= email_date <= window_end:
                        is_excluded = True
                        result['skipped'].append({
                            'type': email['type'],
                            'date': email_date,
                            'reason': 'In exclusion window'
                        })
                        break
                
                if not is_excluded:
                    result['scheduled'].append({
                        'type': email['type'],
                        'date': email_date
                    })
        else:
            # For states without birthday/effective_date rules, schedule all emails
            for email in emails_to_schedule:
                result['scheduled'].append({
                    'type': email['type'],
                    'date': email['date']
                })

        # Sort scheduled emails by date
        result['scheduled'].sort(key=lambda x: x['date'])

        return result

    def get_state_window_period(self, state: str) -> Dict[str, int]:
        """Get window period configuration for a state"""
        state_rules = self.get_state_rule(state)
        return {
            'window_before': state_rules.get('window_before', 0),
            'window_after': state_rules.get('window_after', 0)
        }

    def get_special_state_rules(self, state: str) -> Dict[str, Any]:
        """Get special rules for a state"""
        state_rules = self.get_state_rule(state)
        return state_rules.get('special_rules', {})

    def get_special_rule_states(self) -> List[str]:
        """Get list of states with special rules"""
        return [state for state, rule in self.state_rules.items() 
                if rule.get('type') in ('birthday', 'effective_date')]

================
File: email_scheduler_common.py
================
"""
Common functions and logic for both synchronous and asynchronous email schedulers.
Simplified version that only includes essential constants and utility functions.
"""

from datetime import date, datetime, timedelta
import logging
import os
import json
from typing import Optional

# Configure logging
LOG_FILE = os.environ.get('LOG_FILE', 'logs/email_scheduler.log')
logger = logging.getLogger("email_scheduler")
logger.setLevel(logging.INFO)

# Create formatter
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

# Create file handler
try:
    # Ensure the directory exists
    log_dir = os.path.dirname(LOG_FILE)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir, exist_ok=True)
        
    file_handler = logging.FileHandler(LOG_FILE, mode='a')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
except Exception as e:
    print(f"Warning: Could not set up log file at {LOG_FILE}: {e}")
    print(f"Using fallback log file: email_scheduler.log")
    # Fallback to local log file
    fallback_handler = logging.FileHandler('email_scheduler.log', mode='a')
    fallback_handler.setFormatter(formatter)
    logger.addHandler(fallback_handler)

# All US states
ALL_STATES = [
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
    'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
    'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
    'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
    'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',
    'DC'
]

# Email type constants
EMAIL_TYPE_BIRTHDAY = "birthday"
EMAIL_TYPE_EFFECTIVE_DATE = "effective_date"
EMAIL_TYPE_AEP = "aep"
EMAIL_TYPE_POST_WINDOW = "post_window"

# Load ZIP code data
try:
    with open('zipData.json') as f:
        ZIP_DATA = json.load(f)
except Exception as e:
    logger.error(f"Failed to load zipData.json: {e}")
    ZIP_DATA = {}

def get_state_from_zip(zip_code: str) -> Optional[str]:
    """
    Get state from ZIP code using zipData.json
    
    Args:
        zip_code: ZIP code as string
        
    Returns:
        Two-letter state code, or None if not found
    """
    try:
        if not zip_code or not str(zip_code).strip():
            return None
        # Convert to string and take first 5 digits
        zip_str = str(zip_code)[:5]
        if zip_str in ZIP_DATA:
            return ZIP_DATA[zip_str]['state']
    except (KeyError, TypeError, ValueError) as e:
        logger.warning(f"Error getting state for ZIP {zip_code}: {e}")
    return None

# Helper function to check if a year is a leap year
def is_leap_year(year):
    """Returns True if the given year is a leap year, False otherwise"""
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    return year % 4 == 0

# Helper function to safely create a date
def try_create_date(year, month, day):
    """
    Attempts to create a date, handling leap year dates consistently
    For February 29 in non-leap years, uses February 28 instead
    """
    try:
        return date(year, month, day)
    except ValueError:
        # Handle February 29 in non-leap years
        if month == 2 and day == 29:
            return date(year, 2, 28)  # Use February 28 in non-leap years
        return None

# Helper function to check if a date is the last day of the month
def is_month_end(date_obj):
    """Check if a date is the last day of its month, handling leap years"""
    # Get the first day of the next month
    if date_obj.month == 12:
        next_month = date(date_obj.year + 1, 1, 1)
    else:
        next_month = date(date_obj.year, date_obj.month + 1, 1)
    
    # If the date is the day before the first of next month, it's the last day
    return (next_month - timedelta(days=1)) == date_obj

================
File: email_scheduler_optimized.py
================
"""
Email Scheduler Optimized - Performance-focused implementation.
Handles scheduling of emails based on contact rules and dates.
"""

import asyncio
import logging
from datetime import date, datetime, timedelta
from typing import Dict, List, Any, Optional
from contact_rule_engine import ContactRuleEngine

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EmailScheduler:
    """Processes contacts to schedule emails using rule engine"""
    
    def __init__(self):
        self.rule_engine = ContactRuleEngine()
        
    def process_contact(self, contact: Dict[str, Any], current_date: date, end_date: date) -> Dict[str, Any]:
        """
        Process a single contact to determine email schedule
        
        Args:
            contact: Contact data dictionary
            current_date: Start date for scheduling
            end_date: End date for scheduling
            
        Returns:
            Dictionary containing scheduled and skipped emails
        """
        try:
            # Use the rule engine's calculate_email_dates method which handles all email types
            result = self.rule_engine.calculate_email_dates(
                contact=contact,
                current_date=current_date,
                end_date=end_date
            )
            
            # Add contact ID to result
            result['contact_id'] = contact.get('id')
            return result
            
        except Exception as e:
            logger.error(f"Error processing contact {contact.get('id')}: {e}")
            return {
                "contact_id": contact.get('id'),
                "scheduled": [],
                "skipped": [{
                    "type": "all",
                    "reason": f"Processing error: {str(e)}"
                }]
            }

class AsyncEmailProcessor:
    """Allows for asynchronous processing of contacts in batches"""
    
    def __init__(self, scheduler: EmailScheduler, batch_size: int = 100):
        self.scheduler = scheduler
        self.batch_size = batch_size
        
    async def process_contacts(self, contacts: List[Dict[str, Any]], current_date: date, end_date: date) -> List[Dict[str, Any]]:
        """
        Process contacts asynchronously in batches
        
        Args:
            contacts: List of contacts to process
            current_date: Start date for scheduling
            end_date: End date for scheduling
            
        Returns:
            List of results for each contact
        """
        results = []
        total_contacts = len(contacts)
        
        # Process in batches
        for i in range(0, len(contacts), self.batch_size):
            batch = contacts[i:i + self.batch_size]
            
            # Create tasks for batch
            tasks = [
                asyncio.create_task(self._process_contact(contact, current_date, end_date, total_contacts, idx))
                for idx, contact in enumerate(batch)
            ]
            
            # Wait for batch to complete
            batch_results = await asyncio.gather(*tasks)
            results.extend(batch_results)
            
            logger.info(f"Processed batch of {len(batch)} contacts ({i + len(batch)}/{len(contacts)})")
            
        return results
        
    async def _process_contact(self, contact: Dict[str, Any], current_date: date, end_date: date, 
                             total_contacts: int, contact_index: int) -> Dict[str, Any]:
        """Process a single contact asynchronously"""
        try:
            # Use the rule engine's calculate_email_dates method with contact distribution info
            result = self.scheduler.rule_engine.calculate_email_dates(
                contact=contact,
                current_date=current_date,
                end_date=end_date,
                total_contacts=total_contacts,
                contact_index=contact_index
            )
            result['contact_id'] = contact.get('id')
            return result
        except Exception as e:
            logger.error(f"Error processing contact {contact.get('id')}: {e}")
            return {
                "contact_id": contact.get('id'),
                "scheduled": [],
                "skipped": [{
                    "type": "all",
                    "reason": f"Processing error: {str(e)}"
                }]
            }
        

async def main_async(contacts: List[Dict[str, Any]], current_date: Optional[date] = None, 
                    end_date: Optional[date] = None, batch_size: int = 100) -> List[Dict[str, Any]]:
    """
    Main async entry point for email scheduling
    
    Args:
        contacts: List of contacts to process
        current_date: Optional start date (defaults to today)
        end_date: Optional end date (defaults to 2 years from start)
        batch_size: Number of contacts to process in parallel
        
    Returns:
        List of results for each contact
    """
    # Set default dates if not provided
    if not current_date:
        current_date = date.today()
    if not end_date:
        end_date = current_date + timedelta(days=365 * 2)
        
    processor = AsyncEmailProcessor(EmailScheduler(), batch_size)
    return await processor.process_contacts(contacts, current_date, end_date)

def main_sync(contacts: List[Dict[str, Any]], current_date: Optional[date] = None,
              end_date: Optional[date] = None) -> List[Dict[str, Any]]:
    """
    Main synchronous entry point for email scheduling
    
    Args:
        contacts: List of contacts to process
        current_date: Optional start date (defaults to today)
        end_date: Optional end date (defaults to 2 years from start)
        
    Returns:
        List of results for each contact
    """
    # Set default dates if not provided
    if not current_date:
        current_date = date.today()
    if not end_date:
        end_date = current_date + timedelta(days=365 * 2)
        
    scheduler = EmailScheduler()
    results = []
    total_contacts = len(contacts)
    
    for i, contact in enumerate(contacts):
        try:
            result = scheduler.rule_engine.calculate_email_dates(
                contact=contact,
                current_date=current_date,
                end_date=end_date,
                total_contacts=total_contacts,
                contact_index=i
            )
            result['contact_id'] = contact.get('id')
            results.append(result)
            
            if (i + 1) % 100 == 0:
                logger.info(f"Processed {i + 1}/{len(contacts)} contacts")
                
        except Exception as e:
            logger.error(f"Error processing contact {contact.get('id')}: {e}")
            results.append({
                "contact_id": contact.get('id'),
                "scheduled": [],
                "skipped": [{
                    "type": "all",
                    "reason": f"Processing error: {str(e)}"
                }]
            })
            
    return results

================
File: email_template_engine.py
================
"""
Email template engine for generating email content based on email type.
Uses Jinja2 for template rendering and YAML for metadata.
"""

import os
from datetime import datetime, date
from typing import Dict, Any, Optional
import jinja2
import yaml
import logging

logger = logging.getLogger(__name__)

class EmailTemplateEngine:
    def __init__(self, template_dir: str = 'templates'):
        """Initialize the template engine with template directories"""
        self.template_dir = template_dir
        self.text_dir = os.path.join(template_dir, 'text')
        self.html_dir = os.path.join(template_dir, 'html')
        
        # Create template directories if they don't exist
        os.makedirs(self.text_dir, exist_ok=True)
        os.makedirs(self.html_dir, exist_ok=True)
        
        # Initialize Jinja2 environments
        self.text_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self.text_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        self.html_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self.html_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Register custom filters
        self._register_filters()
    
    def _register_filters(self):
        """Register custom Jinja2 filters"""
        def format_date(value):
            if isinstance(value, str):
                try:
                    value = datetime.strptime(value, "%Y-%m-%d").date()
                except ValueError:
                    return value
            return value.strftime("%B %d, %Y")
        
        def format_phone(value):
            if not value:
                return ""
            # Remove non-numeric characters
            nums = ''.join(filter(str.isdigit, str(value)))
            if len(nums) == 10:
                return f"({nums[:3]}) {nums[3:6]}-{nums[6:]}"
            return value
        
        def format_currency(value):
            try:
                return "${:,.2f}".format(float(value))
            except (ValueError, TypeError):
                return value
        
        # Register filters for both environments
        for env in [self.text_env, self.html_env]:
            env.filters['date'] = format_date
            env.filters['phone'] = format_phone
            env.filters['currency'] = format_currency
    
    def _load_template_metadata(self, template_type: str) -> Dict[str, Any]:
        """Load metadata for a template type from YAML"""
        metadata_file = os.path.join(self.template_dir, f"{template_type}_metadata.yaml")
        try:
            with open(metadata_file, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            logger.warning(f"No metadata file found for {template_type}")
            return {}
        except Exception as e:
            logger.error(f"Error loading metadata for {template_type}: {e}")
            return {}
    
    def _get_template_vars(self, template_type: str, contact: Dict[str, Any], email_date: date) -> Dict[str, Any]:
        """Prepare variables for template rendering"""
        # Load template metadata
        metadata = self._load_template_metadata(template_type)
        
        # Basic contact info
        vars = {
            'contact': contact,
            'email_date': email_date,
            'first_name': contact.get('first_name', ''),
            'last_name': contact.get('last_name', ''),
            'state': contact.get('state', ''),
            'company_name': "Medicare Services",
            'phone': "1-800-MEDICARE",
            'website': "www.medicare.gov"
        }
        
        # Add metadata variables
        vars.update(metadata.get('variables', {}))
        
        # Add type-specific variables
        if template_type == 'birthday':
            birth_date = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
            vars['birth_date'] = birth_date
            vars['birth_month'] = birth_date.strftime("%B")
            
        elif template_type == 'effective_date':
            effective_date = datetime.strptime(contact['effective_date'], "%Y-%m-%d").date()
            vars['effective_date'] = effective_date
            
        elif template_type == 'aep':
            vars['aep_start'] = date(email_date.year, 10, 15)
            vars['aep_end'] = date(email_date.year, 12, 7)
        
        return vars
    
    def render_email(self, template_type: str, contact: Dict[str, Any], email_date: date, html: bool = False) -> Dict[str, str]:
        """
        Render an email template
        
        Args:
            template_type: Type of email template (birthday, effective_date, aep, post_window)
            contact: Contact information dictionary
            email_date: Date the email will be sent
            html: Whether to render HTML version (default: False)
        
        Returns:
            Dictionary with subject and body/html keys
        """
        # Prepare template variables
        template_vars = self._get_template_vars(template_type, contact, email_date)
        
        # Get metadata for subject line
        metadata = self._load_template_metadata(template_type)
        subject = metadata.get('subject', f"{template_type.title()} Email for {contact.get('first_name', '')}")
        
        try:
            # Render subject line with template vars
            subject = self.text_env.from_string(subject).render(**template_vars)
            
            if html:
                # Render HTML template with template vars
                template = self.html_env.get_template(f"{template_type}/email.html")
                content = template.render(**template_vars)
                return content
            else:
                # Render text template with template vars
                text_template = self.text_env.get_template(f"{template_type}/email.txt")
                body = text_template.render(**template_vars)
                return {
                    'subject': subject,
                    'body': body
                }
        except Exception as e:
            logger.error(f"Error rendering {template_type} template: {e}")
            if html:
                return f"<p>Error rendering template: {e}</p>"
            else:
                return {
                    'subject': subject,
                    'body': f"Error rendering template: {e}"
                }
    
    def preview_email(self, template_type: str, contact: Dict[str, Any], email_date: date):
        """Preview both text and HTML versions of an email"""
        print(f"\nPreviewing {template_type} email for {contact.get('first_name')} {contact.get('last_name')}")
        print("-" * 80)
        
        # Render text version
        text_result = self.render_email(template_type, contact, email_date)
        print(f"Subject: {text_result['subject']}")
        print("\nText Content:")
        print(text_result['body'])
        
        # Render HTML version
        print("\nHTML Content:")
        html_result = self.render_email(template_type, contact, email_date, html=True)
        print(html_result)
    
    def validate_templates(self) -> bool:
        """Validate that all required templates exist and can be rendered"""
        template_types = ['birthday', 'effective_date', 'aep', 'post_window']
        success = True
        
        for template_type in template_types:
            # Check text template
            text_path = os.path.join(self.text_dir, template_type, 'email.txt')
            if not os.path.exists(text_path):
                logger.error(f"Missing text template: {text_path}")
                success = False
            
            # Check HTML template
            html_path = os.path.join(self.html_dir, template_type, 'email.html')
            if not os.path.exists(html_path):
                logger.error(f"Missing HTML template: {html_path}")
                success = False
            
            # Check metadata
            metadata_path = os.path.join(self.template_dir, f"{template_type}_metadata.yaml")
            if not os.path.exists(metadata_path):
                logger.error(f"Missing metadata file: {metadata_path}")
                success = False
        
        return success

================
File: org_utils.py
================
import json
import sqlite3
import os
import sys
from typing import List, Dict, Any, Optional
import logging
from dotenv import load_dotenv
from datetime import date, datetime

# Load environment variables from .env file
load_dotenv()

logger = logging.getLogger(__name__)

# Load ZIP data once at module level
try:
    with open('zipData.json', 'r') as f:
        ZIP_DATA = json.load(f)
except Exception as e:
    logger.error(f"Error loading zipData.json: {e}")
    ZIP_DATA = {}

def connect_to_db(db_path: str) -> sqlite3.Connection:
    """
    Connect to SQLite database and set row factory for dictionary results
    
    Args:
        db_path: Path to the SQLite database file
        
    Returns:
        SQLite connection object
    """
    if not os.path.exists(db_path):
        logger.error(f"Database not found: {db_path}")
        sys.exit(1)
    
    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        logger.error(f"Error connecting to database {db_path}: {e}")
        sys.exit(1)

def get_organization_details(main_db_path: str, org_id: int) -> Dict[str, Any]:
    """
    Get organization details from the main database
    
    Args:
        main_db_path: Path to the main database
        org_id: Organization ID
        
    Returns:
        Organization details as a dictionary
    """
    logger.info(f"Getting organization details for org_id: {org_id}")
    
    conn = connect_to_db(main_db_path)
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE id = ?", (org_id,))
        org = cursor.fetchone()
        
        if not org:
            logger.error(f"Organization with ID {org_id} not found in the database")
            sys.exit(1)
            
        return dict(org)
    except sqlite3.Error as e:
        logger.error(f"Error retrieving organization details: {e}")
        sys.exit(1)
    finally:
        conn.close()

def get_state_from_zip(zip_code: str) -> str:
    """Get the state from a ZIP code using zipData.json"""
    if not zip_code:
        return None
        
    try:
        # Ensure we're working with just the first 5 digits and pad
        zip_code = str(zip_code)[:5].zfill(5)
        return ZIP_DATA.get(zip_code, {}).get('state')
    except Exception as e:
        logger.error(f"Error looking up state for ZIP code {zip_code}: {e}")
        return None

def get_contacts_from_org_db(org_db_path: str, org_id: int) -> List[Dict[str, Any]]:
    """
    Get contacts from the organization's database
    
    Args:
        org_db_path: Path to the organization's database
        org_id: Organization ID
        
    Returns:
        List of contacts as dictionaries
    """
    logger.info(f"Getting contacts from organization database: {org_db_path}")
    
    conn = connect_to_db(org_db_path)
    try:
        cursor = conn.cursor()
        
        # Check if the contacts table exists and has the required columns
        cursor.execute("PRAGMA table_info(contacts)")
        columns = {column['name']: True for column in cursor.fetchall()}
        
        # Verify critical columns exist
        if 'email' not in columns:
            raise ValueError("Missing critical column 'email' in contacts table")
            
        # Build query with filtering for valid data
        query_parts = []
        
        # Handle ID column specially
        if 'id' in columns:
            query_parts.append('id')
        else:
            query_parts.append('rowid as id')
            
        # Add email (required)
        query_parts.append('email')
        
        # Add all required columns if they exist
        required_columns = ['first_name', 'last_name', 'birth_date', 'effective_date', 'zip_code', 'gender']
        for col in required_columns:
            if col in columns:
                query_parts.append(col)
        
        # Add state if it exists (optional - we'll derive from zip if missing)
        if 'state' in columns:
            query_parts.append('state')
        
        # Simplified WHERE clause - only check for critical data
        where_conditions = ['email IS NOT NULL AND email != ""']
        
        # Build the query
        query = f"""
            SELECT {', '.join(query_parts)} 
            FROM contacts 
            WHERE {' AND '.join(where_conditions)}
        """
        
        cursor.execute(query)
        
        contacts = []
        # Process rows in batches of 1000
        while True:
            rows = cursor.fetchmany(1000)
            if not rows:
                break
                
            for row in rows:
                contact = dict(row)
                contact['organization_id'] = org_id
                
                # Process state from zip code if needed
                if (contact.get('state') is None or contact['state'] == '') and contact.get('zip_code'):
                    contact['state'] = get_state_from_zip(contact['zip_code'])
                
                contacts.append(contact)
            
        logger.info(f"Retrieved {len(contacts)} contacts from organization database")
        return contacts
    except sqlite3.Error as e:
        logger.error(f"Error retrieving contacts: {e}")
        raise
    finally:
        conn.close()

def parse_date_flexible(date_str: str) -> Optional[date]:
    """Parse a date string flexibly, handling various formats and cleaning input"""
    if not date_str:
        return None
        
    MIN_YEAR = 1900
    MAX_YEAR = 2100
    
    # Month name mappings
    MONTH_MAP = {
        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,
        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12,
        'january': 1, 'february': 2, 'march': 3, 'april': 4, 'june': 6,
        'july': 7, 'august': 8, 'september': 9, 'october': 10, 'november': 11, 'december': 12
    }
        
    # Clean the input string
    orig_date_str = str(date_str).strip()
    
    def validate_year(year: int) -> bool:
        """Validate year is within acceptable range"""
        return MIN_YEAR <= year <= MAX_YEAR
    
    def validate_month(month: int) -> bool:
        """Validate month is between 1-12"""
        return 1 <= month <= 12
        
    def validate_day(year: int, month: int, day: int) -> bool:
        """Validate day is valid for given month/year"""
        try:
            date(year, month, day)
            return True
        except ValueError:
            return False
            
    def normalize_year(year: int) -> int:
        """Convert 2-digit year to 4-digit year (always assume 19XX)"""
        if year < 100:
            return 1900 + year
        return year

    # First try to handle month abbreviation formats (e.g., "Jul-59", "26-Jul-57")
    parts = orig_date_str.replace('/', '-').split('-')
    if len(parts) in [2, 3]:
        try:
            # Handle "MMM-YY" format (e.g., "Jul-59")
            if len(parts) == 2:
                month_str = parts[0].lower()
                if month_str in MONTH_MAP:
                    month = MONTH_MAP[month_str]
                    year = normalize_year(int(parts[1]))
                    if validate_year(year) and validate_month(month):
                        return date(year, month, 1)
            
            # Handle "DD-MMM-YY" format (e.g., "26-Jul-57")
            elif len(parts) == 3:
                day = int(parts[0])
                month_str = parts[1].lower()
                if month_str in MONTH_MAP:
                    month = MONTH_MAP[month_str]
                    year = normalize_year(int(parts[2]))
                    if validate_year(year) and validate_month(month) and validate_day(year, month, day):
                        return date(year, month, day)
        except (ValueError, IndexError):
            pass

    # Clean up date string for further processing
    date_str = orig_date_str.replace('`', '').replace('//', '/').replace('  ', ' ').replace(' ', '')

    # Handle year-only format (e.g., "1923")
    if date_str.isdigit() and len(date_str) == 4:
        year = int(date_str)
        if validate_year(year):
            return date(year, 1, 1)
    
    # Handle compressed dates without any separators
    if date_str.isdigit():
        # Try as MMDDYYYY or MMDDYY
        if len(date_str) in [8, 6]:
            try:
                month = int(date_str[:2])
                day = int(date_str[2:4])
                year = int(date_str[4:])
                year = normalize_year(year)
                if validate_year(year) and validate_month(month) and validate_day(year, month, day):
                    return date(year, month, day)
            except ValueError:
                pass
                
        # Try as DDMMYYYY or DDMMYY
        if len(date_str) in [8, 6]:
            try:
                day = int(date_str[:2])
                month = int(date_str[2:4])
                year = int(date_str[4:])
                year = normalize_year(year)
                if validate_year(year) and validate_month(month) and validate_day(year, month, day):
                    return date(year, month, day)
            except ValueError:
                pass

    # Clean up date string for parsing
    date_str = date_str.replace('/', '').replace('-', '').replace('.', '').replace(' ', '')
    
    # Try standard formats with cleaned string
    formats = [
        "%Y%m%d",     # YYYYMMDD
        "%d%m%Y",     # DDMMYYYY
        "%m%d%Y",     # MMDDYYYY
        "%Y%m",       # YYYYMM (will default to day 1)
    ]
    
    for fmt in formats:
        try:
            parsed_date = datetime.strptime(date_str, fmt).date()
            if validate_year(parsed_date.year):
                return parsed_date
        except ValueError:
            continue

    # If we still haven't found a match, try one last time with very flexible parsing
    try:
        # Extract all numbers from the string
        nums = ''.join(c for c in date_str if c.isdigit())
        if len(nums) >= 6:
            # Try to interpret as month/day/year
            if len(nums) >= 8:
                month = int(nums[:2])
                day = int(nums[2:4])
                year = int(nums[4:8])
            else:
                month = int(nums[:2])
                day = int(nums[2:4])
                year = int(nums[4:])
            year = normalize_year(year)
            if validate_year(year) and validate_month(month) and validate_day(year, month, day):
                return date(year, month, day)
    except (ValueError, IndexError):
        pass

    return None

def format_contact_data(contacts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Format contact data for compatibility with the email scheduler"""
    logger.info("Formatting contact data for scheduler")
    
    formatted_contacts = []
    for contact in contacts:
        # Always try to determine state from ZIP code first
        state = None
        if contact.get('zip_code'):
            state = get_state_from_zip(contact['zip_code'])
        
        # If we couldn't get state from ZIP, check if existing state is valid
        if not state:
            state = contact.get('state')
        
        # Default to CA if we still don't have a valid state
        if not state:
            logger.error(f"Could not determine valid state for contact {contact.get('id')}")
            raise ValueError(f"Missing valid state for contact {contact.get('id')}")
        
        # Ensure required fields exist
        formatted_contact = {
            'id': contact.get('id'),
            'contact_id': str(contact.get('id')),
            'first_name': contact.get('first_name', 'Unknown'),
            'last_name': contact.get('last_name', 'Unknown'),
            'email': contact.get('email', f"contact{contact.get('id')}@example.com"),
            'birth_date': contact.get('birth_date'),
            'effective_date': contact.get('effective_date'),
            'state': state,
            'organization_id': contact.get('organization_id')
        }
        
        # Skip contacts with missing critical data
        if not formatted_contact['birth_date'] and not formatted_contact['effective_date']:
            logger.warning(f"Skipping contact {formatted_contact['id']}: Missing both birth_date and effective_date")
            continue
            
        # Convert date fields if needed
        for date_field in ['birth_date', 'effective_date']:
            if formatted_contact[date_field]:
                if not isinstance(formatted_contact[date_field], date):
                    if isinstance(formatted_contact[date_field], str):
                        parsed_date = parse_date_flexible(formatted_contact[date_field])
                        if parsed_date:
                            formatted_contact[date_field] = parsed_date.isoformat()
                        else:
                            logger.warning(f"Could not parse {date_field} for contact {formatted_contact['id']}: {formatted_contact[date_field]}")
                            formatted_contact[date_field] = None
                    else:
                        formatted_contact[date_field] = formatted_contact[date_field].isoformat()
                
        formatted_contacts.append(formatted_contact)
        
    logger.info(f"Formatted {len(formatted_contacts)} contacts for scheduling")
    return formatted_contacts

================
File: send_scheduled_emails.py
================
"""
Main script for sending scheduled emails.
Reads scheduled emails from the output JSON and sends them via SendGrid.
"""

import os
import json
import argparse
from datetime import date, datetime, timedelta
import time
from typing import Dict, List, Any, Optional

from email_scheduler_common import logger
from sendgrid_client import SendGridClient
from email_template_engine import EmailTemplateEngine

# Initialize the template engine
template_engine = EmailTemplateEngine()

def get_email_content(email_type, contact, email_date):
    """Get email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date)

def get_email_html_content(email_type, contact, email_date):
    """Get HTML email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date, html=True)

def load_scheduled_emails(input_file: str) -> List[Dict[str, Any]]:
    """Load scheduled emails from JSON file"""
    try:
        with open(input_file, 'r') as f:
            data = json.load(f)
        return data
    except Exception as e:
        logger.error(f"Error loading scheduled emails from {input_file}: {e}")
        return []

def load_contact_details(contact_id: str, contacts_file: str) -> Optional[Dict[str, Any]]:
    """Load contact details from contacts file"""
    try:
        with open(contacts_file, 'r') as f:
            contacts = json.load(f)
        
        # Find the contact by ID
        for contact in contacts:
            if str(contact.get('id')) == str(contact_id):
                return contact
        
        logger.error(f"Contact {contact_id} not found in contacts file")
        return None
    except Exception as e:
        logger.error(f"Error loading contact details from {contacts_file}: {e}")
        return None

def send_scheduled_emails(
    scheduled_data: List[Dict[str, Any]], 
    contacts_file: str,
    dry_run: bool = True,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    limit: Optional[int] = None,
    delay: float = 0.0
):
    """Send scheduled emails using SendGrid"""
    # Initialize the SendGrid client
    client = SendGridClient(dry_run=dry_run)
    
    # Default to today if no start date provided
    if start_date is None:
        start_date = date.today()
    
    # Default to one year from start date if no end date provided
    if end_date is None:
        end_date = start_date + timedelta(days=365)
    
    # Track stats
    total_emails = 0
    successful_emails = 0
    failed_emails = 0
    
    # Process each contact's scheduled emails
    for contact_data in scheduled_data:
        contact_id = contact_data.get('contact_id')
        scheduled_emails = contact_data.get('emails', [])
        
        if not contact_id or not scheduled_emails:
            continue
        
        # Load contact details
        contact = load_contact_details(contact_id, contacts_file)
        if not contact:
            logger.warning(f"Skipping emails for contact {contact_id}: Contact details not found")
            continue
        
        # Ensure contact has an email address
        if not contact.get('email'):
            logger.warning(f"Skipping emails for contact {contact_id}: No email address")
            continue
        
        to_email = contact['email']
        
        # Process scheduled emails for this contact
        for email in scheduled_emails:
            email_type = email.get('type')
            email_date_str = email.get('date')
            
            if not email_type or not email_date_str:
                continue
            
            # Parse the email date
            try:
                email_date = datetime.strptime(email_date_str, "%Y-%m-%d").date()
            except:
                logger.error(f"Invalid date format for email: {email_date_str}")
                continue
            
            # Skip emails outside our date range
            if email_date < start_date or email_date > end_date:
                continue
            
            # Generate email content
            try:
                content = get_email_content(email_type, contact, email_date)
                html_content = get_email_html_content(email_type, contact, email_date)
                
                # Send the email
                total_emails += 1
                result = client.send_email(
                    to_email=to_email,
                    subject=content['subject'],
                    content=content['body'],
                    html_content=html_content,
                    dry_run=dry_run
                )
                
                if result:
                    successful_emails += 1
                    logger.info(f"Email {email_type} for contact {contact_id} scheduled on {email_date_str} sent successfully")
                else:
                    failed_emails += 1
                    logger.error(f"Failed to send {email_type} email for contact {contact_id} scheduled on {email_date_str}")
                
                # Add a delay if specified (helps with rate limits)
                if delay > 0 and total_emails < len(scheduled_data):
                    time.sleep(delay)
                
                # Check if we've hit the limit
                if limit and total_emails >= limit:
                    logger.info(f"Reached email limit of {limit}, stopping")
                    break
                
            except Exception as e:
                logger.error(f"Error sending {email_type} email for contact {contact_id}: {e}")
                failed_emails += 1
        
        # Check if we've hit the limit
        if limit and total_emails >= limit:
            break
    
    # Log summary
    logger.info(f"Email sending complete: {successful_emails} successful, {failed_emails} failed, {total_emails} total")
    
    return {
        "total": total_emails,
        "successful": successful_emails,
        "failed": failed_emails
    }

def main():
    """Main entry point for the script"""
    parser = argparse.ArgumentParser(description="Send scheduled emails using SendGrid")
    parser.add_argument("--input", required=True, help="Input JSON file with scheduled emails")
    parser.add_argument("--contacts", required=True, help="JSON file with contact details")
    parser.add_argument("--start-date", help="Start date for emails (YYYY-MM-DD)")
    parser.add_argument("--end-date", help="End date for emails (YYYY-MM-DD)")
    parser.add_argument("--limit", type=int, help="Maximum number of emails to send")
    parser.add_argument("--delay", type=float, default=0.0, help="Delay between emails in seconds")
    parser.add_argument("--live", action="store_true", help="Send actual emails (default is dry-run)")
    
    args = parser.parse_args()
    
    # Parse dates if provided
    start_date = None
    if args.start_date:
        start_date = datetime.strptime(args.start_date, "%Y-%m-%d").date()
    
    end_date = None
    if args.end_date:
        end_date = datetime.strptime(args.end_date, "%Y-%m-%d").date()
    
    # Determine dry_run mode (default to True - dry run)
    dry_run = not args.live
    
    # Load scheduled emails
    scheduled_data = load_scheduled_emails(args.input)
    
    # Send emails
    mode = "LIVE" if not dry_run else "DRY RUN"
    logger.info(f"Starting email sending in {mode} mode")
    
    result = send_scheduled_emails(
        scheduled_data=scheduled_data,
        contacts_file=args.contacts,
        dry_run=dry_run,
        start_date=start_date,
        end_date=end_date,
        limit=args.limit,
        delay=args.delay
    )
    
    logger.info(f"Email sending complete: {result['successful']} successful, {result['failed']} failed, {result['total']} total")

if __name__ == "__main__":
    main()

================
File: sendgrid_client.py
================
"""
SendGrid integration module for email scheduler.
Provides functionality to send emails via SendGrid API with support for dry-run mode.
"""

import os
import logging
from typing import Dict, Any, Optional, Union
import sendgrid
from sendgrid.helpers.mail import Mail, Email, To, Content, HtmlContent
from email_scheduler_common import logger

# Default configuration values
DEFAULT_FROM_EMAIL = "medicare@example.com"
DEFAULT_FROM_NAME = "Medicare Services" 
DEFAULT_DRY_RUN = "true"

class SendGridClient:
    """Client for interacting with SendGrid API to send emails."""
    
    def __init__(self, api_key: Optional[str] = None, dry_run: Optional[bool] = None):
        """
        Initialize the SendGrid client with API key and settings.
        
        Args:
            api_key: SendGrid API key (if None, reads from SENDGRID_API_KEY env var)
            dry_run: Whether to operate in dry-run mode (if None, reads from EMAIL_DRY_RUN env var)
        """
        # Use provided API key or read from environment
        self.api_key = api_key or os.environ.get("SENDGRID_API_KEY")
        
        # Set up dry run mode (default to True if not specified)
        if dry_run is None:
            dry_run_env = os.environ.get("EMAIL_DRY_RUN", DEFAULT_DRY_RUN).lower()
            self.dry_run = dry_run_env in ("true", "1", "yes", "y", "t")
        else:
            self.dry_run = dry_run
        
        # Default sender details
        self.from_email = os.environ.get("FROM_EMAIL", DEFAULT_FROM_EMAIL)
        self.from_name = os.environ.get("FROM_NAME", DEFAULT_FROM_NAME)
        
        # Initialize SendGrid client if API key is available and not in dry-run mode
        self.client = None
        if not self.dry_run and self.api_key:
            try:
                self.client = sendgrid.SendGridAPIClient(api_key=self.api_key)
            except Exception as e:
                logger.error(f"Failed to initialize SendGrid client: {e}")
    
    def send_email(
        self, 
        to_email: str, 
        subject: str, 
        content: str, 
        html_content: Optional[str] = None,
        dry_run: Optional[bool] = None
    ) -> bool:
        """
        Send an email via SendGrid or log it in dry-run mode.
        
        Args:
            to_email: Recipient email address
            subject: Email subject line
            content: Plain text email content
            html_content: Optional HTML content for the email
            dry_run: Override instance dry_run setting for this specific email
            
        Returns:
            Boolean indicating success
        """
        # Determine dry run mode for this specific email
        use_dry_run = self.dry_run if dry_run is None else dry_run
        
        # Validate email address format (basic check)
        if not to_email or '@' not in to_email:
            logger.error(f"Invalid email address: {to_email}")
            return False
        
        # In dry-run mode, just log the email
        if use_dry_run:
            logger.info(f"[DRY RUN] Would send email to: {to_email}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info(f"[DRY RUN] From: {self.from_name} <{self.from_email}>")
            logger.info(f"[DRY RUN] Content (first 100 chars): {content[:100]}...")
            return True
        
        # Ensure we have API key for live mode
        if not self.api_key:
            logger.error("Cannot send email: SendGrid API key not provided")
            return False
        
        # Ensure client is initialized
        if not self.client:
            logger.error("SendGrid client not initialized")
            return False
        
        try:
            # Create email message
            from_email = Email(self.from_email, self.from_name)
            to_email = To(to_email)
            
            # Use HTML content if provided, otherwise use plain text
            if html_content:
                content = HtmlContent(html_content)
            else:
                content = Content("text/plain", content)
            
            # Construct the message
            message = Mail(from_email, to_email, subject, content)
            
            # Send the email
            response = self.client.send(message)
            
            # Check response
            status_code = response.status_code
            
            if 200 <= status_code < 300:  # Success status codes
                logger.info(f"Email sent successfully to {to_email.email}, status: {status_code}")
                return True
            else:
                logger.error(f"Failed to send email to {to_email.email}, status: {status_code}")
                return False
            
        except Exception as e:
            logger.error(f"Error sending email to {to_email}: {str(e)}")
            return False

# Convenience function to send a single email
def send_email(
    to_email: str, 
    subject: str, 
    content: str, 
    html_content: Optional[str] = None,
    dry_run: Optional[bool] = None
) -> bool:
    """
    Convenience function to send a single email without managing client instance.
    
    Args:
        to_email: Recipient email address
        subject: Email subject line
        content: Plain text email content
        html_content: Optional HTML content for the email
        dry_run: Whether to operate in dry-run mode
        
    Returns:
        Boolean indicating success
    """
    client = SendGridClient(dry_run=dry_run)
    return client.send_email(to_email, subject, content, html_content, dry_run)

================
File: test_email_scheduler.py
================
#!/usr/bin/env python3
"""
Test script for email scheduler that loads real data from the database
and runs the scheduler on a random sample of contacts.
"""

import argparse
import json
import random
from datetime import date, datetime, timedelta
import os
import sys
from typing import List, Dict, Any, Optional
import logging

from email_scheduler_optimized import (
    EmailScheduler, 
    AsyncEmailProcessor,
    main_async,
    main_sync
)
from contact_rule_engine import ContactRuleEngine
from org_utils import (
    get_organization_details, 
    get_contacts_from_org_db, 
    format_contact_data
)

# Configure logging
logger = logging.getLogger(__name__)

def load_org_contacts(org_id: int, state: Optional[str] = None) -> List[Dict[str, Any]]:
    """Load contacts from organization database"""
    # Set up paths
    main_db = "main.db"
    org_db_dir = "org_dbs"
    org_db_path = os.path.join(org_db_dir, f"org-{org_id}.db")
    
    # Get organization details
    org = get_organization_details(main_db, org_id)
    logger.info(f"Loading contacts for organization: {org['name']} (ID: {org_id})")
    
    # Get contacts from organization database
    contacts = get_contacts_from_org_db(org_db_path, org_id)
    formatted_contacts = format_contact_data(contacts)
    
    if state:
        # Filter contacts by state
        formatted_contacts = [c for c in formatted_contacts if c.get('state') == state]
        logger.info(f"Filtered to {len(formatted_contacts)} contacts from {state}")
    
    return formatted_contacts

def sample_contacts(contacts: List[Dict[str, Any]], sample_size: int) -> List[Dict[str, Any]]:
    """Randomly sample N contacts from the list"""
    if sample_size >= len(contacts):
        return contacts
    return random.sample(contacts, sample_size)

def main():
    parser = argparse.ArgumentParser(description="Test Email Scheduler with Organization Data")
    parser.add_argument("org_id", type=int, help="Organization ID to load contacts from")
    parser.add_argument("--num-contacts", "-n", type=int, default=5, 
                       help="Number of contacts to sample (default: 5)")
    parser.add_argument("--state", "-s", help="Filter contacts by state code (e.g. CA)")
    parser.add_argument("--output", "-o", help="Output JSON file for results")
    parser.add_argument("--start-date", help="Start date (YYYY-MM-DD)")
    parser.add_argument("--end-date", help="End date (YYYY-MM-DD)")
    parser.add_argument("--display", "-d", type=int, default=5,
                       help="Number of results to display (default: 5)")
    parser.add_argument("--use-async", action="store_true", help="Use async processing")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")
    
    args = parser.parse_args()
    
    # Configure logging based on debug/verbose settings
    log_level = logging.DEBUG if args.debug else (logging.INFO if args.verbose else logging.WARNING)
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    try:
        # Set date range
        current_date = None
        if args.start_date:
            try:
                current_date = datetime.strptime(args.start_date, "%Y-%m-%d").date()
            except ValueError as e:
                logger.error(f"Invalid start date format: {e}")
                logger.error("Start date must be in YYYY-MM-DD format")
                sys.exit(1)
        else:
            current_date = date.today()
            
        end_date = None
        if args.end_date:
            try:
                end_date = datetime.strptime(args.end_date, "%Y-%m-%d").date()
            except ValueError as e:
                logger.error(f"Invalid end date format: {e}")
                logger.error("End date must be in YYYY-MM-DD format")
                sys.exit(1)
        else:
            end_date = current_date + timedelta(days=365)
        
        # Load and sample contacts
        all_contacts = load_org_contacts(args.org_id, args.state)
        if not all_contacts:
            logger.error("No contacts found!")
            sys.exit(1)
            
        logger.info(f"Sampling {args.num_contacts} contacts from {len(all_contacts)} total contacts")
        sampled_contacts = sample_contacts(all_contacts, args.num_contacts)
        
        # Process contacts
        if args.use_async:
            import asyncio
            logger.info("Processing contacts asynchronously...")
            results = asyncio.run(main_async(sampled_contacts, current_date, end_date))
        else:
            logger.info("Processing contacts synchronously...")
            results = main_sync(sampled_contacts, current_date, end_date)
        
        # Display results
        if args.display > 0:
            display_results(results, args.display)
        
        # Write results to file if specified
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            logger.info(f"Full results written to {args.output}")
        
        # Print summary
        total_emails = sum(len(r['emails']) for r in results)
        total_skipped = sum(len(r['skipped']) for r in results)
        print(f"\nSummary:")
        print(f"- Total contacts processed: {len(sampled_contacts)}")
        print(f"- Total emails scheduled: {total_emails}")
        print(f"- Total emails skipped: {total_skipped}")
        print(f"- Average emails per contact: {total_emails/len(sampled_contacts):.1f}")
        
    except Exception as e:
        logger.error(f"Error: {e}")
        if args.debug:
            import traceback
            logger.error(f"Error details:\n{traceback.format_exc()}")
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: z.py
================
from test_email_scheduler import *
from pprint import pprint
import asyncio

ar = asyncio.run

e = EmailScheduler()

current_date = date(2025, 3, 31)
end_date = date(2027, 12, 31)


oc = load_org_contacts(37)

d = format_contact_data(oc)

r = lambda x: e.process_contact(d[x], current_date, end_date)

# t_list = is random list of 10 contact_ids
t_list = random.sample(range(len(d)), 10)
d_list = [r(i) for i in t_list]
pprint(d_list)

dd = ar(main_async(d, current_date, end_date,1000))



================================================================
End of Codebase
================================================================
