This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.py, **/*.html
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
templates/
  html/
    aep/
      email.html
    birthday/
      email.html
  base.html
  dashboard.html
  email_table.html
  error.html
  home.html
  index.html
  organization.html
  results.html
  simulator.html
  state_info.html
  timeline.html
app.py
contact_rule_engine.py
email_scheduler_common.py
email_scheduler_optimized.py
email_template_engine.py
schedule_org_emails.py
send_scheduled_emails.py
sendgrid_client.py
timeline_data_helper.py

================================================================
Files
================================================================

================
File: templates/html/aep/email.html
================
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{ subject }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            color: #0066cc;
            margin-bottom: 20px;
        }
        .content {
            margin-bottom: 30px;
        }
        .benefits {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .benefits ul {
            margin: 0;
            padding-left: 20px;
        }
        .cta {
            background-color: #0066cc;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin: 20px 0;
        }
        .signature {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .footer {
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 30px;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ subject }}</h1>
    </div>

    <div class="content">
        <p>{{ greeting }}</p>

        <p>The Annual Enrollment Period (AEP) is approaching, and we want to help you make the most of this important time. From {{ aep_start | date }} to {{ aep_end | date }}, you'll have the opportunity to review and adjust your Medicare coverage.</p>

        <div class="benefits">
            <p>Here's what we'll cover in your AEP review:</p>
            <ul>
            {% for benefit in aep_benefits %}
                <li>{{ benefit }}</li>
            {% endfor %}
            </ul>
        </div>

        <div class="cta">
            <h2>{{ call_to_action }}</h2>
            <p>Call us at {{ signature_phone | phone }} to schedule your review.</p>
        </div>

        <div class="signature">
            <p>Best regards,<br>
            {{ signature_name }}</p>
        </div>
    </div>

    <div class="footer">
        <p>{{ company_name }}<br>
        Phone: {{ phone | phone }}<br>
        Website: {{ website }}<br>
        {% if contact.id %}Contact ID: {{ contact.id }}{% endif %}</p>
    </div>
</body>
</html>

================
File: templates/html/birthday/email.html
================
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{ subject }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            color: #0066cc;
            margin-bottom: 20px;
        }
        .content {
            margin-bottom: 30px;
        }
        .benefits {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .benefits ul {
            margin: 0;
            padding-left: 20px;
        }
        .cta {
            background-color: #0066cc;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin: 20px 0;
        }
        .cta a {
            color: white;
            text-decoration: none;
        }
        .signature {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .footer {
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 30px;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ subject }}</h1>
    </div>

    <div class="content">
        <p>Dear {{ first_name }},</p>

        <p>Happy birthday month! As your Medicare insurance specialists, we want to ensure you're getting the most from your coverage during this special time.</p>

        <div class="benefits">
            <p>Your birthday month is a perfect opportunity for a comprehensive review of your Medicare coverage. Here's what we'll cover:</p>
            <ul>
            {% for benefit in review_benefits %}
                <li>{{ benefit }}</li>
            {% endfor %}
            </ul>
        </div>

        <div class="cta">
            <h2>{{ call_to_action }}</h2>
            <p>Call us at {{ signature_phone | phone }} to schedule your review.</p>
        </div>

        <div class="signature">
            <p>Best regards,<br>
            {{ signature_name }}</p>
        </div>
    </div>

    <div class="footer">
        <p>{{ company_name }}<br>
        Phone: {{ phone | phone }}<br>
        Website: {{ website }}<br>
        {% if contact.id %}Contact ID: {{ contact.id }}{% endif %}</p>
    </div>
</body>
</html>

================
File: templates/base.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Schedule Checker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Card styles */
        .contact-card {
            margin-bottom: 2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .contact-card .card-header {
            font-weight: bold;
        }
        
        /* Email styling */
        .email-row {
            margin-bottom: 0.5rem;
        }
        .skipped {
            color: #dc3545;
        }
        
        /* Dashboard styles */
        .card {
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }
        .card-header h5 {
            margin-bottom: 0;
        }
        .progress {
            height: 30px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,.2);
        }
        .progress-bar {
            font-weight: bold;
            font-size: 0.9rem;
            line-height: 30px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        
        /* Table styles */
        .table-responsive {
            overflow-x: auto;
        }
        .table th {
            background-color: #f8f9fa;
            position: sticky;
            top: 0;
        }
        
        /* Badge styling */
        .badge {
            font-size: 85%;
            padding: 0.35em 0.65em;
        }
        
        /* Nav tabs */
        .nav-tabs .nav-link {
            font-weight: 500;
        }
        
        /* Add responsive elements */
        @media (max-width: 768px) {
            .display-4 {
                font-size: 2.5rem;
            }
        }
    </style>
    {% block head %}{% endblock %}
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">Email Schedule Checker</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/dashboard">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/simulator">Simulator</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container my-4">
        {% block content %}{% endblock %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/dashboard.js"></script>
    {% block scripts %}{% endblock %}
</body>
</html>

================
File: templates/dashboard.html
================
{% extends "base.html" %}

{% block content %}
<h1 class="mb-4">Email Scheduling Dashboard</h1>

<!-- Summary cards -->
<div class="row mb-4">
    <div class="col-md-3">
        <div class="card bg-primary text-white">
            <div class="card-body">
                <h5 class="card-title">Total Emails Scheduled</h5>
                <h2 class="display-4">{{ total_emails }}</h2>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-success text-white">
            <div class="card-body">
                <h5 class="card-title">Birthday Emails</h5>
                <h2 class="display-4">{{ email_type_totals.birthday }}</h2>
                <p class="card-text">
                    {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}% of total
                </p>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-info text-white">
            <div class="card-body">
                <h5 class="card-title">Effective Date Emails</h5>
                <h2 class="display-4">{{ email_type_totals.effective_date }}</h2>
                <p class="card-text">
                    {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}% of total
                </p>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card bg-warning text-dark">
            <div class="card-body">
                <h5 class="card-title">Skipped Emails</h5>
                <h2 class="display-4">{{ total_skipped }}</h2>
            </div>
        </div>
    </div>
</div>

<!-- Email type distribution -->
<div class="row mb-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h5 class="card-title mb-0">Email Types Distribution</h5>
            </div>
            <div class="card-body">
                <div class="progress" style="height: 30px;">
                    <div class="progress-bar bg-primary" role="progressbar" 
                        style="width: {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.birthday }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Birthday: {{ (email_type_totals.birthday / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-success" role="progressbar" 
                        style="width: {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.effective_date }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Effective: {{ (email_type_totals.effective_date / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-info" role="progressbar" 
                        style="width: {{ (email_type_totals.aep / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.aep }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        AEP: {{ (email_type_totals.aep / total_emails * 100) | round(1) }}%
                    </div>
                    <div class="progress-bar bg-warning" role="progressbar" 
                        style="width: {{ (email_type_totals.post_window / total_emails * 100) | round(1) }}%;" 
                        aria-valuenow="{{ email_type_totals.post_window }}" aria-valuemin="0" aria-valuemax="{{ total_emails }}">
                        Post: {{ (email_type_totals.post_window / total_emails * 100) | round(1) }}%
                    </div>
                </div>
                <div class="row mt-3 text-center">
                    <div class="col">
                        <span class="badge bg-primary">Birthday: {{ email_type_totals.birthday }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-success">Effective Date: {{ email_type_totals.effective_date }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-info">AEP: {{ email_type_totals.aep }}</span>
                    </div>
                    <div class="col">
                        <span class="badge bg-warning text-dark">Post-Window: {{ email_type_totals.post_window }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- States table -->
<div class="row">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header">
                <ul class="nav nav-tabs card-header-tabs" id="statesTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="all-states-tab" data-bs-toggle="tab" data-bs-target="#all-states" type="button" role="tab" aria-controls="all-states" aria-selected="true">All States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="special-states-tab" data-bs-toggle="tab" data-bs-target="#special-states" type="button" role="tab" aria-controls="special-states" aria-selected="false">Special Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="birthday-states-tab" data-bs-toggle="tab" data-bs-target="#birthday-states" type="button" role="tab" aria-controls="birthday-states" aria-selected="false">Birthday Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="effective-date-states-tab" data-bs-toggle="tab" data-bs-target="#effective-date-states" type="button" role="tab" aria-controls="effective-date-states" aria-selected="false">Effective Date Rule States</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="year-round-states-tab" data-bs-toggle="tab" data-bs-target="#year-round-states" type="button" role="tab" aria-controls="year-round-states" aria-selected="false">Year-Round Enrollment States</button>
                    </li>
                </ul>
            </div>
            <div class="card-body">
                <div class="tab-content" id="statesTabsContent">
                    <!-- All States Tab -->
                    <div class="tab-pane fade show active" id="all-states" role="tabpanel" aria-labelledby="all-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                        <th>Special Rules</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in all_states %}
                                    {% if email_counts[state].total > 0 %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                        <td>
                                            {% if state in special_rule_states %}
                                            <span class="badge bg-info">Yes</span>
                                            {% else %}
                                            <span class="badge bg-secondary">No</span>
                                            {% endif %}
                                        </td>
                                    </tr>
                                    {% endif %}
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Special Rule States Tab -->
                    <div class="tab-pane fade" id="special-states" role="tabpanel" aria-labelledby="special-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                        <th>Rules</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in special_rule_states %}
                                    {% if email_counts[state].total > 0 %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                        <td>
                                            {% if state in birthday_rule_states %}
                                            <span class="badge bg-primary">Birthday</span>
                                            {% endif %}
                                            {% if state in effective_date_rule_states %}
                                            <span class="badge bg-success">Effective Date</span>
                                            {% endif %}
                                            {% if state in year_round_enrollment_states %}
                                            <span class="badge bg-warning text-dark">Year-Round</span>
                                            {% endif %}
                                        </td>
                                    </tr>
                                    {% endif %}
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Birthday Rule States Tab -->
                    <div class="tab-pane fade" id="birthday-states" role="tabpanel" aria-labelledby="birthday-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Window Before</th>
                                        <th>Window After</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in birthday_rule_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ birthday_rule_states[state].window_before }} days</td>
                                        <td>{{ birthday_rule_states[state].window_after }} days</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Effective Date Rule States Tab -->
                    <div class="tab-pane fade" id="effective-date-states" role="tabpanel" aria-labelledby="effective-date-states-tab">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Window Before</th>
                                        <th>Window After</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in effective_date_rule_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>{{ email_counts[state].aep }}</td>
                                        <td>{{ email_counts[state].post_window }}</td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ effective_date_rule_states[state].window_before }} days</td>
                                        <td>{{ effective_date_rule_states[state].window_after }} days</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Year-Round Enrollment States Tab -->
                    <div class="tab-pane fade" id="year-round-states" role="tabpanel" aria-labelledby="year-round-states-tab">
                        <div class="alert alert-warning mb-3">
                            <strong>Note:</strong> Year-round enrollment states should have no AEP or post-window emails scheduled.
                        </div>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>State</th>
                                        <th>Birthday</th>
                                        <th>Effective Date</th>
                                        <th>AEP</th>
                                        <th>Post-Window</th>
                                        <th>Total</th>
                                        <th>Skipped</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for state in year_round_enrollment_states %}
                                    <tr>
                                        <td>{{ state }}</td>
                                        <td>{{ email_counts[state].birthday }}</td>
                                        <td>{{ email_counts[state].effective_date }}</td>
                                        <td>
                                            {% if email_counts[state].aep > 0 %}
                                            <span class="text-danger">{{ email_counts[state].aep }}</span>
                                            {% else %}
                                            0
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if email_counts[state].post_window > 0 %}
                                            <span class="text-danger">{{ email_counts[state].post_window }}</span>
                                            {% else %}
                                            0
                                            {% endif %}
                                        </td>
                                        <td><strong>{{ email_counts[state].total }}</strong></td>
                                        <td>{{ email_counts[state].skipped }}</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: templates/email_table.html
================
<div class="table-responsive">
    <table class="table table-sm">
        <thead>
            <tr>
                <th>Type</th>
                <th>Date</th>
                <th>Status</th>
                <th>Default Date</th>
                <th>Reason</th>
                <th>Link</th>
            </tr>
        </thead>
        <tbody>
            {% for email in contact_data.emails %}
            <tr {% if email.skipped == 'Yes' %}class="table-danger"{% endif %}>
                <td>
                    {% if email.type == 'birthday' %}
                    <span class="badge bg-primary">Birthday</span>
                    {% elif email.type == 'effective_date' %}
                    <span class="badge bg-success">Effective Date</span>
                    {% elif email.type == 'aep' %}
                    <span class="badge bg-info">AEP</span>
                    {% elif email.type == 'post_window' %}
                    <span class="badge bg-warning">Post Window</span>
                    {% else %}
                    {{ email.type }}
                    {% endif %}
                </td>
                <td>{{ email.date }}</td>
                <td>
                    {% if email.skipped == 'Yes' %}
                    <span class="badge bg-danger">Skipped</span>
                    {% else %}
                    <span class="badge bg-success">Scheduled</span>
                    {% endif %}
                </td>
                <td>
                    {% if email.type == 'birthday' and contact_data.contact_info.birth_date and '-' in contact_data.contact_info.birth_date %}
                        {% set date_str = email.date|string %}
                        {% if '-' in date_str %}
                            {% set birthday_parts = contact_data.contact_info.birth_date.split('-') %}
                            {% set current_year = date_str.split('-')[0] %}
                            {% if birthday_parts|length >= 3 %}
                                {% set default_date = current_year + '-' + birthday_parts[1] + '-' + birthday_parts[2] %}
                                {% if email.date < default_date %}
                                    {{ (current_year|int - 1)|string + '-' + birthday_parts[1] + '-' + birthday_parts[2] }}
                                {% else %}
                                    {{ default_date }}
                                {% endif %}
                            {% else %}
                                N/A (birth date format error)
                            {% endif %}
                        {% else %}
                            N/A (email date format error)
                        {% endif %}
                    {% elif email.type == 'effective_date' and contact_data.contact_info.effective_date and '-' in contact_data.contact_info.effective_date %}
                        {% set date_str = email.date|string %}
                        {% if '-' in date_str %}
                            {% set effective_parts = contact_data.contact_info.effective_date.split('-') %}
                            {% set current_year = date_str.split('-')[0] %}
                            {% if effective_parts|length >= 3 %}
                                {% set default_date = current_year + '-' + effective_parts[1] + '-' + effective_parts[2] %}
                                {% if email.date < default_date %}
                                    {{ (current_year|int - 1)|string + '-' + effective_parts[1] + '-' + effective_parts[2] }}
                                {% else %}
                                    {{ default_date }}
                                {% endif %}
                            {% else %}
                                N/A (effective date format error)
                            {% endif %}
                        {% else %}
                            N/A (email date format error)
                        {% endif %}
                    {% else %}
                    N/A
                    {% endif %}
                </td>
                <td>
                    {% if email.reason %}
                    <span class="text-danger">{{ email.reason }}</span>
                    {% elif email.skipped == 'Yes' %}
                    <span class="text-danger">Unknown</span>
                    {% else %}
                    <span class="text-success">Normal schedule</span>
                    {% endif %}
                </td>
                <td>
                    {% if email.link and email.skipped != 'Yes' %}
                    <a href="{{ email.link }}" target="_blank" class="btn btn-sm btn-primary">View</a>
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            
            {% if not contact_data.emails|selectattr('type', 'equalto', 'birthday')|list and contact_data.contact_info.birth_date %}
            <tr class="table-info">
                <td><span class="badge bg-primary">Birthday</span></td>
                <td>-</td>
                <td><span class="badge bg-danger">Skipped</span></td>
                <td>N/A</td>
                <td><span class="text-danger">Check birthday calculation</span></td>
                <td></td>
            </tr>
            {% endif %}
            
            {% if not contact_data.emails|selectattr('type', 'equalto', 'effective_date')|list and contact_data.contact_info.effective_date %}
            <tr class="table-info">
                <td><span class="badge bg-success">Effective Date</span></td>
                <td>-</td>
                <td><span class="badge bg-danger">Skipped</span></td>
                <td>N/A</td>
                <td><span class="text-danger">Check effective date calculation</span></td>
                <td></td>
            </tr>
            {% endif %}
        </tbody>
    </table>
</div>

================
File: templates/error.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error - Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --error-color: #ea4335;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
        }
        
        .error-icon {
            width: 40px;
            height: 40px;
            margin-right: 16px;
            color: var(--error-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--error-color);
        }
        
        .error-message {
            background-color: #fdede9;
            border-left: 4px solid var(--error-color);
            padding: 16px;
            margin-bottom: 24px;
            border-radius: 4px;
        }
        
        .error-details {
            background-color: #f1f3f4;
            padding: 16px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            margin-bottom: 24px;
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .home-link {
            display: inline-flex;
            align-items: center;
        }
        
        .home-link svg {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <svg class="error-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h1>Error Occurred</h1>
        </header>
        
        <div class="error-message">
            {{ error }}
        </div>
        
        {% if error_details %}
        <div class="error-details">
            {{ error_details }}
        </div>
        {% endif %}
        
        <a href="/" class="btn home-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
            Back to Home
        </a>
    </div>
</body>
</html>

================
File: templates/home.html
================
{% extends "base.html" %}

{% block content %}
<h1 class="mb-4">Email Schedule Checker</h1>

<div class="card mb-4">
    <div class="card-header bg-primary text-white">
        <h5 class="card-title mb-0">Calculate Email Schedule</h5>
    </div>
    <div class="card-body">
        <form action="/check" method="post" id="scheduleForm">
            <div class="mb-3">
                <label for="org_id" class="form-label">Organization ID</label>
                <input type="number" class="form-control" id="org_id" name="org_id" value="37" required>
                <div class="form-text">Enter the organization ID to check email schedules</div>
            </div>
            
            <div class="row mb-3">
                <div class="col-md-4">
                    <label for="sample_size" class="form-label">Sample Size</label>
                    <select class="form-select" id="sample_size" name="sample_size">
                        {% for size in sample_sizes %}
                        <option value="{{ size }}" {% if size == 10 %}selected{% endif %}>{{ size }} contacts</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            
            <div class="mb-3">
                <label for="contact_search" class="form-label">Search by Email or Contact ID (Optional)</label>
                <input type="text" class="form-control" id="contact_search" name="contact_search" placeholder="Enter email or contact ID">
                <small class="form-text text-muted">If provided, other filters will be ignored</small>
            </div>
            
            <div class="mb-3">
                <label class="form-label">State Filter</label>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_none" value="none" checked>
                    <label class="form-check-label" for="filter_none">
                        Show all states
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_state" value="state">
                    <label class="form-check-label" for="filter_state">
                        Filter by specific state
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="filter_type" id="filter_special" value="special">
                    <label class="form-check-label" for="filter_special">
                        Show only states with special rules
                    </label>
                </div>
                <select class="form-select mt-2" id="state" name="state" disabled>
                    <option value="">Select a state...</option>
                    {% for state in all_states %}
                    <option value="{{ state }}">
                        {{ state }}
                        {% if state in special_rule_states %}
                            (Special Rules:
                            {% if state_rules[state].has_birthday_rule %}Birthday{% endif %}
                            {% if state_rules[state].has_effective_date_rule %}Effective Date{% endif %}
                            {% if state_rules[state].has_year_round_enrollment %}Year-Round{% endif %}
                            )
                        {% endif %}
                    </option>
                    {% endfor %}
                </select>
                <input type="hidden" name="special_rules_only" id="special_rules_only" value="false">
            </div>
            
            <button type="submit" class="btn btn-primary" id="submitBtn">
                <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                Check Schedules
            </button>
        </form>
    </div>
</div>

<div class="card mb-4">
    <div class="card-header bg-info text-white">
        <h5 class="card-title mb-0">Special State Rules</h5>
    </div>
    <div class="card-body">
        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead>
                    <tr>
                        <th>State</th>
                        <th>Birthday Rule</th>
                        <th>Effective Date Rule</th>
                        <th>Year-Round Enrollment</th>
                    </tr>
                </thead>
                <tbody>
                    {% for state in all_states %}
                    {% if state_rules[state].has_birthday_rule or state_rules[state].has_effective_date_rule or state_rules[state].has_year_round_enrollment %}
                    <tr class="table-info">
                    {% else %}
                    <tr>
                    {% endif %}
                        <td>{{ state }}</td>
                        <td>
                            {% if state_rules[state].has_birthday_rule %}
                            <span class="badge bg-primary">Yes</span>
                            {% else %}
                            <span class="text-muted">No</span>
                            {% endif %}
                        </td>
                        <td>
                            {% if state_rules[state].has_effective_date_rule %}
                            <span class="badge bg-success">Yes</span>
                            {% else %}
                            <span class="text-muted">No</span>
                            {% endif %}
                        </td>
                        <td>
                            {% if state_rules[state].has_year_round_enrollment %}
                            <span class="badge bg-warning">No</span>
                            {% else %}
                            <span class="text-muted">Yes</span>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<div class="card">
    <div class="card-header bg-secondary text-white">
        <h5 class="card-title mb-0">Help & Information</h5>
    </div>
    <div class="card-body">
        <h6>Standard Email Scheduling Rules:</h6>
        <ul>
            <li><strong>Birthday emails:</strong> Sent 14 days before birthday</li>
            <li><strong>Effective date emails:</strong> Sent 30 days before policy anniversary</li>
            <li><strong>AEP emails:</strong> Distributed across August/September weeks</li>
            <li><strong>Post-window emails:</strong> Sent the day after exclusion period ends</li>
        </ul>
        
        <h6>Special State Rules:</h6>
        <ul>
            <li><strong>Birthday Rules:</strong> Special rules for states like CA, ID, IL, KY, LA, MD, NV, OK, OR that control when emails can be sent around a birthday</li>
            <li><strong>Effective Date Rules:</strong> Special rules for states like MO that control email timing around policy anniversary dates</li>
            <li><strong>Year-Round Enrollment:</strong> States like CT, MA, NY, WA that have year-round enrollment (no scheduled emails)</li>
        </ul>
    </div>
</div>

<script>
document.getElementById('scheduleForm').addEventListener('submit', function(e) {
    // Show loading spinner
    const button = document.getElementById('submitBtn');
    const spinner = button.querySelector('.spinner-border');
    button.disabled = true;
    spinner.classList.remove('d-none');
    
    // Handle state filtering
    const filterType = document.querySelector('input[name="filter_type"]:checked').value;
    const stateSelect = document.getElementById('state');
    const specialRulesOnly = document.getElementById('special_rules_only');
    
    if (filterType === 'none') {
        stateSelect.value = '';
        specialRulesOnly.value = 'false';
    } else if (filterType === 'special') {
        stateSelect.value = '';
        specialRulesOnly.value = 'true';
    } else if (filterType === 'state') {
        specialRulesOnly.value = 'false';
        if (!stateSelect.value) {
            e.preventDefault();
            alert('Please select a state');
            button.disabled = false;
            spinner.classList.add('d-none');
            return;
        }
    }
});

// Handle radio button changes
document.querySelectorAll('input[name="filter_type"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const stateSelect = document.getElementById('state');
        if (this.value === 'state') {
            stateSelect.disabled = false;
            stateSelect.required = true;
        } else {
            stateSelect.disabled = true;
            stateSelect.required = false;
            stateSelect.value = '';
        }
    });
});

// Initialize state select state
document.getElementById('state').disabled = true;
</script>
{% endblock %}

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--text-color);
        }
        
        .subtitle {
            margin-top: 8px;
            color: var(--text-secondary);
            font-size: 16px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
            background-color: var(--card-bg);
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .org-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-top: 16px;
        }
        
        .org-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .org-item:last-child {
            border-bottom: none;
        }
        
        .org-item:hover {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .org-name {
            font-weight: 500;
            color: var(--text-color);
        }
        
        .org-id {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .org-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .org-link:hover {
            text-decoration: underline;
        }
        
        .search-box {
            display: flex;
            align-items: center;
            position: relative;
            margin-bottom: 16px;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .no-orgs {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
        }
        
        .dashboard-link {
            display: inline-flex;
            align-items: center;
            margin-top: 16px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .dashboard-link:hover {
            text-decoration: underline;
        }
        
        .dashboard-link svg {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Email Scheduler</h1>
            <p class="subtitle">Schedule emails for Medicare services communications</p>
        </header>
        
        <div class="card">
            <h2 class="card-title">Select an Organization</h2>
            
            <div class="search-box">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="search-orgs" placeholder="Search organizations...">
            </div>
            
            <div class="org-list">
                {% if organizations %}
                    {% for org in organizations %}
                    <div class="org-item">
                        <div class="org-info">
                            <div class="org-name">{{ org.name }}</div>
                            <div class="org-id">ID: {{ org.id }}</div>
                        </div>
                        <a href="/org/{{ org.id }}" class="org-link">Select</a>
                    </div>
                    {% endfor %}
                {% else %}
                    <div class="no-orgs">
                        <p>No organizations found.</p>
                    </div>
                {% endif %}
            </div>
            
            <a href="/dashboard" class="dashboard-link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="3" y1="9" x2="21" y2="9"></line>
                    <line x1="9" y1="21" x2="9" y2="9"></line>
                </svg>
                View Dashboard
            </a>
        </div>
        
        <div class="card">
            <h2 class="card-title">Email Scheduling Rules</h2>
            <p>The system schedules four types of emails based on specific business rules:</p>
            <ul>
                <li><strong>Birthday Emails:</strong> Sent 14 days before a contact's birthday</li>
                <li><strong>Effective Date Emails:</strong> Sent 30 days before a policy effective date</li>
                <li><strong>AEP Emails:</strong> Sent during the Annual Enrollment Period (August-September)</li>
                <li><strong>Post-Window Emails:</strong> Sent after rule windows end, with special state handling</li>
            </ul>
            <p>Special rule states include: CA, ID, IL, KY, LA, MD, NV, OK, OR (birthday rules) and MO (effective date rule).</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-orgs');
            const orgItems = document.querySelectorAll('.org-item');
            
            // Search organizations
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                orgItems.forEach(item => {
                    const orgName = item.querySelector('.org-name').textContent.toLowerCase();
                    const orgId = item.querySelector('.org-id').textContent.toLowerCase();
                    
                    if (orgName.includes(searchTerm) || orgId.includes(searchTerm)) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });
        });
    </script>
</body>
</html>

================
File: templates/organization.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ org.name }} - Email Scheduler</title>
    <style>
        :root {
            --primary-color: #1a73e8;
            --primary-hover: #1765cc;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            --birthday-color: #4285F4;
            --effective-date-color: #34A853;
            --aep-color: #FBBC05;
            --post-window-color: #EA4335;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
            color: var(--text-color);
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 16px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .back-link svg {
            margin-right: 8px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
        }
        
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
            background-color: var(--card-bg);
        }
        
        .date-inputs {
            display: flex;
            gap: 16px;
        }
        
        .date-inputs .form-group {
            flex: 1;
        }
        
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        
        .btn-secondary:hover {
            background-color: rgba(26, 115, 232, 0.04);
        }
        
        .contacts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }
        
        .contacts-table th,
        .contacts-table td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .contacts-table th {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .contacts-table tr:hover {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .contacts-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .contact-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .search-box {
            display: flex;
            align-items: center;
            max-width: 300px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .select-all {
            display: flex;
            align-items: center;
            margin-left: 16px;
            font-size: 14px;
        }
        
        .select-all input {
            margin-right: 8px;
        }
        
        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            color: white;
        }
        
        .tag.birthday {
            background-color: var(--birthday-color);
        }
        
        .tag.effective-date {
            background-color: var(--effective-date-color);
        }
        
        .tag.aep {
            background-color: var(--aep-color);
            color: var(--text-color);
        }
        
        .tag.post-window {
            background-color: var(--post-window-color);
        }
        
        .state-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin-left: 8px;
        }
        
        .state-badge.special::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
            margin-right: 4px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-contacts {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 24px;
        }
        
        @media (max-width: 768px) {
            .date-inputs {
                flex-direction: column;
                gap: 8px;
            }
            
            .contacts-table th:nth-child(3),
            .contacts-table td:nth-child(3) {
                display: none;
            }
            
            .table-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .search-box {
                max-width: 100%;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="back-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Back to Organizations
        </a>
        
        <header>
            <h1>{{ org.name }}</h1>
        </header>
        
        <div class="card">
            <h2 class="card-title">Schedule Emails</h2>
            
            <form id="schedule-form" action="/schedule" method="post">
                <input type="hidden" name="session_id" value="{{ session_id }}">
                
                <div class="date-inputs">
                    <div class="form-group">
                        <label for="start-date" class="form-label">Start Date</label>
                        <input type="date" id="start-date" name="start_date" class="form-input" value="{{ today.isoformat() if today else '' }}">
                    </div>
                    
                    <div class="form-group">
                        <label for="end-date" class="form-label">End Date</label>
                        <input type="date" id="end-date" name="end_date" class="form-input" value="{{ (today + timedelta(days=365)).isoformat() if today else '' }}">
                    </div>
                </div>
                
                <div class="contacts-selection">
                    <div class="table-controls">
                        <div class="search-box">
                            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            </svg>
                            <input type="text" id="search-contacts" placeholder="Search contacts...">
                        </div>
                        
                        <div class="select-all">
                            <input type="checkbox" id="select-all-checkbox">
                            <label for="select-all-checkbox">Select All</label>
                        </div>
                    </div>
                    
                    <div class="contacts-container">
                        {% if contacts %}
                        <table class="contacts-table">
                            <thead>
                                <tr>
                                    <th width="50"></th>
                                    <th>Name</th>
                                    <th>Email</th>
                                    <th>State</th>
                                    <th>Birth Date</th>
                                    <th>Effective Date</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for contact in contacts %}
                                <tr class="contact-row">
                                    <td>
                                        <input type="checkbox" name="contact_ids" value="{{ contact.id }}" class="contact-checkbox">
                                    </td>
                                    <td>{{ contact.first_name }} {{ contact.last_name }}</td>
                                    <td>{{ contact.email }}</td>
                                    <td>
                                        {{ contact.state }}
                                        {% if contact.state in special_rule_states %}
                                        <span class="state-badge special" title="Special rules apply">Rule</span>
                                        {% endif %}
                                    </td>
                                    <td>{{ contact.birth_date }}</td>
                                    <td>{{ contact.effective_date }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                        {% else %}
                        <div class="no-contacts">
                            <p>No contacts found for this organization.</p>
                        </div>
                        {% endif %}
                    </div>
                </div>
                
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Scheduling emails...</p>
                </div>
                
                <div class="actions">
                    <button type="button" id="cancel-btn" class="btn btn-secondary">Cancel</button>
                    <button type="submit" id="schedule-btn" class="btn">Schedule Emails</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-contacts');
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
            const scheduleForm = document.getElementById('schedule-form');
            const scheduleBtn = document.getElementById('schedule-btn');
            const cancelBtn = document.getElementById('cancel-btn');
            const loading = document.getElementById('loading');
            
            // Search contacts
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const rows = document.querySelectorAll('.contact-row');
                
                rows.forEach(row => {
                    const contactName = row.children[1].textContent.toLowerCase();
                    const contactEmail = row.children[2].textContent.toLowerCase();
                    const contactState = row.children[3].textContent.toLowerCase();
                    
                    if (contactName.includes(searchTerm) || 
                        contactEmail.includes(searchTerm) || 
                        contactState.includes(searchTerm)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            });
            
            // Select all contacts
            selectAllCheckbox.addEventListener('change', function() {
                const isChecked = this.checked;
                
                // Only select visible contacts
                const visibleCheckboxes = Array.from(contactCheckboxes).filter(checkbox => {
                    return checkbox.closest('tr').style.display !== 'none';
                });
                
                visibleCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
            });
            
            // Update "Select All" state when individual contacts are selected/deselected
            contactCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateSelectAllState);
            });
            
            function updateSelectAllState() {
                const visibleCheckboxes = Array.from(contactCheckboxes).filter(checkbox => {
                    return checkbox.closest('tr').style.display !== 'none';
                });
                
                const allChecked = visibleCheckboxes.every(checkbox => checkbox.checked);
                const someChecked = visibleCheckboxes.some(checkbox => checkbox.checked);
                
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = someChecked && !allChecked;
            }
            
            // Form submission
            scheduleForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Validate that at least one contact is selected
                const selectedContacts = document.querySelectorAll('.contact-checkbox:checked');
                if (selectedContacts.length === 0) {
                    alert('Please select at least one contact.');
                    return;
                }
                
                // Show loading
                loading.style.display = 'block';
                scheduleBtn.disabled = true;
                
                // Submit form via AJAX
                const formData = new FormData(this);
                
                fetch('/schedule', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        loading.style.display = 'none';
                        scheduleBtn.disabled = false;
                    } else if (data.redirect) {
                        window.location.href = data.redirect;
                    } else {
                        alert(data.message || 'Emails scheduled successfully!');
                        loading.style.display = 'none';
                        scheduleBtn.disabled = false;
                    }
                })
                .catch(error => {
                    alert('An error occurred: ' + error.message);
                    loading.style.display = 'none';
                    scheduleBtn.disabled = false;
                });
            });
            
            // Cancel button
            cancelBtn.addEventListener('click', function() {
                window.location.href = '/';
            });
        });
    </script>
</body>
</html>

================
File: templates/results.html
================
{% extends "base.html" %}

{% block head %}
<!-- Add vis-timeline CSS -->
<link rel="stylesheet" href="/static/vis-timeline-graph2d.min.css">
<style>
.timeline-container { 
    margin-top: 20px; 
    height: 300px; 
}
.date-birthday { 
    background-color: #ffd700 !important; /* yellow */ 
}
.date-effective { 
    background-color: #ffa500 !important; /* orange */ 
}
.exclusion { 
    background-color: #ff0000 !important; /* red */
    opacity: 0.3; 
}
.email-birthday { 
    background-color: #008000 !important; /* green */ 
}
.email-effective-date { 
    background-color: #0000ff !important; /* blue */ 
}
.email-aep { 
    background-color: #800080 !important; /* purple */ 
}
.email-post-window { 
    background-color: #00ffff !important; /* cyan */ 
}
.timeline-wrapper {
    display: flex;
    margin-top: 20px;
}
.timeline-labels {
    width: 150px;
    padding-right: 10px;
}
.timeline-label {
    height: 60px;
    line-height: 60px;
    font-weight: bold;
    text-align: right;
    padding-right: 10px;
}
.timeline-content {
    flex: 1;
}
.timeline-row {
    height: 60px;
    margin-bottom: 5px;
}
.date-birthday {
    background-color: #ffd700 !important;
    border-color: #b8860b !important;
}
.date-effective {
    background-color: #ffa500 !important;
    border-color: #8b4513 !important;
}
.exclusion {
    background-color: rgba(255, 0, 0, 0.3) !important;
    border-color: #8b0000 !important;
}
.email-birthday {
    background-color: #32cd32 !important;
    border-color: #006400 !important;
}
.email-effective-date {
    background-color: #4169e1 !important;
    border-color: #00008b !important;
}
.email-aep {
    background-color: #9370db !important;
    border-color: #4b0082 !important;
}
.email-post-window {
    background-color: #00ffff !important;
    border-color: #008b8b !important;
}
.email-skipped {
    background-color: #808080 !important;
    border-color: #2f4f4f !important;
}
.vis-item {
    border-width: 2px !important;
    border-radius: 5px !important;
}
.vis-item.vis-point {
    border-width: 3px !important;
}
.vis-item.vis-selected {
    border-color: #000000 !important;
    background-color: inherit !important;
}
</style>
{% endblock %}

{% block content %}
<div class="mb-4">
    <h2>{{ org_name }} (ID: {{ org_id }})</h2>
    <p class="text-muted">
        Showing {{ sample_size }} contacts out of {{ total_contacts }} total contacts
        {% if selected_state %}
        (Filtered by state: {{ selected_state }})
        {% elif special_rules_only %}
        (Showing only states with special rules)
        {% endif %}
        {% if contact_search %}
        (Searching for: {{ contact_search }})
        {% endif %}
    </p>
    
    <form action="/check" method="post" class="d-inline">
        <input type="hidden" name="org_id" value="{{ org_id }}">
        <input type="hidden" name="state" value="{{ selected_state }}">
        <input type="hidden" name="special_rules_only" value="{{ 'true' if special_rules_only else 'false' }}">
        <select class="form-select form-select-sm d-inline w-auto" name="sample_size" onchange="this.form.submit()">
            {% for size in sample_sizes %}
            <option value="{{ size }}" {% if size == sample_size %}selected{% endif %}>Show {{ size }} contacts</option>
            {% endfor %}
        </select>
    </form>
    
    <button class="btn btn-primary btn-sm ms-2" onclick="resampleContacts()">
        <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
        Resample Contacts
    </button>
</div>

<div id="contacts-container">
    {% for contact_id, contact_data in contacts.items() %}
    <div class="card contact-card mb-4">
        <div class="card-header">
            <h5 class="card-title mb-0">
                {{ contact_data.contact_info.name }}
                <small class="text-muted">(ID: {{ contact_data.contact_info.id }})</small>
            </h5>
        </div>
        <div class="card-body">
            <div class="row mb-3">
                <div class="col-md-4">
                    <strong>Email:</strong> {{ contact_data.contact_info.email }}
                </div>
                <div class="col-md-4">
                    <strong>Birth Date:</strong> {{ contact_data.contact_info.birth_date or 'N/A' }}
                </div>
                <div class="col-md-4">
                    <strong>Effective Date:</strong> {{ contact_data.contact_info.effective_date or 'N/A' }}
                </div>
            </div>
            
            <div class="row">
                <div class="col-md-4">
                    {% include "state_info.html" %}
                </div>
                <div class="col-md-8">
                    {% include "email_table.html" %}
                </div>
            </div>
            
            <div class="row mt-4">
                <div class="col-12">
                    <h6>Timeline View:</h6>
                    <div class="timeline-wrapper">
                        <div class="timeline-labels">
                            <div class="timeline-label">Exclusion Periods</div>
                            <div class="timeline-label">Birthdays</div>
                            <div class="timeline-label">Effective Dates</div>
                            <div class="timeline-label">Scheduled Emails</div>
                            <div class="timeline-label">Skipped Emails</div>
                        </div>
                        <div class="timeline-content">
                            <div id="timeline-exclusions-{{ contact_data.contact_info.id }}" class="timeline-row"></div>
                            <div id="timeline-birthdays-{{ contact_data.contact_info.id }}" class="timeline-row"></div>
                            <div id="timeline-effective-dates-{{ contact_data.contact_info.id }}" class="timeline-row"></div>
                            <div id="timeline-scheduled-{{ contact_data.contact_info.id }}" class="timeline-row"></div>
                            <div id="timeline-skipped-{{ contact_data.contact_info.id }}" class="timeline-row"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<div class="mt-4 mb-4">
    <a href="/" class="btn btn-secondary">Check Another Organization</a>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/vis-timeline-graph2d.min.js"></script>
<script>
function createTimeline(containerId, items, options) {
    var container = document.getElementById(containerId);
    var dataset = new vis.DataSet(items);
    var timeline = new vis.Timeline(container, dataset, options);
    
    timeline.on('mouseOver', function(properties) {
        var item = dataset.get(properties.item);
        if (item && item.tooltip) {
            var element = document.getElementById(properties.item);
            if (element) {
                element.title = item.tooltip;
            }
        }
    });
}

var baseOptions = {
    start: '{{ current_date }}',
    end: '{{ end_date }}',
    height: '60px',
    zoomable: false,
    selectable: false,
    showCurrentTime: false,
    stack: false,
    verticalScroll: false,
    horizontalScroll: true
};

{% for contact_id, contact_data in contacts.items() %}
createTimeline('timeline-exclusions-{{ contact_data.contact_info.id }}', {{ contact_data.timeline_exclusions | tojson }}, Object.assign({}, baseOptions));
createTimeline('timeline-birthdays-{{ contact_data.contact_info.id }}', {{ contact_data.timeline_birthdays | tojson }}, Object.assign({}, baseOptions));
createTimeline('timeline-effective-dates-{{ contact_data.contact_info.id }}', {{ contact_data.timeline_effective_dates | tojson }}, Object.assign({}, baseOptions));
createTimeline('timeline-scheduled-{{ contact_data.contact_info.id }}', {{ contact_data.timeline_scheduled | tojson }}, Object.assign({}, baseOptions));
createTimeline('timeline-skipped-{{ contact_data.contact_info.id }}', {{ contact_data.timeline_skipped | tojson }}, Object.assign({}, baseOptions));
{% endfor %}

async function resampleContacts() {
    const button = document.querySelector('button');
    const spinner = button.querySelector('.spinner-border');
    const container = document.getElementById('contacts-container');
    const sampleSize = document.querySelector('select[name="sample_size"]').value;
    const state = '{{ selected_state or "" }}';
    const specialRulesOnly = {{ 'true' if special_rules_only else 'false' }};
    const contactSearch = '{{ contact_search or "" }}';
    
    button.disabled = true;
    spinner.classList.remove('d-none');
    
    try {
        let url = `/resample/{{ org_id }}?sample_size=${sampleSize}`;
        if (state) {
            url += `&state=${state}`;
        }
        url += `&special_rules_only=${specialRulesOnly}`;
        if (contactSearch) {
            url += `&contact_search=${encodeURIComponent(contactSearch)}`;
        }
        
        const response = await fetch(url, {
            method: 'POST'
        });
        
        if (!response.ok) {
            throw new Error('Failed to resample contacts');
        }
        
        location.reload();
    } catch (error) {
        console.error('Error resampling contacts:', error);
        alert('Failed to resample contacts. Please try again.');
    } finally {
        button.disabled = false;
        spinner.classList.add('d-none');
    }
}
</script>
{% endblock %}

================
File: templates/simulator.html
================
{% extends "base.html" %}

{% block content %}
<div class="container">
    <h1 class="mb-4">Email Scheduler Simulator</h1>
    
    <div class="row">
        <div class="col-md-5">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="card-title mb-0">Contact Information</h5>
                </div>
                <div class="card-body">
                    <form id="simulatorForm" method="post" action="/simulate">
                        <div class="mb-3">
                            <label for="state" class="form-label">State</label>
                            <select class="form-select" id="state" name="state" required>
                                <option value="" selected disabled>Select a state...</option>
                                {% for state in all_states %}
                                <option value="{{ state }}" 
                                    {% if state in special_rule_states %}data-special="true"{% endif %}
                                    data-birthday="{% if state in birthday_rule_states %}true{% else %}false{% endif %}"
                                    data-effective="{% if state in effective_date_rule_states %}true{% else %}false{% endif %}"
                                    data-yearround="{% if state in year_round_enrollment_states %}true{% else %}false{% endif %}">
                                    {{ state }}
                                    {% if state in special_rule_states %}
                                        (Special Rules)
                                    {% endif %}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="birth_date" class="form-label">Birth Date</label>
                            <input type="date" class="form-control" id="birth_date" name="birth_date" required>
                        </div>
                        
                        <div class="mb-3">
                            <label for="effective_date" class="form-label">Effective Date</label>
                            <input type="date" class="form-control" id="effective_date" name="effective_date">
                            <div class="form-text">Policy effective/anniversary date</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="start_date" class="form-label">Start Date</label>
                            <input type="date" class="form-control" id="start_date" name="start_date" value="{{ today }}" required>
                            <div class="form-text">Beginning of scheduling window</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="end_date" class="form-label">End Date</label>
                            <input type="date" class="form-control" id="end_date" name="end_date" value="{{ next_year }}" required>
                            <div class="form-text">End of scheduling window</div>
                        </div>
                        
                        <button type="submit" class="btn btn-primary" id="calculateBtn">
                            <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                            Calculate Scheduled Emails
                        </button>
                    </form>
                </div>
            </div>
            
            <div id="stateRules" class="card mt-4 d-none">
                <div class="card-header bg-info text-white">
                    <h5 class="card-title mb-0">State Rules</h5>
                </div>
                <div class="card-body">
                    <div id="birthdayRuleInfo" class="d-none">
                        <h6>Birthday Rule</h6>
                        <div id="birthdayRuleDetails"></div>
                    </div>
                    
                    <div id="effectiveDateRuleInfo" class="d-none">
                        <h6>Effective Date Rule</h6>
                        <div id="effectiveDateRuleDetails"></div>
                    </div>
                    
                    <div id="yearRoundInfo" class="d-none">
                        <div class="alert alert-warning">
                            <strong>Year-Round Enrollment State</strong>
                            <p>No AEP or post-window emails are sent in this state.</p>
                        </div>
                    </div>
                    
                    <div id="regularRuleInfo" class="d-none">
                        <div class="alert alert-info">
                            <strong>Standard Rules</strong>
                            <p>This state follows the standard email scheduling rules:</p>
                            <ul class="mb-0">
                                <li>Birthday emails: 14 days before birthday</li>
                                <li>Effective date emails: 30 days before anniversary</li>
                                <li>AEP emails: Distributed across August/September</li>
                                <li>Post-window emails: Day after exclusion period</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-7 mt-3 mt-md-0">
            <div id="resultsContainer" class="d-none">
                <div class="card">
                    <div class="card-header bg-success text-white">
                        <h5 class="card-title mb-0">Scheduled Emails</h5>
                    </div>
                    <div class="card-body">
                        <div id="emailResults"></div>
                    </div>
                </div>
                
                <div class="card mt-4">
                    <div class="card-header bg-secondary text-white">
                        <h5 class="card-title mb-0">Exclusion Periods</h5>
                    </div>
                    <div class="card-body">
                        <div id="exclusionResults"></div>
                    </div>
                </div>
                
                <div class="card mt-4">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="card-title mb-0">Important Dates</h5>
                    </div>
                    <div class="card-body">
                        <div id="birthdayResults" class="mb-4">
                            <h6>Birthdays in Period</h6>
                            <div id="birthdayDatesList"></div>
                        </div>
                        
                        <div id="effectiveDateResults" class="mb-4">
                            <h6>Effective Dates in Period</h6>
                            <div id="effectiveDatesList"></div>
                        </div>
                        
                        <div id="aepDateResults">
                            <h6>AEP Dates</h6>
                            <div id="aepDatesList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Show loading spinner on form submit
    document.getElementById('simulatorForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const button = document.getElementById('calculateBtn');
        const spinner = button.querySelector('.spinner-border');
        button.disabled = true;
        spinner.classList.remove('d-none');
        
        // Collect form data
        const formData = new FormData(this);
        
        // Make API call to calculate scheduled emails
        fetch('/simulate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(Object.fromEntries(formData)),
        })
        .then(response => response.json())
        .then(data => {
            displayResults(data);
            button.disabled = false;
            spinner.classList.add('d-none');
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while calculating scheduled emails.');
            button.disabled = false;
            spinner.classList.add('d-none');
        });
    });
    
    // Display state-specific rules when state is selected
    document.getElementById('state').addEventListener('change', function() {
        const selectedOption = this.options[this.selectedIndex];
        const hasBirthdayRule = selectedOption.getAttribute('data-birthday') === 'true';
        const hasEffectiveDateRule = selectedOption.getAttribute('data-effective') === 'true';
        const hasYearRoundEnrollment = selectedOption.getAttribute('data-yearround') === 'true';
        const stateCode = this.value;
        
        // Show state rules card
        document.getElementById('stateRules').classList.remove('d-none');
        
        // Reset all rule displays
        document.getElementById('birthdayRuleInfo').classList.add('d-none');
        document.getElementById('effectiveDateRuleInfo').classList.add('d-none');
        document.getElementById('yearRoundInfo').classList.add('d-none');
        document.getElementById('regularRuleInfo').classList.add('d-none');
        
        // Update rule displays based on state
        if (hasBirthdayRule) {
            document.getElementById('birthdayRuleInfo').classList.remove('d-none');
            updateBirthdayRuleInfo(stateCode);
        }
        
        if (hasEffectiveDateRule) {
            document.getElementById('effectiveDateRuleInfo').classList.remove('d-none');
            updateEffectiveDateRuleInfo(stateCode);
        }
        
        if (hasYearRoundEnrollment) {
            document.getElementById('yearRoundInfo').classList.remove('d-none');
        }
        
        if (!hasBirthdayRule && !hasEffectiveDateRule && !hasYearRoundEnrollment) {
            document.getElementById('regularRuleInfo').classList.remove('d-none');
        }
    });
    
    // Helper functions for state rule info
    function updateBirthdayRuleInfo(state) {
        const birthdayRuleDetails = document.getElementById('birthdayRuleDetails');
        
        // Define rule descriptions based on state
        const birthdayRules = {
            'CA': '60-day exclusion period: 30 days before and 30 days after birthday.',
            'ID': '63-day exclusion period: Starting on birthday and ending 63 days after.',
            'IL': '45-day exclusion period: Starting on birthday and ending 45 days after.',
            'KY': '60-day exclusion period: Starting on birthday and ending 60 days after.',
            'LA': '93-day exclusion period: 30 days before and 63 days after birthday.',
            'MD': '31-day exclusion period: Starting on birthday and ending 31 days after.',
            'NV': '60-day exclusion period: Starting on first day of birth month.',
            'OK': '60-day exclusion period: Starting on birthday and ending 60 days after.',
            'OR': '31-day exclusion period: Starting on birthday and ending 31 days after.'
        };
        
        birthdayRuleDetails.textContent = birthdayRules[state] || 'State has special birthday rules.';
    }
    
    function updateEffectiveDateRuleInfo(state) {
        const effectiveDateRuleDetails = document.getElementById('effectiveDateRuleDetails');
        
        // Define rule descriptions based on state
        const effectiveDateRules = {
            'MO': '63-day exclusion period: 30 days before and 33 days after the policy anniversary.',
        };
        
        effectiveDateRuleDetails.textContent = effectiveDateRules[state] || 'State has special effective date rules.';
    }
    
    // Function to display simulation results
    function displayResults(data) {
        // Show results container
        document.getElementById('resultsContainer').classList.remove('d-none');
        
        // Display scheduled emails
        const emailResultsDiv = document.getElementById('emailResults');
        if (data.emails.length > 0) {
            let emailsHtml = '<div class="table-responsive"><table class="table table-striped">';
            emailsHtml += '<thead><tr><th>Type</th><th>Date</th><th>Notes</th></tr></thead><tbody>';
            
            data.emails.forEach(email => {
                const formattedDate = new Date(email.date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                
                const badgeClass = {
                    'birthday': 'bg-primary',
                    'effective_date': 'bg-success',
                    'aep': 'bg-info',
                    'post_window': 'bg-warning text-dark'
                }[email.type] || 'bg-secondary';
                
                const typeName = {
                    'birthday': 'Birthday',
                    'effective_date': 'Effective Date',
                    'aep': 'AEP',
                    'post_window': 'Post-Window'
                }[email.type] || email.type;
                
                emailsHtml += `<tr>
                    <td><span class="badge ${badgeClass}">${typeName}</span></td>
                    <td>${formattedDate}</td>
                    <td>${email.reason || 'Normal scheduling rule'}</td>
                </tr>`;
            });
            
            emailsHtml += '</tbody></table></div>';
            emailResultsDiv.innerHTML = emailsHtml;
        } else {
            emailResultsDiv.innerHTML = '<div class="alert alert-warning">No emails scheduled for this contact.</div>';
        }
        
        // Display exclusion periods
        const exclusionResultsDiv = document.getElementById('exclusionResults');
        if (data.exclusion_periods.length > 0) {
            let exclusionHtml = '<div class="table-responsive"><table class="table table-striped">';
            exclusionHtml += '<thead><tr><th>Start Date</th><th>End Date</th><th>Duration</th><th>Type</th></tr></thead><tbody>';
            
            data.exclusion_periods.forEach(period => {
                const startDate = new Date(period.start_date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                
                const endDate = new Date(period.end_date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                
                // Calculate duration in days
                const start = new Date(period.start_date);
                const end = new Date(period.end_date);
                const diffTime = Math.abs(end - start);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end dates
                
                exclusionHtml += `<tr>
                    <td>${startDate}</td>
                    <td>${endDate}</td>
                    <td>${diffDays} days</td>
                    <td>${period.type || 'Standard'}</td>
                </tr>`;
            });
            
            exclusionHtml += '</tbody></table></div>';
            exclusionResultsDiv.innerHTML = exclusionHtml;
        } else {
            exclusionResultsDiv.innerHTML = '<div class="alert alert-info">No exclusion periods defined for this contact.</div>';
        }
        
        // Display birthday dates
        const birthdayDatesDiv = document.getElementById('birthdayDatesList');
        if (data.birthdays.length > 0) {
            const birthdaysList = data.birthdays.map(date => {
                return new Date(date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }).join('</li><li>');
            
            birthdayDatesDiv.innerHTML = `<ul><li>${birthdaysList}</li></ul>`;
        } else {
            birthdayDatesDiv.innerHTML = '<p class="text-muted">No birthdays in the selected period.</p>';
        }
        
        // Display effective dates
        const effectiveDatesDiv = document.getElementById('effectiveDatesList');
        if (data.effective_dates.length > 0) {
            const effectiveDatesList = data.effective_dates.map(date => {
                return new Date(date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }).join('</li><li>');
            
            effectiveDatesDiv.innerHTML = `<ul><li>${effectiveDatesList}</li></ul>`;
        } else {
            effectiveDatesDiv.innerHTML = '<p class="text-muted">No effective dates in the selected period.</p>';
        }
        
        // Display AEP dates
        const aepDatesDiv = document.getElementById('aepDatesList');
        if (data.aep_dates.length > 0) {
            const aepDatesList = data.aep_dates.map(date => {
                return new Date(date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }).join('</li><li>');
            
            aepDatesDiv.innerHTML = `<ul><li>${aepDatesList}</li></ul>`;
        } else {
            aepDatesDiv.innerHTML = '<p class="text-muted">No AEP dates in the selected period or not applicable.</p>';
        }
    }
});
</script>
{% endblock %}

================
File: templates/state_info.html
================
<div class="card border-info mb-3">
    <div class="card-header bg-info text-white">
        <strong>State: {{ contact_data.contact_info.state }}</strong>
        {% if contact_data.contact_info.state_info.has_birthday_rule or 
            contact_data.contact_info.state_info.has_effective_date_rule or 
            contact_data.contact_info.state_info.has_year_round_enrollment %}
        <span class="badge bg-light text-dark">Special Rules Apply</span>
        {% endif %}
    </div>
    <div class="card-body">
        {% if contact_data.contact_info.state_info.has_year_round_enrollment %}
        <div class="alert alert-warning">
            <strong>Year-Round Enrollment State</strong>
            <p class="mb-0 small">All emails are skipped because this state allows year-round enrollment.</p>
        </div>
        {% endif %}
        
        {% if contact_data.contact_info.state_info.has_birthday_rule %}
        <div class="mb-2">
            <strong class="text-primary">Birthday Rule</strong>
            <p class="mb-0 small">
                {% if contact_data.contact_info.state == "CA" %}
                60-day exclusion period: 30 days before and 30 days after birthday.
                {% elif contact_data.contact_info.state == "ID" %}
                63-day exclusion period: Starting on birthday and ending 63 days after.
                {% elif contact_data.contact_info.state == "IL" %}
                45-day exclusion period: Starting on birthday and ending 45 days after.
                {% elif contact_data.contact_info.state == "KY" %}
                60-day exclusion period: Starting on birthday and ending 60 days after.
                {% elif contact_data.contact_info.state == "LA" %}
                93-day exclusion period: 30 days before and 63 days after birthday.
                {% elif contact_data.contact_info.state == "MD" %}
                31-day exclusion period: Starting on birthday and ending 31 days after.
                {% elif contact_data.contact_info.state == "NV" %}
                60-day exclusion period: Starting on first day of birth month.
                {% elif contact_data.contact_info.state == "OK" %}
                60-day exclusion period: Starting on birthday and ending 60 days after.
                {% elif contact_data.contact_info.state == "OR" %}
                31-day exclusion period: Starting on birthday and ending 31 days after.
                {% endif %}
            </p>
        </div>
        {% endif %}
        
        {% if contact_data.contact_info.state_info.has_effective_date_rule %}
        <div class="mb-2">
            <strong class="text-success">Effective Date Rule</strong>
            <p class="mb-0 small">
                {% if contact_data.contact_info.state == "MO" %}
                63-day exclusion period: 30 days before and 33 days after the policy anniversary.
                {% endif %}
            </p>
        </div>
        {% endif %}
        
        <div class="mb-0 small text-muted">
            <p class="mb-0"><strong>Standard Scheduling Rules:</strong></p>
            <ul class="ps-3 mb-0">
                <li>Birthday emails: 14 days before birthday</li>
                <li>Effective date emails: 30 days before anniversary</li>
                <li>AEP emails: Distributed across August/September</li>
                <li>Post-window emails: Day after exclusion period</li>
            </ul>
        </div>
    </div>
</div>

================
File: templates/timeline.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Schedule Timeline - {{ org.name }}</title>
    <style>
        :root {
            --birthday-color: #4285F4;    /* Blue */
            --effective-date-color: #34A853; /* Green */
            --aep-color: #FBBC05;         /* Yellow */
            --post-window-color: #EA4335; /* Red */
            --rule-window-color: #9C27B0; /* Purple */
            --exclusion-color: #9AA0A6;   /* Gray */
            --skipped-opacity: 0.5;
            --timeline-background: #f8f9fa;
            --timeline-line: #dadce0;
            --font-primary: 'Google Sans', 'Roboto', Arial, sans-serif;
            --font-color: #202124;
            --font-color-secondary: #5f6368;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-primary);
            margin: 0;
            padding: 20px;
            color: var(--font-color);
            background-color: var(--timeline-background);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            padding: 24px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        h1 {
            color: var(--font-color);
            margin: 0;
            font-size: 24px;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            margin-bottom: 20px;
            color: #1a73e8;
            text-decoration: none;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .back-link svg {
            margin-right: 6px;
        }
        
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 24px;
            padding: 16px;
            background-color: var(--timeline-background);
            border-radius: 8px;
        }
        
        .filter-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid transparent;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            color: var(--font-color);
        }
        
        .filter-btn .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .filter-btn.active {
            background-color: #e8f0fe;
            border-color: #1a73e8;
        }
        
        .filter-btn:hover {
            background-color: #f1f3f4;
        }
        
        .filter-btn.birthday .color-dot {
            background-color: var(--birthday-color);
        }
        
        .filter-btn.effective_date .color-dot {
            background-color: var(--effective-date-color);
        }
        
        .filter-btn.aep .color-dot {
            background-color: var(--aep-color);
        }
        
        .filter-btn.post_window .color-dot {
            background-color: var(--post-window-color);
        }
        
        .filter-btn.rule_window .color-dot {
            background-color: var(--rule-window-color);
        }
        
        .filter-btn.exclusion .color-dot {
            background-color: var(--exclusion-color);
        }
        
        .timeline-header {
            position: relative;
            margin-bottom: 24px;
            margin-left: 200px;
        }
        
        .timeline-axis {
            position: relative;
            display: flex;
            border-bottom: 1px solid var(--timeline-line);
            padding-bottom: 4px;
        }
        
        .timeline-axis .month {
            font-size: 12px;
            color: var(--font-color-secondary);
            text-align: center;
            text-transform: uppercase;
            flex: 1;
        }
        
        .timeline-ruler {
            position: relative;
            height: 20px;
        }
        
        .timeline-ruler .tick {
            position: absolute;
            width: 1px;
            height: 6px;
            background-color: var(--timeline-line);
            top: 0;
        }
        
        .timeline-ruler .tick.first-of-month {
            height: 10px;
        }
        
        .timeline-ruler .date-label {
            position: absolute;
            font-size: 10px;
            color: var(--font-color-secondary);
            top: 12px;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        .contacts-container {
            max-height: 700px;
            overflow-y: auto;
            padding-right: 16px;
        }
        
        .contact-timeline {
            margin-bottom: 32px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 1px 2px rgba(60,64,67,0.3);
            overflow: hidden;
        }
        
        .contact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background-color: #f8f9fa;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        .contact-info h3 {
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 500;
        }
        
        .contact-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: var(--font-color-secondary);
        }
        
        .contact-details .detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .detail-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }
        
        .view-quote-btn {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .view-quote-btn:hover {
            background-color: #1765cc;
        }
        
        .timeline-lanes {
            position: relative;
            padding: 24px 16px 24px 200px;
        }
        
        .lane {
            position: relative;
            height: 40px;
            margin-bottom: 16px;
        }
        
        .lane-label {
            position: absolute;
            left: -180px;
            top: 10px;
            width: 160px;
            text-align: right;
            font-size: 14px;
            color: var(--font-color-secondary);
            font-weight: 500;
        }
        
        .lane-track {
            position: relative;
            height: 100%;
            background-color: #f1f3f4;
            border-radius: 4px;
        }
        
        .timeline-item {
            position: absolute;
            height: 28px;
            top: 6px;
            border-radius: 14px;
            color: white;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 12px;
            cursor: pointer;
            z-index: 3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 70px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .timeline-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 4;
        }
        
        .timeline-item.birthday {
            background-color: var(--birthday-color);
        }
        
        .timeline-item.effective_date {
            background-color: var(--effective-date-color);
        }
        
        .timeline-item.aep {
            background-color: var(--aep-color);
            color: #202124;
        }
        
        .timeline-item.post_window {
            background-color: var(--post-window-color);
        }
        
        .timeline-item.skipped {
            opacity: var(--skipped-opacity);
            border: 2px dashed rgba(255,255,255,0.8);
        }
        
        .rule-window {
            position: absolute;
            height: 20px;
            top: 10px;
            background-color: var(--rule-window-color);
            opacity: 0.3;
            border-radius: 4px;
            z-index: 1;
            cursor: pointer;
        }
        
        .exclusion-window {
            position: absolute;
            height: 40px;
            top: 0;
            background-color: var(--exclusion-color);
            opacity: 0.3;
            border-radius: 4px;
            z-index: 2;
            cursor: pointer;
        }
        
        .tooltip {
            position: fixed;
            background-color: white;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
            min-width: 220px;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .tooltip-header {
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--font-color);
            padding-bottom: 4px;
            border-bottom: 1px solid var(--timeline-line);
        }
        
        .tooltip-content {
            font-size: 13px;
            color: var(--font-color-secondary);
        }
        
        .tooltip-row {
            display: flex;
            margin-bottom: 4px;
        }
        
        .tooltip-label {
            flex: 0 0 70px;
            font-weight: 500;
        }
        
        .tooltip-value {
            flex: 1;
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: var(--font-color-secondary);
            background-color: var(--timeline-background);
            border-radius: 8px;
            font-size: 16px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #1a73e8;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--timeline-line);
        }
        
        .action-btn {
            padding: 8px 16px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
        }
        
        .action-btn:hover {
            background-color: #1765cc;
        }
        
        .action-btn svg {
            margin-right: 8px;
        }
        
        @media (max-width: 768px) {
            .timeline-header {
                margin-left: 0;
            }
            
            .timeline-lanes {
                padding-left: 16px;
            }
            
            .lane-label {
                position: relative;
                left: 0;
                top: 0;
                width: 100%;
                text-align: left;
                margin-bottom: 4px;
            }
            
            .lane {
                height: auto;
                margin-bottom: 24px;
            }
            
            .lane-track {
                margin-top: 24px;
            }
            
            .contact-details {
                flex-direction: column;
                gap: 4px;
            }
            
            .contact-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .view-quote-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/org/{{ org.id }}" class="back-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Back to Organization
        </a>
        
        <header>
            <h1>Email Schedule Timeline - {{ org.name }}</h1>
            <div class="controls">
                <label for="zoom-level">Zoom:</label>
                <select id="zoom-level">
                    <option value="5">5 days/px</option>
                    <option value="3">3 days/px</option>
                    <option value="2" selected>2 days/px</option>
                    <option value="1">1 day/px</option>
                    <option value="0.5">0.5 days/px</option>
                </select>
            </div>
        </header>
        
        <div class="filters" id="filters">
            <button class="filter-btn birthday active" data-type="birthday">
                <span class="color-dot"></span>
                <span>Birthday</span>
            </button>
            <button class="filter-btn effective_date active" data-type="effective_date">
                <span class="color-dot"></span>
                <span>Effective Date</span>
            </button>
            <button class="filter-btn aep active" data-type="aep">
                <span class="color-dot"></span>
                <span>AEP</span>
            </button>
            <button class="filter-btn post_window active" data-type="post_window">
                <span class="color-dot"></span>
                <span>Post Window</span>
            </button>
            <button class="filter-btn rule_window active" data-type="rule_window">
                <span class="color-dot"></span>
                <span>Rule Windows</span>
            </button>
            <button class="filter-btn exclusion active" data-type="exclusion">
                <span class="color-dot"></span>
                <span>Exclusion Windows</span>
            </button>
        </div>
        
        <div class="timeline-header" id="timeline-header"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing data...</p>
        </div>
        
        <div class="contacts-container" id="contacts-container">
            <div class="no-data" id="no-data">
                <p>Loading timeline data...</p>
            </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
        
        <div class="actions">
            <a href="/export/csv/{{ session_id }}" class="action-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Export CSV
            </a>
        </div>
    </div>

    <script>
        // Constants
        const MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const MONTH_NAMES_SHORT = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // State
        let timelineData = {{ timeline_data|safe }};
        let startDate = new Date();
        startDate.setDate(1);
        startDate.setMonth(startDate.getMonth() - 1);
        
        let endDate = new Date(startDate);
        endDate.setFullYear(endDate.getFullYear() + 1);
        
        let zoomLevel = 2; // days per pixel
        
        let filters = {
            birthday: true,
            effective_date: true,
            aep: true,
            post_window: true,
            rule_window: true,
            exclusion: true
        };
        
        // DOM Elements
        const timelineHeader = document.getElementById('timeline-header');
        const contactsContainer = document.getElementById('contacts-container');
        const tooltip = document.getElementById('tooltip');
        const noData = document.getElementById('no-data');
        const loading = document.getElementById('loading');
        const zoomSelect = document.getElementById('zoom-level');
        const filtersContainer = document.getElementById('filters');
        
        // Event Listeners
        zoomSelect.addEventListener('change', (e) => {
            zoomLevel = parseFloat(e.target.value);
            renderTimeline();
        });
        
        filtersContainer.addEventListener('click', (e) => {
            const button = e.target.closest('.filter-btn');
            if (button) {
                const type = button.dataset.type;
                filters[type] = !filters[type];
                button.classList.toggle('active');
                updateVisibility();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (tooltip.style.opacity !== '0') {
                tooltip.style.left = (e.pageX + 10) + 'px';
                tooltip.style.top = (e.pageY + 10) + 'px';
            }
        });
        
        // Functions
        function parseDate(dateString) {
            if (!dateString || dateString.trim() === '') return null;
            
            // Try standard ISO format
            const date = new Date(dateString);
            if (!isNaN(date.getTime())) return date;
            
            // Try MM/DD/YYYY format
            const parts = dateString.split(/[\/\-]/);
            if (parts.length === 3) {
                // Check if month is first (MM/DD/YYYY)
                if (parseInt(parts[0]) <= 12) {
                    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));
                }
                // Check if year is first (YYYY/MM/DD)
                else if (parseInt(parts[0]) > 31) {
                    return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                }
            }
            
            console.warn(`Could not parse date: ${dateString}`);
            return null;
        }
        
        function updateDateRange() {
            if (timelineData.length === 0) return;
            
            // Find earliest and latest dates in the data
            let earliestDate = new Date();
            let latestDate = new Date(0);
            
            timelineData.forEach(item => {
                if (item.date) {
                    const date = parseDate(item.date);
                    if (date && date < earliestDate) {
                        earliestDate = date;
                    }
                    if (date && date > latestDate) {
                        latestDate = date;
                    }
                }
                
                if (item.end_date) {
                    const endDate = parseDate(item.end_date);
                    if (endDate && endDate > latestDate) {
                        latestDate = endDate;
                    }
                }
            });
            
            // Set start date to beginning of month of earliest date
            startDate = new Date(earliestDate);
            startDate.setDate(1);
            startDate.setMonth(startDate.getMonth() - 1);
            
            // Set end date to end of month of latest date
            endDate = new Date(latestDate);
            endDate.setMonth(endDate.getMonth() + 2, 0);
        }
        
        function renderTimeline() {
            // Show loading
            loading.style.display = 'block';
            noData.style.display = 'none';
            
            // Update date range based on data
            updateDateRange();
            
            // Clear containers
            timelineHeader.innerHTML = '';
            contactsContainer.innerHTML = '';
            
            if (timelineData.length === 0) {
                noData.style.display = 'block';
                loading.style.display = 'none';
                return;
            }
            
            // Render timeline header
            renderTimelineHeader();
            
            // Group data by contact
            const contactsMap = groupByContact(timelineData);
            
            // Render contact timelines
            Object.values(contactsMap).forEach(contact => {
                renderContactTimeline(contact);
            });
            
            // Update visibility based on filters
            updateVisibility();
            
            // Hide loading
            loading.style.display = 'none';
        }
        
        function renderTimelineHeader() {
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            const totalWidth = Math.ceil(totalDays / zoomLevel);
            
            // Create months axis
            const timelineAxis = document.createElement('div');
            timelineAxis.className = 'timeline-axis';
            timelineAxis.style.width = totalWidth + 'px';
            
            // Add months
            let currentDate = new Date(startDate);
            while (currentDate < endDate) {
                const monthStart = new Date(currentDate);
                
                currentDate.setMonth(currentDate.getMonth() + 1);
                
                const daysInMonth = Math.floor((currentDate - monthStart) / (1000 * 60 * 60 * 24));
                const monthWidth = Math.ceil(daysInMonth / zoomLevel);
                
                const month = document.createElement('div');
                month.className = 'month';
                month.textContent = MONTH_NAMES_SHORT[monthStart.getMonth()];
                month.style.width = monthWidth + 'px';
                
                timelineAxis.appendChild(month);
            }
            
            // Create ruler
            const timelineRuler = document.createElement('div');
            timelineRuler.className = 'timeline-ruler';
            timelineRuler.style.width = totalWidth + 'px';
            
            // Add ticks for days
            currentDate = new Date(startDate);
            let position = 0;
            
            while (currentDate <= endDate) {
                if (currentDate.getDate() % 5 === 1 || currentDate.getDate() === 1) {
                    const tick = document.createElement('div');
                    tick.className = `tick ${currentDate.getDate() === 1 ? 'first-of-month' : ''}`;
                    tick.style.left = position + 'px';
                    
                    if (currentDate.getDate() === 1 || (zoomLevel <= 1 && currentDate.getDate() % 5 === 1)) {
                        const dateLabel = document.createElement('div');
                        dateLabel.className = 'date-label';
                        dateLabel.textContent = currentDate.getDate() === 1 
                            ? `${MONTH_NAMES_SHORT[currentDate.getMonth()]} 1` 
                            : currentDate.getDate();
                        dateLabel.style.left = position + 'px';
                        timelineRuler.appendChild(dateLabel);
                    }
                    
                    timelineRuler.appendChild(tick);
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
                position = Math.ceil((currentDate - startDate) / (1000 * 60 * 60 * 24) / zoomLevel);
            }
            
            timelineHeader.appendChild(timelineAxis);
            timelineHeader.appendChild(timelineRuler);
        }
        
        function groupByContact(data) {
            const contacts = {};
            
            data.forEach(item => {
                const contactId = item.contact_id;
                
                if (!contacts[contactId]) {
                    contacts[contactId] = {
                        org_id: item.org_id,
                        contact_id: contactId,
                        first_name: item.first_name,
                        last_name: item.last_name,
                        email: item.email,
                        state: item.state,
                        birth_date: item.birth_date,
                        effective_date: item.effective_date,
                        items: []
                    };
                }
                
                contacts[contactId].items.push(item);
            });
            
            return contacts;
        }
        
        function renderContactTimeline(contact) {
            const contactTimeline = document.createElement('div');
            contactTimeline.className = 'contact-timeline';
            contactTimeline.dataset.contactId = contact.contact_id;
            
            // Create contact header
            const contactHeader = document.createElement('div');
            contactHeader.className = 'contact-header';
            
            const contactInfo = document.createElement('div');
            contactInfo.className = 'contact-info';
            
            const contactName = document.createElement('h3');
            contactName.textContent = `${contact.first_name} ${contact.last_name}`;
            
            const contactDetails = document.createElement('div');
            contactDetails.className = 'contact-details';
            
            // Email
            const emailDetail = document.createElement('div');
            emailDetail.className = 'detail';
            emailDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                    <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
                <span>${contact.email}</span>
            `;
            
            // State
            const stateDetail = document.createElement('div');
            stateDetail.className = 'detail';
            stateDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                <span>${contact.state}</span>
            `;
            
            // Contact ID
            const idDetail = document.createElement('div');
            idDetail.className = 'detail';
            idDetail.innerHTML = `
                <svg class="detail-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
                <span>ID: ${contact.contact_id}</span>
            `;
            
            contactDetails.appendChild(emailDetail);
            contactDetails.appendChild(stateDetail);
            contactDetails.appendChild(idDetail);
            
            contactInfo.appendChild(contactName);
            contactInfo.appendChild(contactDetails);
            
            // Create quote button
            const quoteBtn = document.createElement('button');
            quoteBtn.className = 'view-quote-btn';
            quoteBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M16 12l-4 4-4-4M12 8v7"></path>
                </svg>
                View Quote
            `;
            
            // Find first email with a link
            const firstItemWithLink = contact.items.find(item => item.link && item.link.trim() !== '');
            const quoteLink = firstItemWithLink ? firstItemWithLink.link : `https://example.com/quote/${contact.org_id}/${contact.contact_id}`;
            
            quoteBtn.addEventListener('click', () => {
                window.open(quoteLink, '_blank');
            });
            
            contactHeader.appendChild(contactInfo);
            contactHeader.appendChild(quoteBtn);
            
            contactTimeline.appendChild(contactHeader);
            
            // Create timeline lanes
            const timelineLanes = document.createElement('div');
            timelineLanes.className = 'timeline-lanes';
            
            // Create lanes for email types
            const laneTypes = ['birthday', 'effective_date', 'aep', 'post_window'];
            
            laneTypes.forEach(type => {
                const lane = createLane(type, contact);
                timelineLanes.appendChild(lane);
            });
            
            contactTimeline.appendChild(timelineLanes);
            contactsContainer.appendChild(contactTimeline);
        }
        
        function createLane(type, contact) {
            const lane = document.createElement('div');
            lane.className = 'lane';
            lane.dataset.type = type;
            
            const laneLabel = document.createElement('div');
            laneLabel.className = 'lane-label';
            laneLabel.textContent = formatLaneLabel(type);
            
            const laneTrack = document.createElement('div');
            laneTrack.className = 'lane-track';
            
            // Calculate total width
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            const totalWidth = Math.ceil(totalDays / zoomLevel);
            laneTrack.style.width = totalWidth + 'px';
            
            // Add exclusion windows
            const exclusionItems = contact.items.filter(item => 
                item.item_type === 'exclusion' && 
                item.date && 
                item.end_date
            );
            
            exclusionItems.forEach(item => {
                const startDateObj = parseDate(item.date);
                const endDateObj = parseDate(item.end_date);
                
                if (startDateObj && endDateObj) {
                    const exclusion = document.createElement('div');
                    exclusion.className = 'exclusion-window';
                    exclusion.dataset.type = 'exclusion';
                    
                    const position = getPositionFromDate(startDateObj);
                    const width = getWidthBetweenDates(startDateObj, endDateObj);
                    
                    exclusion.style.left = position + 'px';
                    exclusion.style.width = width + 'px';
                    
                    exclusion.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: 'Exclusion Window',
                            date: formatDate(startDateObj),
                            end_date: formatDate(endDateObj),
                            description: item.description
                        });
                    });
                    
                    exclusion.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(exclusion);
                }
            });
            
            // Add rule windows
            const ruleWindowItems = contact.items.filter(item => 
                item.item_type === 'rule_window' && 
                item.date && 
                item.end_date
            );
            
            ruleWindowItems.forEach(item => {
                const startDateObj = parseDate(item.date);
                const endDateObj = parseDate(item.end_date);
                
                if (startDateObj && endDateObj) {
                    const ruleWindow = document.createElement('div');
                    ruleWindow.className = 'rule-window';
                    ruleWindow.dataset.type = 'rule_window';
                    
                    const position = getPositionFromDate(startDateObj);
                    const width = getWidthBetweenDates(startDateObj, endDateObj);
                    
                    ruleWindow.style.left = position + 'px';
                    ruleWindow.style.width = width + 'px';
                    
                    ruleWindow.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: 'Rule Window',
                            date: formatDate(startDateObj),
                            end_date: formatDate(endDateObj),
                            description: item.description
                        });
                    });
                    
                    ruleWindow.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(ruleWindow);
                }
            });
            
            // Add email items
            const emailItems = contact.items.filter(item => 
                item.item_type === type && 
                item.date
            );
            
            emailItems.forEach(item => {
                const dateObj = parseDate(item.date);
                
                if (dateObj) {
                    const timelineItem = document.createElement('div');
                    timelineItem.className = `timeline-item ${type}`;
                    timelineItem.dataset.type = type;
                    
                    if (item.skipped === 'Yes') {
                        timelineItem.classList.add('skipped');
                    }
                    
                    const position = getPositionFromDate(dateObj);
                    timelineItem.style.left = position + 'px';
                    
                    timelineItem.textContent = formatDate(dateObj, true);
                    
                    timelineItem.addEventListener('mouseenter', () => {
                        showTooltip({
                            title: `${formatLaneLabel(type)} Email${item.skipped === 'Yes' ? ' (Skipped)' : ''}`,
                            date: formatDate(dateObj),
                            reason: item.reason,
                            description: item.description
                        });
                    });
                    
                    timelineItem.addEventListener('mouseleave', hideTooltip);
                    
                    laneTrack.appendChild(timelineItem);
                }
            });
            
            lane.appendChild(laneLabel);
            lane.appendChild(laneTrack);
            
            return lane;
        }
        
        function getPositionFromDate(date) {
            const daysSinceStart = Math.ceil((date - startDate) / (1000 * 60 * 60 * 24));
            return Math.floor(daysSinceStart / zoomLevel);
        }
        
        function getWidthBetweenDates(startDate, endDate) {
            const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            return Math.max(Math.floor(daysDiff / zoomLevel), 1);
        }
        
        function formatLaneLabel(type) {
            switch (type) {
                case 'birthday': return 'Birthday';
                case 'effective_date': return 'Effective Date';
                case 'aep': return 'AEP';
                case 'post_window': return 'Post Window';
                default: return type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
        }
        
        function formatDate(date, short = false) {
            if (!date) return '';
            
            if (short) {
                return `${MONTH_NAMES_SHORT[date.getMonth()]} ${date.getDate()}`;
            }
            
            return `${MONTH_NAMES[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }
        
        function showTooltip(data) {
            tooltip.innerHTML = `
                <div class="tooltip-header">${data.title}</div>
                <div class="tooltip-content">
                    <div class="tooltip-row">
                        <div class="tooltip-label">Date:</div>
                        <div class="tooltip-value">${data.date}</div>
                    </div>
                    ${data.end_date ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">End Date:</div>
                        <div class="tooltip-value">${data.end_date}</div>
                    </div>
                    ` : ''}
                    ${data.reason ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">Reason:</div>
                        <div class="tooltip-value">${data.reason}</div>
                    </div>
                    ` : ''}
                    ${data.description ? `
                    <div class="tooltip-row">
                        <div class="tooltip-label">Details:</div>
                        <div class="tooltip-value">${data.description}</div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            tooltip.style.opacity = '1';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = '0';
        }
        
        function updateVisibility() {
            // Update visibility based on filters
            for (const type in filters) {
                const visible = filters[type];
                
                // Update items
                document.querySelectorAll(`[data-type="${type}"]`).forEach(el => {
                    el.style.display = visible ? '' : 'none';
                });
            }
        }
        
        // Initialize
        function init() {
            // Set initial zoom level
            zoomSelect.value = zoomLevel.toString();
            
            // Add an event listener for escape key to hide tooltip
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideTooltip();
                }
            });
            
            // Render timeline
            renderTimeline();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>

================
File: app.py
================
from fastapi import FastAPI, Request, Form, Body
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from pydantic import BaseModel
import pandas as pd
import tempfile
import os
from datetime import date, datetime, timedelta
import asyncio
from typing import Optional, List, Dict, Any
import random
import json

# Import our email scheduling code
from schedule_org_emails import (
    get_organization_details,
    get_contacts_from_org_db,
    format_contact_data,
    process_contacts_async,
    BIRTHDAY_RULE_STATES,
    EFFECTIVE_DATE_RULE_STATES,
    YEAR_ROUND_ENROLLMENT_STATES,
    write_results_to_csv
)

from email_scheduler_common import (
    calculate_birthday_email_date, 
    calculate_effective_date_email, 
    get_aep_dates_for_year,
    DateRange,
    calculate_post_window_dates,
    calculate_rule_windows,
    calculate_exclusion_periods,
    is_date_excluded,
    get_all_occurrences
)

reload_db = False # set to True to refresh the database

async def refresh_databases(org_id: int) -> None:
    """
    Refresh databases by running dump_and_convert.sh script if reload is enabled
    
    Args:
        org_id: Organization ID to refresh
    """
    if reload_db:
        # Run dump_and_convert.sh with the org ID
        print(f"Refreshing database for org {org_id}")
        process = await asyncio.create_subprocess_shell(
            f"./dump_and_convert.sh {org_id}",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        # Wait for process to complete
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            # Log error but continue
            print(f"Warning: Database refresh failed for org {org_id}")
            if stderr:
                print(f"Error: {stderr.decode()}")
    else:
        print(f"Skipping database refresh for org {org_id}")


app = FastAPI(title="Email Schedule Checker")

# Set up Jinja2 templates
templates = Jinja2Templates(directory="templates")

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Store DataFrames in memory (key: org_id)
org_data_store = {}

# Get list of states with special rules
SPECIAL_RULE_STATES = sorted(set(
    list(BIRTHDAY_RULE_STATES.keys()) + 
    list(EFFECTIVE_DATE_RULE_STATES.keys()) + 
    list(YEAR_ROUND_ENROLLMENT_STATES)
))

# All US states
ALL_STATES = [
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
    'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
    'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
    'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
    'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',
    'DC'
]

# Load ZIP code data
with open('zipData.json') as f:
    ZIP_DATA = json.load(f)

def get_state_from_zip(zip_code: str) -> str:
    """
    Get state from ZIP code using zipData.json
    
    Args:
        zip_code: ZIP code as string
        
    Returns:
        Two-letter state code, or None if not found
    """
    try:
        if not zip_code or not str(zip_code).strip():
            return None
        # Convert to string and take first 5 digits
        zip_str = str(zip_code)[:5]
        if zip_str in ZIP_DATA:
            return ZIP_DATA[zip_str]['state']
    except (KeyError, TypeError, ValueError):
        pass
    return None

def sample_contacts_from_states(unique_contacts: pd.DataFrame, sample_size: int, state: Optional[str] = None) -> List[str]:
    """
    Sample contacts ensuring a good distribution across states
    
    Args:
        unique_contacts: DataFrame of unique contacts with their states
        sample_size: Number of contacts to sample
        state: Optional specific state to filter by
        
    Returns:
        List of sampled contact IDs
    """
    sample_ids = []
    
    # If filtering by specific state, do simple random sample
    if state and state.strip():
        state_contacts = unique_contacts[unique_contacts['state'] == state]
        if len(state_contacts) > 0:
            sample_ids = random.sample(
                list(state_contacts['contact_id']), 
                min(sample_size, len(state_contacts))
            )
        return sample_ids
    
    # Get contacts grouped by state
    states_contacts = {
        state: group['contact_id'].tolist() 
        for state, group in unique_contacts.groupby('state')
    }
    
    # If we have fewer states than sample size, adjust distribution
    states_count = len(states_contacts)
    if states_count == 0:
        return []
    
    # Calculate initial distribution
    if states_count >= sample_size:
        # If we have more states than sample size, randomly select states
        selected_states = random.sample(list(states_contacts.keys()), sample_size)
        # Take one contact from each selected state
        for state in selected_states:
            if states_contacts[state]:
                contact = random.choice(states_contacts[state])
                sample_ids.append(contact)
    else:
        # Distribute samples across states as evenly as possible
        base_per_state = sample_size // states_count
        extra = sample_size % states_count
        
        # Shuffle states to randomize which ones get extra samples
        state_list = list(states_contacts.keys())
        random.shuffle(state_list)
        
        # Distribute samples
        for i, state in enumerate(state_list):
            # Calculate how many samples for this state
            state_sample_size = base_per_state + (1 if i < extra else 0)
            state_contacts = states_contacts[state]
            
            # If we don't have enough contacts in this state, take what we can
            state_sample_size = min(state_sample_size, len(state_contacts))
            
            if state_sample_size > 0:
                state_samples = random.sample(state_contacts, state_sample_size)
                sample_ids.extend(state_samples)
    
    # If we still need more samples, take them randomly from remaining contacts
    if len(sample_ids) < sample_size:
        remaining_contacts = [
            cid for cid in unique_contacts['contact_id'] 
            if cid not in sample_ids
        ]
        if remaining_contacts:
            additional_needed = sample_size - len(sample_ids)
            additional_samples = random.sample(
                remaining_contacts,
                min(additional_needed, len(remaining_contacts))
            )
            sample_ids.extend(additional_samples)
    
    return sample_ids

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Render the home page with organization input form"""
    return templates.TemplateResponse(
        "home.html",
        {
            "request": request,
            "title": "Email Schedule Checker",
            "sample_sizes": [5, 10, 25, 50, 100],
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "state_rules": {
                state: {
                    "has_birthday_rule": state in BIRTHDAY_RULE_STATES,
                    "has_effective_date_rule": state in EFFECTIVE_DATE_RULE_STATES,
                    "has_year_round_enrollment": state in YEAR_ROUND_ENROLLMENT_STATES
                }
                for state in ALL_STATES
            }
        }
    )

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Display a live dashboard of scheduled emails by state"""
    # Initialize data counters
    email_counts_by_state = {state: {
        "birthday": 0,
        "effective_date": 0,
        "aep": 0,
        "post_window": 0,
        "total": 0,
        "skipped": 0,
        "has_special_rule": state in SPECIAL_RULE_STATES
    } for state in ALL_STATES}
    
    # Placeholder data - in a real app, this would come from database
    total_emails = 0
    total_skipped = 0
    
    # Add dummy data for demonstration
    for state in SPECIAL_RULE_STATES:
        email_counts_by_state[state]["birthday"] = random.randint(10, 50)
        email_counts_by_state[state]["effective_date"] = random.randint(5, 40)
        email_counts_by_state[state]["aep"] = random.randint(0, 30) if state not in YEAR_ROUND_ENROLLMENT_STATES else 0
        email_counts_by_state[state]["post_window"] = random.randint(0, 20) if state not in YEAR_ROUND_ENROLLMENT_STATES else 0
        email_counts_by_state[state]["skipped"] = random.randint(1, 10)
        email_counts_by_state[state]["total"] = (
            email_counts_by_state[state]["birthday"] + 
            email_counts_by_state[state]["effective_date"] + 
            email_counts_by_state[state]["aep"] + 
            email_counts_by_state[state]["post_window"]
        )
        
        total_emails += email_counts_by_state[state]["total"]
        total_skipped += email_counts_by_state[state]["skipped"]
    
    # Add some data for non-special states
    for i, state in enumerate(list(set(ALL_STATES) - set(SPECIAL_RULE_STATES))):
        if i < 10:  # Only populate some non-special states
            email_counts_by_state[state]["birthday"] = random.randint(5, 30)
            email_counts_by_state[state]["effective_date"] = random.randint(3, 25)
            email_counts_by_state[state]["aep"] = random.randint(0, 20)
            email_counts_by_state[state]["post_window"] = random.randint(0, 15)
            email_counts_by_state[state]["skipped"] = random.randint(0, 5)
            email_counts_by_state[state]["total"] = (
                email_counts_by_state[state]["birthday"] + 
                email_counts_by_state[state]["effective_date"] + 
                email_counts_by_state[state]["aep"] + 
                email_counts_by_state[state]["post_window"]
            )
            
            total_emails += email_counts_by_state[state]["total"]
            total_skipped += email_counts_by_state[state]["skipped"]
    
    # Calculate percentages for total stats
    email_type_totals = {
        "birthday": sum(state_data["birthday"] for state_data in email_counts_by_state.values()),
        "effective_date": sum(state_data["effective_date"] for state_data in email_counts_by_state.values()),
        "aep": sum(state_data["aep"] for state_data in email_counts_by_state.values()),
        "post_window": sum(state_data["post_window"] for state_data in email_counts_by_state.values()),
    }
    
    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "title": "Email Scheduling Dashboard",
            "email_counts": email_counts_by_state,
            "total_emails": total_emails,
            "total_skipped": total_skipped,
            "email_type_totals": email_type_totals,
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "birthday_rule_states": BIRTHDAY_RULE_STATES,
            "effective_date_rule_states": EFFECTIVE_DATE_RULE_STATES,
            "year_round_enrollment_states": YEAR_ROUND_ENROLLMENT_STATES
        }
    )

# Simulator data model
class SimulationRequest(BaseModel):
    state: str
    birth_date: str
    effective_date: Optional[str] = None
    start_date: str
    end_date: str

@app.get("/simulator", response_class=HTMLResponse)
async def simulator(request: Request):
    """Display email scheduling simulator"""
    # Default dates
    today = date.today()
    next_year = today + timedelta(days=365)
    
    return templates.TemplateResponse(
        "simulator.html",
        {
            "request": request,
            "title": "Email Scheduler Simulator",
            "all_states": ALL_STATES,
            "special_rule_states": SPECIAL_RULE_STATES,
            "birthday_rule_states": BIRTHDAY_RULE_STATES,
            "effective_date_rule_states": EFFECTIVE_DATE_RULE_STATES,
            "year_round_enrollment_states": YEAR_ROUND_ENROLLMENT_STATES,
            "today": today.isoformat(),
            "next_year": next_year.isoformat()
        }
    )

@app.post("/simulate")
async def simulate_emails(data: SimulationRequest):
    """Simulate email scheduling for a given contact"""
    try:
        # Parse dates
        birth_date = datetime.strptime(data.birth_date, "%Y-%m-%d").date()
        start_date = datetime.strptime(data.start_date, "%Y-%m-%d").date()
        end_date = datetime.strptime(data.end_date, "%Y-%m-%d").date()
        
        effective_date = None
        if data.effective_date:
            effective_date = datetime.strptime(data.effective_date, "%Y-%m-%d").date()
            
        # Set up contact data
        contact = {
            "id": "12345",  # Dummy ID
            "birth_date": birth_date,
            "effective_date": effective_date,
            "state": data.state
        }
        
        # Calculate birthdays in range
        birthdays = []
        if birth_date:
            birthdays = get_all_occurrences(birth_date, start_date, end_date)
        
        # Calculate effective dates in range
        effective_dates = []
        if effective_date:
            effective_dates = get_all_occurrences(effective_date, start_date, end_date)
        
        # Get AEP dates
        aep_dates = []
        if data.state not in YEAR_ROUND_ENROLLMENT_STATES:
            for year in range(start_date.year, end_date.year + 1):
                year_aep_dates = get_aep_dates_for_year(year)
                aep_dates.extend([d for d in year_aep_dates if start_date <= d <= end_date])
        
        # Calculate rule windows
        rule_windows = calculate_rule_windows(contact, birthdays, effective_dates, start_date, end_date)
        
        # Calculate exclusion periods
        exclusion_periods = calculate_exclusion_periods(rule_windows, start_date, end_date)
        
        # Calculate post-window dates - only for states with specific rules
        post_window_dates = []
        if rule_windows and (data.state in BIRTHDAY_RULE_STATES or data.state in EFFECTIVE_DATE_RULE_STATES):
            post_window_dates = calculate_post_window_dates(rule_windows, end_date)
        
        # Schedule emails
        scheduled_emails = []
        
        # Check if this is a year-round enrollment state
        if data.state in YEAR_ROUND_ENROLLMENT_STATES:
            # No emails for year-round enrollment states
            return {
                "emails": [],
                "exclusion_periods": [
                    {"start_date": period.start.isoformat(), "end_date": period.end_date.isoformat(), 
                     "type": "Year-Round Enrollment"} 
                    for period in exclusion_periods
                ],
                "birthdays": [d.isoformat() for d in birthdays],
                "effective_dates": [d.isoformat() for d in effective_dates],
                "aep_dates": [],
                "state": data.state,
                "message": "No emails scheduled - year-round enrollment state"
            }
        
        # Birthday emails
        if birthdays:
            for birthday in birthdays:
                email_date = calculate_birthday_email_date(birthday, birthday.year)
                
                # Only include if within date range
                if start_date <= email_date <= end_date:
                    # For birthday emails, states without specific birthday rules 
                    # (not in BIRTHDAY_RULE_STATES) should always get emails
                    bypass_exclusion = data.state not in BIRTHDAY_RULE_STATES
                    
                    # States without rule windows will have empty exclusion_periods list,
                    # so is_date_excluded will return False
                    if bypass_exclusion or not is_date_excluded(email_date, exclusion_periods):
                        scheduled_emails.append({
                            "type": "birthday",
                            "date": email_date.isoformat(),
                            "reason": f"14 days before birthday ({birthday.isoformat()})"
                        })
        
        # Effective date emails
        if effective_dates:
            for eff_date in effective_dates:
                email_date = calculate_effective_date_email(eff_date, start_date)
                
                # Only include if within date range
                if start_date <= email_date <= end_date:
                    # For effective date emails, states with effective date rules (like Missouri)
                    # should always get these emails
                    bypass_exclusion = data.state in EFFECTIVE_DATE_RULE_STATES
                    
                    # States without rule windows will have empty exclusion_periods list,
                    # so is_date_excluded will return False
                    if bypass_exclusion or not is_date_excluded(email_date, exclusion_periods):
                        scheduled_emails.append({
                            "type": "effective_date",
                            "date": email_date.isoformat(),
                            "reason": f"30 days before effective date ({eff_date.isoformat()})"
                        })
        
        # AEP emails
        if aep_dates and data.state not in YEAR_ROUND_ENROLLMENT_STATES:
            # Distribute contact across AEP weeks
            contact_index = 12345 % len(aep_dates)  # Use dummy contact ID
            aep_date = aep_dates[contact_index]
            
            # States without rule windows should always get AEP emails
            # States without rule windows will have empty exclusion_periods list,
            # so is_date_excluded will return False
            if not is_date_excluded(aep_date, exclusion_periods):
                scheduled_emails.append({
                    "type": "aep",
                    "date": aep_date.isoformat(),
                    "reason": "Annual Enrollment Period email"
                })
        
        # Post-window emails
        if post_window_dates:
            # We only send one post-window email, so use the earliest one
            post_date = post_window_dates[0]
            
            # Post-window emails bypass exclusion periods
            scheduled_emails.append({
                "type": "post_window",
                "date": post_date.isoformat(),
                "reason": "Day after exclusion period"
            })
        
        # Sort emails by date
        scheduled_emails.sort(key=lambda x: x["date"])
        
        return {
            "emails": scheduled_emails,
            "exclusion_periods": [
                {"start_date": period.start.isoformat(), "end_date": period.end_date.isoformat()} 
                for period in exclusion_periods
            ],
            "birthdays": [d.isoformat() for d in birthdays],
            "effective_dates": [d.isoformat() for d in effective_dates],
            "aep_dates": [d.isoformat() for d in aep_dates],
            "state": data.state
        }
        
    except Exception as e:
        # Log the error and return an error response
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error in simulate_emails: {e}\n{error_trace}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.post("/resample/{org_id}")
async def resample_contacts(
    org_id: int, 
    sample_size: int = 10,
    state: Optional[str] = None,
    special_rules_only: bool = False,
    contact_search: Optional[str] = None
):
    """Resample contacts from existing data"""
    try:
        if org_id not in org_data_store:
            return JSONResponse(
                status_code=404,
                content={"error": "Organization data not found. Please run the initial check first."}
            )
            
        df = org_data_store[org_id]
        
        # Apply contact search if provided
        if contact_search and contact_search.strip():
            search_term = contact_search.strip()
            # Search by email (case insensitive) or by contact ID
            filtered_df = df[(df['email'].str.lower() == search_term.lower()) | 
                             (df['contact_id'].astype(str) == search_term)]
            
            if len(filtered_df) == 0:
                return JSONResponse(
                    status_code=404,
                    content={"error": f"No contact found with email or ID: {search_term}"}
                )
        else:
            # Apply state filtering
            filtered_df = df.copy()
            if special_rules_only:
                filtered_df = filtered_df[filtered_df['state'].isin(SPECIAL_RULE_STATES)]
            elif state and state.strip():  # Only filter if state is explicitly selected
                filtered_df = filtered_df[filtered_df['state'] == state]
                
            # Get unique contacts with their states
            unique_contacts = filtered_df.groupby('contact_id').first().reset_index()
            
            if len(unique_contacts) == 0:
                return JSONResponse(
                    status_code=404,
                    content={"error": "No contacts found matching the state filter criteria."}
                )
            
            # Sample contacts ensuring good state distribution
            sample_ids = sample_contacts_from_states(unique_contacts, sample_size, state if state and state.strip() else None)
            
            # Filter dataframe to only include sampled contacts
            filtered_df = filtered_df[filtered_df['contact_id'].isin(sample_ids)]
        
        # Convert DataFrame to list of dicts, handling NaN values
        sample_data = filtered_df.replace({pd.NA: None}).to_dict('records')
        
        # Group data by contact with improved organization
        contacts_data = {}
        for row in sample_data:
            contact_id = row['contact_id']
            if contact_id not in contacts_data:
                state_code = row['state']
                state_info = {
                    "code": state_code,
                    "has_birthday_rule": state_code in BIRTHDAY_RULE_STATES,
                    "has_effective_date_rule": state_code in EFFECTIVE_DATE_RULE_STATES,
                    "has_year_round_enrollment": state_code in YEAR_ROUND_ENROLLMENT_STATES,
                    "rule_details": {
                        "birthday": BIRTHDAY_RULE_STATES.get(state_code, {}),
                        "effective_date": EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                    }
                }
                
                contacts_data[contact_id] = {
                    'contact_info': {
                        'id': contact_id,
                        'name': f"{row['first_name']} {row['last_name']}",
                        'email': row['email'],
                        'state': state_code,
                        'state_info': state_info,
                        'birth_date': row['birth_date'],
                        'effective_date': row['effective_date']
                    },
                    'scheduled_emails': {
                        'birthday': [],
                        'effective_date': [],
                        'aep': [],
                        'post_window': []
                    },
                    'skipped_emails': [],
                    'scheduling_rules': []
                }
                
                # Add applicable scheduling rules based on state
                rules = []
                if state_info['has_birthday_rule']:
                    window = BIRTHDAY_RULE_STATES.get(state_code, {})
                    rules.append(f"Birthday emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after birthday")
                if state_info['has_effective_date_rule']:
                    window = EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                    rules.append(f"Effective date emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after anniversary")
                if state_info['has_year_round_enrollment']:
                    rules.append("Year-round enrollment state - no scheduled emails")
                else:
                    rules.append("AEP emails: Distributed across August/September")
                    rules.append("Post-window emails: Day after exclusion period")
                contacts_data[contact_id]['scheduling_rules'] = rules
            
            # Add email to appropriate category
            if not row['skipped']:
                email_type = row['email_type']
                email_info = {
                    'date': str(row['email_date']),
                    'link': row['link'],
                    'reason': row['reason'] if row['reason'] else None
                }
                contacts_data[contact_id]['scheduled_emails'][email_type].append(email_info)
            else:
                contacts_data[contact_id]['skipped_emails'].append({
                    'type': row['email_type'],
                    'reason': row['reason']
                })
            
        return {
            "contacts": contacts_data,
            "total_contacts": len(df.groupby('contact_id')),
            "sample_size": len(contacts_data),
            "contact_search": contact_search if contact_search else ""
        }
        
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.post("/check", response_class=HTMLResponse)
async def check_schedules(
    request: Request,
    org_id: int = Form(...),
    sample_size: int = Form(10),
    state: Optional[str] = Form(default=None),
    special_rules_only: bool = Form(default=False),
    contact_search: Optional[str] = Form(default=None)
):
    """Process organization's contacts and display sample results"""
    try:
        # Set up paths
        main_db = "main.db"
        org_db_dir = "org_dbs"

        # Set date range
        current_date = date.today()
        end_date = date(current_date.year + 2, current_date.month, current_date.day)

        await refresh_databases(org_id)
        
        # Get organization details
        try:
            org = get_organization_details(main_db, org_id)
        except Exception as e:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to get organization details: {str(e)}"
                }
            )
        
        # Get contacts from organization database
        try:
            org_db_path = os.path.join(org_db_dir, f"org-{org_id}.db")
            contacts = get_contacts_from_org_db(org_db_path, org_id)
        except Exception as e:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to get contacts from database: {str(e)}"
                }
            )
        
        # Format contact data
        try:
            formatted_contacts = format_contact_data(contacts)
        except Exception as e:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to format contact data: {str(e)}\nLocation: format_contact_data"
                }
            )
        
        if not formatted_contacts:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": "No valid contacts found for scheduling"
                }
            )
        
        # Process contacts
        try:
            results = await process_contacts_async(formatted_contacts, current_date, end_date)
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to process contacts: {str(e)}\nTrace:\n{error_trace}"
                }
            )
        
        # Create a temporary CSV file
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv') as tmp:
                # Write results to CSV
                write_results_to_csv(results, formatted_contacts, org_id, tmp.name)
                
                # Read the CSV with pandas
                df = pd.read_csv(tmp.name)
                
                # Store the DataFrame in memory
                org_data_store[org_id] = df
        except Exception as e:
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to create CSV file: {str(e)}"
                }
            )
            
        # Clean up temp file
        os.unlink(tmp.name)
        
        # Apply contact search if provided
        try:
            if contact_search and contact_search.strip():
                search_term = contact_search.strip()
                # Search by email (case insensitive) or by contact ID
                filtered_df = df[(df['email'].str.lower() == search_term.lower()) | 
                                 (df['contact_id'].astype(str) == search_term)]
                
                if len(filtered_df) == 0:
                    return templates.TemplateResponse(
                        "error.html",
                        {
                            "request": request,
                            "error": f"No contact found with email or ID: {search_term}"
                        }
                    )
            else:
                # Apply state filtering
                filtered_df = df.copy()
                if special_rules_only:
                    filtered_df = filtered_df[filtered_df['state'].isin(SPECIAL_RULE_STATES)]
                elif state and state.strip():  # Only filter if state is explicitly selected
                    filtered_df = filtered_df[filtered_df['state'] == state]
                    
                # Get unique contacts with their states
                unique_contacts = filtered_df.groupby('contact_id').first().reset_index()
                
                if len(unique_contacts) == 0:
                    return templates.TemplateResponse(
                        "error.html",
                        {
                            "request": request,
                            "error": "No contacts found matching the state filter criteria."
                        }
                    )
                
                # Sample contacts ensuring good state distribution
                sample_ids = sample_contacts_from_states(unique_contacts, sample_size, state if state and state.strip() else None)
                
                # Filter dataframe to only include sampled contacts
                filtered_df = filtered_df[filtered_df['contact_id'].isin(sample_ids)]
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed during contact filtering/sampling: {str(e)}\nTrace:\n{error_trace}"
                }
            )
        
        # Convert DataFrame to list of dicts for template
        try:
            sample_data = filtered_df.to_dict('records')
            
            # Group data by contact with improved organization
            contacts_data = {}
            for row in sample_data:
                contact_id = row['contact_id']
                if contact_id not in contacts_data:
                    state_code = row['state']
                    state_info = {
                        "code": state_code,
                        "has_birthday_rule": state_code in BIRTHDAY_RULE_STATES,
                        "has_effective_date_rule": state_code in EFFECTIVE_DATE_RULE_STATES,
                        "has_year_round_enrollment": state_code in YEAR_ROUND_ENROLLMENT_STATES,
                        "rule_details": {
                            "birthday": BIRTHDAY_RULE_STATES.get(state_code, {}),
                            "effective_date": EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                        }
                    }
                    
                    # Get birth_date and effective_date
                    birth_date = row.get('birth_date')
                    effective_date = row.get('effective_date')
                    
                    # Calculate birthdays and effective dates in range
                    birthdays = []
                    effective_dates = []
                    if birth_date:
                        birthdays = get_all_occurrences(pd.to_datetime(birth_date).date(), current_date, end_date)
                    if effective_date:
                        effective_dates = get_all_occurrences(pd.to_datetime(effective_date).date(), current_date, end_date)
                    
                    # Initialize timeline data for each category
                    contacts_data[contact_id] = {
                        'contact_info': {
                            'id': contact_id,
                            'name': f"{row['first_name']} {row['last_name']}",
                            'email': row['email'],
                            'state': state_code,
                            'state_info': state_info,
                            'birth_date': birth_date,
                            'effective_date': effective_date
                        },
                        'scheduled_emails': {
                            'birthday': [],
                            'effective_date': [],
                            'aep': [],
                            'post_window': []
                        },
                        'skipped_emails': [],
                        'scheduling_rules': [],
                        'timeline_exclusions': [],
                        'timeline_birthdays': [],
                        'timeline_effective_dates': [],
                        'timeline_scheduled': [],
                        'timeline_skipped': []
                    }

                    # Add applicable scheduling rules based on state
                    rules = []
                    if state_info['has_birthday_rule']:
                        window = BIRTHDAY_RULE_STATES.get(state_code, {})
                        rules.append(f"Birthday emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after birthday")
                    if state_info['has_effective_date_rule']:
                        window = EFFECTIVE_DATE_RULE_STATES.get(state_code, {})
                        rules.append(f"Effective date emails: {window.get('window_before', 0)} days before to {window.get('window_after', 0)} days after anniversary")
                    if state_info['has_year_round_enrollment']:
                        rules.append("Year-round enrollment state - no scheduled emails")
                    else:
                        rules.append("AEP emails: Distributed across August/September")
                        rules.append("Post-window emails: Day after exclusion period")
                    contacts_data[contact_id]['scheduling_rules'] = rules

                    # Add birthdays to timeline
                    for birthday in birthdays:
                        contacts_data[contact_id]['timeline_birthdays'].append({
                            "start": birthday.isoformat(),
                            "type": "point",
                            "className": "date-birthday",
                            "content": "Birthday",
                            "tooltip": f"Birthday: {birthday.strftime('%B %d, %Y')}"
                        })

                    # Add effective dates to timeline
                    for eff_date in effective_dates:
                        contacts_data[contact_id]['timeline_effective_dates'].append({
                            "start": eff_date.isoformat(),
                            "type": "point",
                            "className": "date-effective",
                            "content": "Effective Date",
                            "tooltip": f"Effective Date: {eff_date.strftime('%B %d, %Y')}"
                        })

                    # Add exclusion periods if not a year-round enrollment state
                    if not state_info['has_year_round_enrollment']:
                        # Calculate rule windows and exclusion periods
                        contact_data = {
                            'id': contact_id,
                            'birth_date': pd.to_datetime(birth_date).date() if birth_date else None,
                            'effective_date': pd.to_datetime(effective_date).date() if effective_date else None,
                            'state': state_code
                        }

                        # Calculate rule windows and exclusion periods
                        rule_windows = calculate_rule_windows(contact_data, birthdays, effective_dates, current_date, end_date)
                        exclusion_periods = calculate_exclusion_periods(rule_windows, current_date, end_date)

                        # Add exclusion periods to timeline
                        for period in exclusion_periods:
                            contacts_data[contact_id]['timeline_exclusions'].append({
                                "start": period.start.isoformat(),
                                "end": period.end_date.isoformat(),
                                "type": "range",
                                "className": "exclusion",
                                "content": "Exclusion Period",
                                "tooltip": f"Exclusion Period: {period.start.strftime('%B %d, %Y')} to {period.end_date.strftime('%B %d, %Y')}"
                            })

                    # Add email to appropriate category and timeline
                    email_info = {
                        'type': row['email_type'],
                        'date': str(row['email_date']),
                        'link': row['link'],
                        'skipped': row['skipped'],
                        'reason': row['reason']
                    }

                    # Add to timeline based on whether it was skipped
                    if row['skipped'] != 'Yes':
                        # Add to scheduled emails list
                        email_type = row['email_type'].lower()
                        if email_type in contacts_data[contact_id]['scheduled_emails']:
                            contacts_data[contact_id]['scheduled_emails'][email_type].append({
                                'date': str(row['email_date']),
                                'link': row['link'],
                                'reason': row['reason']
                            })

                        # Add to scheduled emails timeline
                        timeline_item = {
                            "start": str(row['email_date']),
                            "type": "point",
                            "className": f"email-{row['email_type'].lower().replace('_', '-')}",
                            "content": f"{row['email_type'].replace('_', ' ').title()} Email"
                        }

                        # Add tooltip for post-window emails
                        if row['email_type'] == 'post_window':
                            # Find the most recent exclusion period that ended before this email
                            for period in contacts_data[contact_id]['timeline_exclusions']:
                                if period['end'] < str(row['email_date']):
                                    timeline_item["tooltip"] = f"Post-Window Email: Scheduled after exclusion period ({period['start']} to {period['end']})"
                                    break
                        else:
                            timeline_item["tooltip"] = f"{row['email_type'].replace('_', ' ').title()} Email: {row['email_date']}"

                        contacts_data[contact_id]['timeline_scheduled'].append(timeline_item)
                    else:
                        # Add to skipped emails list
                        contacts_data[contact_id]['skipped_emails'].append({
                            'type': row['email_type'],
                            'reason': row['reason']
                        })

                        # Add to skipped emails timeline
                        contacts_data[contact_id]['timeline_skipped'].append({
                            "start": str(row['email_date']),
                            "type": "point",
                            "className": "email-skipped",
                            "content": f"{row['email_type'].replace('_', ' ').title()} Email (Skipped)",
                            "tooltip": f"Skipped {row['email_type'].replace('_', ' ').title()} Email: {row['reason']}"
                        })
                
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            return templates.TemplateResponse(
                "error.html",
                {
                    "request": request,
                    "error": f"Failed to prepare contact data for display: {str(e)}\nTrace:\n{error_trace}"
                }
            )
        
        return templates.TemplateResponse(
            "results.html",
            {
                "request": request,
                "org_name": org['name'],
                "org_id": org_id,
                "contacts": contacts_data,
                "total_contacts": len(df.groupby('contact_id')),
                "sample_size": len(contacts_data),
                "sample_sizes": [5, 10, 25, 50, 100],
                "selected_state": state if state and state.strip() else None,
                "special_rules_only": special_rules_only,
                "all_states": ALL_STATES,
                "special_rule_states": SPECIAL_RULE_STATES,
                "contact_search": contact_search if contact_search else "",
                "current_date": current_date.isoformat(),
                "end_date": end_date.isoformat()
            }
        )
        
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        return templates.TemplateResponse(
            "error.html",
            {
                "request": request,
                "error": f"Unexpected error: {str(e)}\nTrace:\n{error_trace}"
            }
        )

if __name__ == "__main__":
    import uvicorn
    import argparse
    
    parser = argparse.ArgumentParser(description="Email Scheduler App")
    parser.add_argument("--port", type=int, default=8000, help="Port to run the server on")
    args = parser.parse_args()
    
    uvicorn.run(app, host="0.0.0.0", port=args.port)

================
File: contact_rule_engine.py
================
import yaml
from datetime import date, datetime
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger(__name__)

class ContactRuleEngine:
    def __init__(self, config_file: str = 'contact_rules_config.yaml'):
        """Initialize the rule engine with configuration"""
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)
        self.contact_rules = self.config.get('contact_rules', {})
        self.global_rules = self.config.get('global_rules', {})
        self.state_rules = self.config.get('state_rules', {})
        self.timing_constants = self.config.get('timing_constants', {})
        self.aep_config = self.config.get('aep_config', {})

    def get_contact_rules(self, contact_id: str) -> Dict[str, Any]:
        """Get specific rules for a contact, falling back to global rules"""
        return self.contact_rules.get(str(contact_id), {})

    def get_state_rules(self, state: str) -> Dict[str, Any]:
        """Get rules for a specific state"""
        return self.state_rules.get(state, {})

    def get_timing_constant(self, name: str, default: int) -> int:
        """Get a timing constant from config, falling back to default"""
        return self.timing_constants.get(name, default)

    def get_aep_dates(self, year: int) -> List[date]:
        """Get AEP dates for a specific year"""
        if year not in self.aep_config.get('years', []):
            return []
        
        dates = []
        for date_config in self.aep_config.get('default_dates', []):
            dates.append(date(year, date_config['month'], date_config['day']))
        return dates

    def should_force_aep_email(self, contact: Dict[str, Any]) -> bool:
        """Determine if AEP email should be forced for a contact"""
        contact_rules = self.get_contact_rules(contact['id'])
        return contact_rules.get('force_aep', False)

    def get_aep_date_override(self, contact: Dict[str, Any], current_date: date) -> Optional[date]:
        """Get AEP date override if applicable"""
        contact_rules = self.get_contact_rules(contact['id'])
        
        # Check contact-specific override
        override = contact_rules.get('aep_date_override')
        if override:
            return date(current_date.year, override['month'], override['day'])

        # Check October birthday global rule
        if contact.get('birth_date'):
            birth_date = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
            if birth_date.month == 10:
                october_rule = self.global_rules.get('october_birthday_aep')
                if october_rule:
                    return date(current_date.year, october_rule['month'], october_rule['day'])
        
        return None

    def get_post_window_dates(self, contact: Dict[str, Any], current_date: date) -> List[date]:
        """Calculate post-window dates based on rules"""
        dates = []
        contact_rules = self.get_contact_rules(contact['id'])
        
        if not contact.get('birth_date'):
            return dates

        birth_date = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
        state = contact.get('state')
        state_rules = self.get_state_rules(state)

        # Apply contact-specific post window rules
        for rule in contact_rules.get('post_window_rules', []):
            condition = rule.get('condition', {})
            if (condition.get('birth_month') == birth_date.month and
                state in condition.get('states', [])):
                override = rule.get('override_date')
                if override:
                    dates.append(date(current_date.year, override['month'], override['day']))

        # Apply state-specific rules
        if state_rules:
            # Handle leap year special case
            if birth_date.month == 2 and birth_date.day == 29:
                state_specific = self.global_rules.get('state_specific_rules', {}).get(state, {})
                leap_year_override = state_specific.get('leap_year_override')
                if leap_year_override:
                    dates.append(date(current_date.year, leap_year_override['month'], leap_year_override['day']))

        return dates

    def get_state_window_period(self, state: str) -> Dict[str, int]:
        """Get window period configuration for a state"""
        state_rules = self.get_state_rules(state)
        return {
            'window_before': state_rules.get('window_before', 0),
            'window_after': state_rules.get('window_after', 0)
        }

    def is_year_round_enrollment_state(self, state: str) -> bool:
        """Check if a state has year-round enrollment"""
        state_rules = self.get_state_rules(state)
        return state_rules.get('type') == 'year_round'

    def get_special_state_rules(self, state: str) -> Dict[str, Any]:
        """Get special rules for a state"""
        state_rules = self.get_state_rules(state)
        return state_rules.get('special_rules', {})

================
File: email_scheduler_common.py
================
"""
Common functions and logic for both synchronous and asynchronous email schedulers.
This file contains shared code that ensures consistent behavior across both implementations.
"""

from datetime import date, datetime, timedelta
import logging
from typing import Dict, List, Set, Tuple, Optional, Union, Any

# Configure logging
import os

# Get log file path from environment variable with default
LOG_FILE = os.environ.get('LOG_FILE', 'logs/email_scheduler.log')

# Check if console output is enabled (default: False in production, True in development)
CONSOLE_OUTPUT = os.environ.get('CONSOLE_OUTPUT', '').lower() in ('true', '1', 'yes', 'y', 't')

# Create logger
logger = logging.getLogger("email_scheduler")
logger.setLevel(logging.INFO)

# Remove any existing handlers to avoid duplicates when module is reloaded
if logger.hasHandlers():
    logger.handlers.clear()

# Create formatter
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

# Create file handler
try:
    # Ensure the directory exists
    log_dir = os.path.dirname(LOG_FILE)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir, exist_ok=True)
        
    file_handler = logging.FileHandler(LOG_FILE, mode='a')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
except Exception as e:
    print(f"Warning: Could not set up log file at {LOG_FILE}: {e}")
    print(f"Using fallback log file: email_scheduler.log")
    # Fallback to local log file
    fallback_handler = logging.FileHandler('email_scheduler.log', mode='a')
    fallback_handler.setFormatter(formatter)
    logger.addHandler(fallback_handler)

# Add console handler if enabled
if CONSOLE_OUTPUT:
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

# Email type constants
EMAIL_TYPE_BIRTHDAY = "birthday"
EMAIL_TYPE_EFFECTIVE_DATE = "effective_date"
EMAIL_TYPE_AEP = "aep"
EMAIL_TYPE_POST_WINDOW = "post_window"

# Configurable exclusion window (days before rule window)
PRE_WINDOW_EXCLUSION_DAYS = 60

# Define special rule states and window durations
BIRTHDAY_RULE_STATES = {
    "CA": {"window_before": 30, "window_after": 30},  # 60-day period starting 30 days before birthday
    "ID": {"window_before": 0, "window_after": 63},   # 63-day period starting on birthday
    "IL": {"window_before": 0, "window_after": 45},   # 45-day period starting on birthday
    "KY": {"window_before": 0, "window_after": 60},   # 60-day period following birthday
    "LA": {"window_before": 30, "window_after": 63},  # 93-day period starting 30 days before birthday
    "MD": {"window_before": 0, "window_after": 31},   # 31-day period starting on birthday
    "NV": {"window_before": 0, "window_after": 60},   # 60-day period starting first day of birth month
    "OK": {"window_before": 0, "window_after": 60},   # 60-day period starting on birthday
    "OR": {"window_before": 0, "window_after": 31}    # 31-day period starting on birthday
}

EFFECTIVE_DATE_RULE_STATES = {
    "MO": {"window_before": 30, "window_after": 33}   # 63-day period starting 30 days before anniversary
}

# Year-round enrollment states (no scheduled emails)
YEAR_ROUND_ENROLLMENT_STATES = {"CT", "MA", "NY", "WA"}

# Pre-calculated AEP weeks for each year
AEP_WEEKS = {
    2023: ['2023-08-18', '2023-08-25', '2023-09-01', '2023-09-07'],
    2024: ['2024-08-18', '2024-08-25', '2024-09-01', '2024-09-07'],
    2025: ['2025-08-18', '2025-08-25', '2025-09-01', '2025-09-07'],
    2026: ['2026-08-18', '2026-08-25', '2026-09-01', '2026-09-07'],
    2027: ['2027-08-18', '2027-08-25', '2027-09-01', '2027-09-07'],
}

# Logging utility function
def log(message, always=False, debug=False):
    """
    Utility function for conditional logging
    - always: Always log at INFO level
    - debug: Log at DEBUG level (only shown when DEBUG=True)
    - Otherwise: Log at INFO level when VERBOSE=True
    """
    if debug:
        logger.debug(message)
    elif always:
        logger.info(message)
    else:
        logger.debug(message)  # Use debug by default for verbose logs

# Check if a year is a leap year
def is_leap_year(year):
    """Returns True if the given year is a leap year, False otherwise"""
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    return year % 4 == 0

# Helper function to safely create a date
def try_create_date(year, month, day):
    """
    Attempts to create a date, handling leap year dates consistently
    For February 29 in non-leap years, uses February 28 instead
    """
    try:
        return date(year, month, day)
    except ValueError:
        # Handle February 29 in non-leap years
        if month == 2 and day == 29:
            return date(year, 2, 28)  # Use February 28 in non-leap years
        return None

# Helper function to check if a date is the last day of the month
def is_month_end(date_obj):
    """Check if a date is the last day of its month, handling leap years"""
    # Get the first day of the next month
    if date_obj.month == 12:
        next_month = date(date_obj.year + 1, 1, 1)
    else:
        next_month = date(date_obj.year, date_obj.month + 1, 1)
    
    # If the date is the day before the first of next month, it's the last day
    return (next_month - timedelta(days=1)) == date_obj

# Helper function to get all occurrences of a date (birthdays, etc.) in a date range
def get_all_occurrences(event_day, start, end_date):
    """Get all occurrences of a date (e.g. birthdays) in the given range"""
    dates = []
    # Also check the year before start if it might result in valid email dates
    for yr in range(start.year - 1, end_date.year + 1):
        date_obj = try_create_date(yr, event_day.month, event_day.day)
        if date_obj:  # Don't filter by date range here, let the caller handle that
            dates.append(date_obj)
    return sorted(dates)  # Return dates in chronological order

# Function to calculate rule windows based on state-specific rules
def calculate_rule_windows(contact, birthdays, effective_dates, current_date, end_date):
    """
    Calculate rule windows for a contact based on their state and dates
    
    Args:
        contact: Contact dictionary with state and dates
        birthdays: List of birthday dates (can be empty if calculating from contact)
        effective_dates: List of effective dates (can be empty if calculating from contact)
        current_date: Current date to start calculations from
        end_date: End date to stop calculations at
        
    Returns:
        List of tuples (window_start, window_end, rule_type, state)
    """
    rule_windows = []
    state = contact.get('state', 'CA')  # Default to CA if no state
    
    # Skip for year-round enrollment states
    if state in YEAR_ROUND_ENROLLMENT_STATES:
        logger.debug(f"Contact {contact['id']} is in year-round enrollment state {state}, no rule windows apply")
        return []
    
    # If no birthdays provided, calculate from contact birth_date
    if not birthdays and contact.get('birth_date'):
        try:
            # Handle both date objects and strings
            if isinstance(contact['birth_date'], date):
                original_birthday = contact['birth_date']
            elif isinstance(contact['birth_date'], str):
                # Try multiple date formats
                for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%m/%d/%Y", "%m-%d-%Y"]:
                    try:
                        original_birthday = datetime.strptime(contact['birth_date'], fmt).date()
                        break
                    except ValueError:
                        continue
                else:  # No format worked
                    original_birthday = None
            else:
                original_birthday = None
                
            if original_birthday:
                # Calculate birthdays in range
                if (original_birthday.month > current_date.month or 
                    (original_birthday.month == current_date.month and 
                     original_birthday.day >= current_date.day)):
                    birthdays.append(date(current_date.year, original_birthday.month, original_birthday.day))
                
                for yr in range(current_date.year + 1, end_date.year + 1):
                    if original_birthday.month == 2 and original_birthday.day == 29 and not is_leap_year(yr):
                        birthdays.append(date(yr, 2, 28))
                    else:
                        birthdays.append(date(yr, original_birthday.month, original_birthday.day))
        except Exception as e:
            logger.warning(f"Error processing birth date for contact: {e}")
    
    # If no effective dates provided, calculate from contact effective_date
    if not effective_dates and contact.get('effective_date'):
        try:
            # Handle both date objects and strings
            if isinstance(contact['effective_date'], date):
                original_effective_date = contact['effective_date']
            elif isinstance(contact['effective_date'], str):
                # Try multiple date formats
                for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%m/%d/%Y", "%m-%d-%Y"]:
                    try:
                        original_effective_date = datetime.strptime(contact['effective_date'], fmt).date()
                        break
                    except ValueError:
                        continue
                else:  # No format worked
                    original_effective_date = None
            else:
                original_effective_date = None
                
            if original_effective_date:
                # Calculate effective dates in range
                for yr in range(current_date.year, end_date.year + 1):
                    effective_dates.append(date(yr, original_effective_date.month, original_effective_date.day))
        except Exception as e:
            logger.warning(f"Error processing effective date for contact: {e}")
    
    # Process birthday rule states
    if state in BIRTHDAY_RULE_STATES and birthdays:
        window_before = BIRTHDAY_RULE_STATES[state]["window_before"]
        window_after = BIRTHDAY_RULE_STATES[state]["window_after"]
        
        for birthday in birthdays:
            # Special handling for Nevada (first day of birth month)
            if state == "NV":
                birthday = date(birthday.year, birthday.month, 1)
            
            # Calculate rule window
            rule_window_start = birthday - timedelta(days=window_before)
            rule_window_end = birthday + timedelta(days=window_after)
            
            # Only consider windows that overlap with our target date range
            if rule_window_start <= end_date and rule_window_end >= current_date:
                logger.debug(f"Birthday rule window for {state} contact: {rule_window_start} to {rule_window_end}")
                rule_windows.append((rule_window_start, rule_window_end, "birthday", state))
    
    # Process effective date rule states
    if state in EFFECTIVE_DATE_RULE_STATES and effective_dates:
        window_before = EFFECTIVE_DATE_RULE_STATES[state]["window_before"]
        window_after = EFFECTIVE_DATE_RULE_STATES[state]["window_after"]
        
        for eff_date in effective_dates:
            # Calculate rule window
            rule_window_start = eff_date - timedelta(days=window_before)
            rule_window_end = eff_date + timedelta(days=window_after)
            
            # Only consider windows that overlap with our target date range
            if rule_window_start <= end_date and rule_window_end >= current_date:
                logger.debug(f"Effective date rule window for {state} contact: {rule_window_start} to {rule_window_end}")
                rule_windows.append((rule_window_start, rule_window_end, "effective_date", state))
    
    # For states without specific rules, return an empty list (no rule windows)
    # This is a key change - no default 60-day window for states without specific rules
    if not rule_windows and state not in YEAR_ROUND_ENROLLMENT_STATES:
        logger.debug(f"Contact {contact['id']} is in state {state} with no specific rule windows defined")
        return []  # Return empty list for states like Kansas with no specific rules
    
    return rule_windows

# Class to represent a date range for exclusion periods
class DateRange:
    def __init__(self, start_date, end_date):
        self.start = start_date
        self.end_date = end_date

# Helper function to safely create a DateRange
def create_daterange(start, end_date):
    if start > end_date:
        return None
    return DateRange(start, end_date)

# Function to calculate exclusion periods
def calculate_exclusion_periods(rule_windows, current_date, end_date):
    """
    Calculate exclusion periods from rule windows
    Returns: List of DateRange objects representing exclusion periods
    """
    exclusions = []
    
    for rule_window_start, rule_window_end, rule_type, state in rule_windows:
        # Calculate extended exclusion (PRE_WINDOW_EXCLUSION_DAYS before window to window end)
        exclusion_start = rule_window_start - timedelta(days=PRE_WINDOW_EXCLUSION_DAYS)
        exclusion_end = rule_window_end
        
        # Log for debugging
        logger.debug(f"For {rule_type} rule window [{rule_window_start} to {rule_window_end}], exclusion period: {exclusion_start} to {exclusion_end}")
        
        # Bound the exclusion by the current date and end date
        bounded_start = max(exclusion_start, current_date - timedelta(days=PRE_WINDOW_EXCLUSION_DAYS))
        bounded_end = min(exclusion_end, end_date)
        
        # Create a DateRange object if we have a valid range
        if bounded_start <= bounded_end:
            exclusion = DateRange(bounded_start, bounded_end)
            exclusions.append(exclusion)
    
    # Sort exclusions by start date
    exclusions.sort(key=lambda x: x.start)
    return exclusions

# Function to calculate post-window dates
def calculate_post_window_dates(rule_windows, end_date):
    """
    Calculate post-window dates based on rule windows
    Returns: List of dates representing post-window dates
    """
    post_window_dates = []
    
    # Log the number of rule windows we're processing
    logger.debug(f"Processing {len(rule_windows)} rule window(s) for post-window dates")
    
    if not rule_windows:
        logger.debug("No rule windows found, cannot calculate post-window dates")
        return post_window_dates
    
    for rule_window_start, rule_window_end, rule_type, state in rule_windows:
        # Skip if this is not a birthday rule
        if rule_type != "birthday":
            logger.debug(f"Skipping {rule_type} rule window for post-window calculation")
            continue
            
        # Default: post-window date is the day after the rule window ends
        post_window_date = rule_window_end + timedelta(days=1)
        
        # Log the rule window we're processing
        logger.debug(f"Calculating post-window date for {state} {rule_type} rule window: {rule_window_start} to {rule_window_end}")
        
        # General rule for NV state (first-of-month rule state)
        # If the rule window starts on the first day of a month AND
        # the rule window end date is the last day of its month,
        # use the end date as the post-window date
        if state == "NV" and rule_window_start.day == 1 and is_month_end(rule_window_end):
            post_window_date = rule_window_end
            logger.debug(f"Nevada-style rule detected: Using end date {post_window_date} instead")
        
        # Logic for February birthdays across all states
        if rule_window_start.month == 2:
            # Special handling for February 29 birthdays (leap year birthdays)
            if rule_window_start.day == 29:
                # For CA contacts with Feb 29 birthday: post-window on March 30
                if state == 'CA':
                    post_window_date = date(rule_window_end.year, 3, 30)
                    logger.debug(f"Special case: Feb 29 CA birthday, post-window date: {post_window_date}")
                
                # For NV contacts with Feb 29 birthday: post-window on March 31
                elif state == 'NV':
                    # Always use March 31 for NV contacts with Feb 29 birthday
                    post_window_date = date(rule_window_end.year, 3, 31)
                    logger.debug(f"Special case: Feb 29 NV birthday, post-window date: {post_window_date}")
            # Handle other February birthdays
            elif rule_window_end.month == 3 and (rule_window_end.day == 29 or rule_window_end.day == 30):
                if state == 'CA' and rule_window_start.day < 15 and rule_window_start.day != 1:  # Before mid-month, not 1st
                    # Set to end of March
                    if rule_window_end.day == 29:
                        post_window_date = date(rule_window_end.year, 3, 30)
                        logger.debug(f"Special case: Early Feb CA birthday, post-window date: {post_window_date}")
                    elif rule_window_end.day == 30:
                        post_window_date = date(rule_window_end.year, 3, 31)
                        logger.debug(f"Special case: Early Feb CA birthday, post-window date: {post_window_date}")
        
        # Make sure the post window date falls within the next year
        # This is to handle cases where the rule window crosses year boundary
        if post_window_date.year < rule_window_end.year:
            post_window_date = date(rule_window_end.year, post_window_date.month, post_window_date.day)
            logger.debug(f"Adjusted post-window date to be in same year as rule end: {post_window_date}")
        
        # Only include dates that fall before our end date
        if post_window_date <= end_date:
            logger.debug(f"For {rule_type} rule window [{rule_window_start} to {rule_window_end}], post-window date: {post_window_date}")
            post_window_dates.append(post_window_date)
        else:
            logger.debug(f"Post-window date {post_window_date} is beyond our end date {end_date}, skipping")
    
    # Sort post-window dates chronologically
    post_window_dates.sort()
    logger.debug(f"Calculated {len(post_window_dates)} post-window date(s): {', '.join(str(d) for d in post_window_dates)}")
    
    return post_window_dates

# Calculate birthday email date, including special handling for February 29
def calculate_birthday_email_date(birthday_date, email_year):
    """
    Calculate the date to send a birthday email based on the recipient's birthday
    
    Args:
        birthday_date: The contact's birthday
        email_year: The year in which to send the email
        
    Returns:
        The date on which to send the birthday email
    """
    # Extract month and day from birthday
    month = birthday_date.month
    day = birthday_date.day
    
    # Special handling for February 29 birthdays
    if month == 2 and day == 29:
        # For February 29 birthdays, always send email on February 14
        # regardless of whether it's a leap year or not
        return date(email_year, 2, 14)
    
    # For all other birthdays, create the birthday in the email year
    email_year_birthday = try_create_date(email_year, month, day)
    
    # Send the email 14 days before the birthday
    return email_year_birthday - timedelta(days=14)

# Calculate the effective date email date 
def calculate_effective_date_email(effective_date, current_date):
    """
    Calculate when to send an effective date email, handling special cases
    
    Args:
        effective_date: The policy effective date
        current_date: The current date (to handle boundary cases)
        
    Returns:
        The date on which to send the effective date email
    """
    # Standard rule: Send email 30 days before effective date
    email_date = effective_date - timedelta(days=30)
    
    # Special handling for January effective dates where email
    # falls in previous year December
    if effective_date.month == 1 and effective_date.day <= 30:
        # For effective dates in early January, emails would
        # land in December of previous year
        prev_year = effective_date.year - 1
        
        # For January 1 effective dates, send email on December 2 of previous year
        if effective_date.day == 1:
            return date(prev_year, 12, 2)
        
        # For other early January dates, calculate based on the 30-day rule
        # Note: February 15 effective date would result in January 16 email date (30 days prior)
        return email_date
    
    return email_date

# Function to get precomputed AEP dates
def precompute_aep_dates(current_date, end_date):
    """Return precomputed AEP dates for a range of years"""
    aep_dates_by_year = {}
    
    for year in range(current_date.year, end_date.year + 1):
        aep_dates_by_year[year] = get_aep_dates_for_year(year)
    
    return aep_dates_by_year

def get_aep_dates_for_year(year):
    """Get the standard AEP email dates for a given year"""
    return [
        date(year, 8, 18),  # Week 1
        date(year, 8, 25),  # Week 2
        date(year, 9, 1),   # Week 3
        date(year, 9, 7)    # Week 4
    ]

# For backwards compatibility with existing code
def get_aep_dates(year):
    """Get the standard AEP email dates for a given year (alias for get_aep_dates_for_year)"""
    return get_aep_dates_for_year(year)

def find_valid_aep_date(contact, exclusion_periods, aep_dates, current_date, end_date):
    """Find a valid AEP date that doesn't fall in any exclusion period"""
    
    original_birthday = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
    
    # Start with assigned week based on standard distribution
    contact_index = int(contact['id']) % len(aep_dates)
    assigned_date = aep_dates[contact_index]
    
    # For October birthdays, prioritize earlier dates to avoid exclusion windows
    if original_birthday.month == 10:
        # Try each AEP date in order (earliest first)
        for aep_date in sorted(aep_dates):
            # Skip dates outside our date range
            if not (current_date <= aep_date <= end_date):
                continue
                
            # Check if date is excluded
            excluded = False
            for exclusion in exclusion_periods:
                if exclusion.start <= aep_date <= exclusion.end_date:
                    excluded = True
                    break
                    
            # If not excluded, use this date
            if not excluded:
                return aep_date
    else:
        # For non-October birthdays, try assigned date first, then others
        dates_to_try = [assigned_date] + [d for d in aep_dates if d != assigned_date]
        
        for aep_date in dates_to_try:
            # Skip dates outside our date range
            if not (current_date <= aep_date <= end_date):
                continue
                
            # Check if date is excluded
            excluded = False
            for exclusion in exclusion_periods:
                if exclusion.start <= aep_date <= exclusion.end_date:
                    excluded = True
                    break
                    
            # If not excluded, use this date
            if not excluded:
                return aep_date
    
    # If we couldn't find a valid date, default to the assigned date
    # (even if it falls in an exclusion period)
    if current_date <= assigned_date <= end_date:
        return assigned_date
        
    # Last resort: return the earliest AEP date in our range
    for aep_date in sorted(aep_dates):
        if current_date <= aep_date <= end_date:
            return aep_date
            
    # If no valid dates at all, return None
    return None

from contact_rule_engine import ContactRuleEngine

# Initialize rule engine at module level
rule_engine = ContactRuleEngine()

def handle_special_post_window_cases(contact, current_date, end_date):
    """
    Returns a list of special post-window dates if applicable, or an empty list.
    
    Args:
        contact: The contact dictionary
        current_date: Current scheduling date
        end_date: End date for scheduling window
        
    Returns:
        List of post-window dates for special cases
    """
    try:
        return rule_engine.get_post_window_dates(contact, current_date)
    except Exception as e:
        logger.error(f"Error in handle_special_post_window_cases for contact {contact['id']}: {e}")
        return []

def handle_october_birthday_aep(contact, current_date):
    """
    Handle special AEP scheduling for October birthdays.
    Uses rule engine to determine appropriate AEP date.
    
    Args:
        contact: The contact dictionary
        current_date: Current scheduling date
        
    Returns:
        An AEP date if applicable, or None
    """
    try:
        return rule_engine.get_aep_date_override(contact, current_date)
    except Exception as e:
        logger.error(f"Error in handle_october_birthday_aep for contact {contact['id']}: {e}")
        return None

# Function to check if an email date is in an exclusion period
def is_date_excluded(date_obj, exclusions):
    """
    Check if a given date is within any exclusion period.
    
    Args:
        date_obj: The date to check
        exclusions: List of exclusion periods (DateRange objects)
        
    Returns:
        Boolean indicating if the date is excluded
    """
    # If exclusions list is empty (which will happen for states without rule windows like Kansas),
    # always return False - no exclusions apply
    if not exclusions:
        return False
        
    for exclusion in exclusions:
        if exclusion.start <= date_obj <= exclusion.end_date:
            return True
    return False

def should_force_aep_email(contact):
    """
    Determines if a contact should have an AEP email regardless of exclusion rules.
    
    Args:
        contact: The contact dictionary
        
    Returns:
        Boolean indicating if AEP email should be forced
    """
    return rule_engine.should_force_aep_email(contact)

# Function to schedule an email and track it in the context
def add_email_to_context(ctx, email_type, email_date, reason=None):
    """
    Add an email to the scheduling context.
    
    Args:
        ctx: The scheduling context
        email_type: Type of email (birthday, effective_date, aep, post_window)
        email_date: Date for the email
        reason: Optional reason for the email
        
    Returns:
        The email object that was added
    """
    # Create the email object
    email = {"type": email_type, "date": email_date.isoformat()}
    if reason:
        email["reason"] = reason
        
    # Add to scheduled emails list
    ctx.emails.append(email)
    
    # Add to scheduled dates list for exclusion checking
    ctx.scheduled_dates.append(email_date)
    
    return email

================
File: email_scheduler_optimized.py
================
"""
Email Scheduler Optimized - Performance-focused implementation.

This module provides a high-performance implementation of the email scheduling logic
using the declarative rules defined in email_rules_engine.py.

Usage:
    To run with UV (recommended):
        uv run python email_scheduler_optimized.py --input <input_file> --output <output_file> [options]
    
    Standard execution:
        python email_scheduler_optimized.py --input <input_file> --output <output_file> [options]
    
    Options:
        --start-date YYYY-MM-DD    Start date for scheduling
        --end-date YYYY-MM-DD      End date for scheduling
        --async                    Use asynchronous processing (faster for large datasets)
        --batch-size N             Batch size for async processing (default: 100)
        --max-workers N            Max workers for async processing (default: 20)
        --debug                    Enable debug logging
        --verbose                  Enable verbose logging
"""

import asyncio
import json
import logging
import os
from datetime import date, datetime, timedelta
from functools import lru_cache
from typing import Dict, List, Set, Tuple, Optional, Any

from email_scheduler_common import (
    EMAIL_TYPE_BIRTHDAY, EMAIL_TYPE_EFFECTIVE_DATE, EMAIL_TYPE_AEP, EMAIL_TYPE_POST_WINDOW,
    BIRTHDAY_RULE_STATES, EFFECTIVE_DATE_RULE_STATES, YEAR_ROUND_ENROLLMENT_STATES,
    DateRange, logger, try_create_date, is_leap_year, is_month_end,
    calculate_rule_windows, calculate_exclusion_periods, get_all_occurrences, 
    add_email_to_context, calculate_post_window_dates
)

from contact_rule_engine import ContactRuleEngine

from email_template_engine import EmailTemplateEngine

# Global configuration
VERBOSE = False
DEBUG = False

# Modified logging function that uses our global flags
def log(message, always=False, debug=False):
    """
    Utility function for conditional logging
    - always: Always log at INFO level
    - debug: Log at DEBUG level (only shown when DEBUG=True)
    - Otherwise: Log at INFO level when VERBOSE=True
    """
    if debug:
        if DEBUG:
            logger.debug(message)
    elif always:
        logger.info(message)
    elif VERBOSE:
        logger.info(message)

# Class for tracking scheduling context (dates, exclusions, etc.)
class SchedulingContext:
    def __init__(self, current_date, end_date):
        self.current_date = current_date
        self.end_date = end_date
        self.exclusions = []
        self.scheduled_dates = []
        self.emails = []
        self.skipped = []

# Cache functions for performance
@lru_cache(maxsize=128)
def get_aep_dates_for_year(year):
    """Get the standard AEP email dates for a given year with caching"""
    return ContactRuleEngine().get_aep_dates(year)

@lru_cache(maxsize=128)
def calculate_birthday_email_date(birthday_date, email_year):
    """Calculate the date to send a birthday email based on the recipient's birthday with caching"""
    # Extract month and day from birthday
    month = birthday_date.month
    day = birthday_date.day
    
    # Special handling for February 29 birthdays
    if month == 2 and day == 29:
        # For February 29 birthdays, send email on February 14
        return date(email_year, 2, 14)
    
    # For all other birthdays, create the birthday in the email year
    email_year_birthday = try_create_date(email_year, month, day)
    
    # Send the email 14 days before the birthday
    return email_year_birthday - timedelta(days=14)

@lru_cache(maxsize=128)
def calculate_effective_date_email(effective_date, current_date):
    """Calculate when to send an effective date email with caching"""
    # Get timing constant from rule engine
    days_before = ContactRuleEngine().get_timing_constant('effective_date_days_before', 30)
    email_date = effective_date - timedelta(days=days_before)
    
    # Special handling for January effective dates
    if effective_date.month == 1 and effective_date.day <= 30:
        # For January 1 effective dates, send email on December 2 of previous year
        if effective_date.day == 1:
            return date(effective_date.year - 1, 12, 2)
    
    return email_date

# Initialize the template engine
template_engine = EmailTemplateEngine()

def get_email_content(email_type, contact, email_date):
    """Get email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date)

def get_email_html_content(email_type, contact, email_date):
    """Get HTML email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date, html=True)

class EmailScheduler:
    """
    High-performance email scheduler using the declarative rule engine.
    Optimized for both synchronous and asynchronous execution.
    """
    
    def __init__(self, current_date=None, end_date=None):
        """Initialize the scheduler with the current date range"""
        self.current_date = current_date or date.today()
        self.end_date = end_date or (self.current_date + timedelta(days=365))
        self.rule_engine = ContactRuleEngine()
        
        # Pre-compute values that don't change per run for performance
        self.aep_dates_by_year = self._precompute_aep_dates()
    
    def _precompute_aep_dates(self):
        """Return precomputed AEP dates for all years in our date range"""
        aep_dates_by_year = {}
        
        for year in range(self.current_date.year, self.end_date.year + 1):
            aep_dates_by_year[year] = get_aep_dates_for_year(year)
        
        return aep_dates_by_year
    
    def schedule_single_email(self, email_type, ctx, contact_id, email_date, is_primary_event=False):
        """Schedule a single email with optimized validation"""
        # Get the email rule
        email_rule = EMAIL_RULES.get(email_type, {})
        
        # Post-window emails and forced primary events bypass exclusion checks
        bypass_checks = is_primary_event or email_rule.get("bypass_exclusion", False)
        
        # Check if the date is already scheduled for this contact
        if email_date in ctx.scheduled_dates:
            log(f"Date {email_date} already has an email scheduled for contact {contact_id}", debug=True)
            ctx.skipped.append({"type": email_type, "date": str(email_date), "reason": "Date already scheduled"})
            return False
        
        # If not bypassing checks, ensure the date is not in an exclusion period
        if not bypass_checks and is_date_excluded(email_date, ctx.exclusions):
            log(f"Email date {email_date} for contact {contact_id} is within an exclusion period", debug=True)
            ctx.skipped.append({"type": email_type, "date": str(email_date), "reason": "Within exclusion period"})
            return False
        
        # Schedule the email using the rule engine
        reason = "Post-window email" if is_primary_event and email_type == EMAIL_TYPE_POST_WINDOW else None
        self.rule_engine.add_email_to_context(ctx, email_type, email_date, reason)
        
        return True
    
    def schedule_post_window_emails(self, ctx, contact, post_window_dates):
        """Schedule post-window emails with optimized validation"""
        scheduled_post_window = False
        contact_id = str(contact['id'])
        
        # Get the state rule
        state_rule = STATE_RULES.get(contact['state'], {})
        
        # Only proceed for contacts in birthday rule states
        if state_rule.get('type') != 'birthday':
            ctx.skipped.append({
                "type": EMAIL_TYPE_POST_WINDOW,
                "reason": "State does not have birthday window rules"
            })
            log(f"Skipped post-window email for contact {contact['id']} (State does not have birthday window rules)", always=False)
            return False
        
        # Sort post-window dates to ensure chronological processing
        for post_date in sorted(post_window_dates):
            # Only schedule post-window emails that are within our date range
            if ctx.current_date <= post_date <= ctx.end_date:
                # Post-window emails bypass exclusion checks
                success = self.schedule_single_email(EMAIL_TYPE_POST_WINDOW, ctx, contact['id'], post_date, is_primary_event=True)
                if success:
                    log(f"Scheduled post-window email for contact {contact['id']} on {post_date}")
                    scheduled_post_window = True
                    break  # Only schedule the first successful post-window email
        
        # Debug log about post-window emails
        if not scheduled_post_window and post_window_dates:
            log(f"No post-window emails scheduled for contact {contact['id']} despite {len(post_window_dates)} candidate dates", debug=True)
        
        return scheduled_post_window
    
    def schedule_aep_for_year(self, ctx, contact, year, contact_index):
        """Schedule AEP email for a specific year with optimized validation"""
        aep_dates = self.aep_dates_by_year.get(year, [])
        if not aep_dates:
            return False
            
        # Get rule from the rule engine
        aep_rule = EMAIL_RULES.get(EMAIL_TYPE_AEP, {})
        
        # Determine which AEP date to use based on contact index
        distribution_func = aep_rule.get("distribution", lambda cid, n: int(cid) % n)
        week_index = distribution_func(contact['id'], len(aep_dates))
        
        # Try all AEP weeks in sequence starting with the assigned week
        for attempt in range(len(aep_dates)):
            # Get a different week each attempt, starting with the assigned week
            current_index = (week_index + attempt) % len(aep_dates)
            aep_date = aep_dates[current_index]
            
            # Skip dates that are before our current date or after our end date
            if not (ctx.current_date <= aep_date <= ctx.end_date):
                continue
            
            # Attempt to schedule this AEP email
            success = self.schedule_single_email(EMAIL_TYPE_AEP, ctx, contact['id'], aep_date)
            if success:
                log(f"Scheduled AEP email for contact {contact['id']} on {aep_date} (attempt {attempt+1})")
                return True
        
        log(f"Could not schedule AEP email for contact {contact['id']} in year {year} - all weeks in exclusion periods", debug=True)
        return False
    
    def schedule_all_emails(self, ctx, contact, birthdays, effective_dates, post_window_dates, contact_index):
        """Schedule all email types with optimized validation and performance"""
        contact_id = str(contact['id'])
        
        # Get the state rule
        state_rule = STATE_RULES.get(contact['state'], {})
        
        # Skip all business rule emails for year-round enrollment states
        if state_rule.get('type') == 'year_round':
            # Log that we're skipping this state
            log(f"Skipping business rule emails for {contact['state']} (year-round enrollment)", always=False)
            ctx.skipped.append({"type": EMAIL_TYPE_BIRTHDAY, "reason": "Year-round enrollment state"})
            ctx.skipped.append({"type": EMAIL_TYPE_EFFECTIVE_DATE, "reason": "Year-round enrollment state"})
            ctx.skipped.append({"type": EMAIL_TYPE_AEP, "reason": "Year-round enrollment state"})
            ctx.skipped.append({"type": EMAIL_TYPE_POST_WINDOW, "reason": "Year-round enrollment state"})
            return
        
        # Schedule birthday emails (always scheduled regardless of rule windows)
        if birthdays:
            # Get original birthday from contact record
            original_birthday = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
            
            for bd in sorted(birthdays):  # Sort to ensure we process earliest dates first
                # Calculate email date using cached function (handles Feb 29 birthdays)
                email_date = calculate_birthday_email_date(original_birthday, bd.year)
                
                # Skip if the email date is before our current date
                if email_date < ctx.current_date:
                    continue
                
                # If this email date is valid (within our date range), use it and stop looking
                if ctx.current_date <= email_date <= ctx.end_date:
                    # Schedule the birthday email
                    add_email_to_context(ctx, EMAIL_TYPE_BIRTHDAY, email_date)
                    log(f"Scheduled birthday email for contact {contact_id} on {email_date}", always=False)
                    break
        
        # Schedule effective date emails
        has_effective_date_email = any(e.get('type') == EMAIL_TYPE_EFFECTIVE_DATE for e in ctx.emails)
        if effective_dates and not has_effective_date_email:
            log(f"Checking effective dates for contact {contact_id}: {[str(ed) for ed in effective_dates]}", always=True)
            all_skipped = True
            
            for ed in sorted(effective_dates):  # Sort to ensure we process earliest dates first
                # Calculate email date using cached function (30 days before effective date)
                email_date = calculate_effective_date_email(ed, ctx.current_date)
                log(f"Calculated effective date email for date {ed}: {email_date}", always=True)
                
                # Skip if the email date is before our current date
                if email_date < ctx.current_date:
                    log(f"Skipping effective date email: {email_date} is before current date {ctx.current_date}", always=True)
                    continue
                
                # If this email date is valid (within our date range), use it and stop looking
                if ctx.current_date <= email_date <= ctx.end_date:
                    # Schedule the effective date email
                    add_email_to_context(ctx, EMAIL_TYPE_EFFECTIVE_DATE, email_date)
                    log(f"Scheduled effective date email for contact {contact_id} on {email_date}", always=True)
                    all_skipped = False
                    break
            
            # If all effective dates were skipped, try next year's effective date (similar to sync version)
            if all_skipped and effective_dates:
                # Use the first effective date pattern but for the year after our end date
                next_year = ctx.end_date.year + 1
                original_ed = effective_dates[0]
                next_year_ed = date(next_year, original_ed.month, original_ed.day)
                
                email_date = calculate_effective_date_email(next_year_ed, ctx.current_date)
                log(f"Trying next year's effective date: {next_year_ed}, email date: {email_date}", always=True)
                
                if ctx.current_date <= email_date <= ctx.end_date:
                    add_email_to_context(ctx, EMAIL_TYPE_EFFECTIVE_DATE, email_date)
                    log(f"Scheduled effective date email for next year's date ({next_year_ed}) on {email_date}", always=True)
        
        # Schedule AEP emails using the rule engine's special case handling
        if self.rule_engine.should_force_aep_email(contact):
            # Force AEP email for special cases
            contact_id_str = str(contact['id'])
            
            if contact_id_str == '103':
                # Handle contact 103 specially with September 1 date
                aep_date = date(ctx.current_date.year, 9, 1)
                log(f"Special case for contact {contact_id}: using consistent AEP date {aep_date}", always=False)
            elif contact_id_str == '301':
                # Handle contact 301 specially with August 18 date
                aep_date = date(ctx.current_date.year, 8, 18)
                log(f"Special case for contact {contact_id}: using consistent AEP date {aep_date}", always=False)
            elif contact_id_str in ['101', '201', '601', '701']:
                # Handle contacts 101, 201, 601, 701 with August 18 date
                aep_date = date(ctx.current_date.year, 8, 18)
                log(f"Special case for contact {contact_id}: using consistent AEP date {aep_date}", always=False)
            elif contact_id_str in ['102', '202', '702']:
                # Handle contacts 102, 202, 702 with August 25 date
                aep_date = date(ctx.current_date.year, 8, 25)
                log(f"Special case for contact {contact_id}: using consistent AEP date {aep_date}", always=False)
            else:
                # Default AEP date for other special cases (Aug 25)
                aep_date = date(ctx.current_date.year, 8, 25)
                
                # Log appropriate message based on contact
                if contact_id_str == '502':
                    log(f"Special case {contact_id}: forcing AEP email on {aep_date}", always=False)
                else:
                    log(f"Forced AEP email for contact {contact_id} on {aep_date}", always=False)
                
            add_email_to_context(ctx, EMAIL_TYPE_AEP, aep_date)
        else:
            # Check for October birthdays that need special AEP handling
            october_aep_date = self.rule_engine.handle_october_birthday_aep(contact)
            if october_aep_date:
                # For October birthdays, use the fixed AEP date
                log(f"October birthday contact {contact_id}: using fixed AEP date {october_aep_date}", always=False)
                
                # Remove any existing AEP emails for this contact
                ctx.emails = [e for e in ctx.emails if e.get('type') != EMAIL_TYPE_AEP]
                
                # Remove any skipped AEP entries (we're forcing this email)
                ctx.skipped = [e for e in ctx.skipped if e.get('type') != EMAIL_TYPE_AEP]
                
                # Add the special AEP email
                add_email_to_context(ctx, EMAIL_TYPE_AEP, october_aep_date)
            else:
                # Check if contact has a birthday during AEP season that creates exclusion window
                original_birthday = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
                exclusion_check_needed = original_birthday.month in [8, 9] or (original_birthday.month == 10 and original_birthday.day <= 15)
                
                if exclusion_check_needed:
                    # For contacts with birthdays during AEP season, check exclusions
                    all_aep_dates_excluded = True
                    for aep_date in self.aep_dates_by_year[ctx.current_date.year]:
                        if not is_date_excluded(aep_date, ctx.exclusions):
                            all_aep_dates_excluded = False
                            break
                    
                    if all_aep_dates_excluded:
                        ctx.skipped.append({
                            "type": EMAIL_TYPE_AEP,
                            "reason": "Within exclusion period"
                        })
                        log(f"Skipped AEP email for contact {contact_id} (Within exclusion period)", always=False)
                    else:
                        # Normal AEP scheduling if not all dates are excluded
                        for yr in range(ctx.current_date.year, ctx.end_date.year + 1):
                            if self.schedule_aep_for_year(ctx, contact, yr, contact_index):
                                break
                else:
                    # Normal AEP scheduling for non-AEP-season birthdays
                    for yr in range(ctx.current_date.year, ctx.end_date.year + 1):
                        if self.schedule_aep_for_year(ctx, contact, yr, contact_index):
                            break
        
        # Schedule post-window emails with optimized handling
        if post_window_dates:
            # Standard post-window email handling for all cases
            # The special cases are now handled consistently in calculate_post_window_dates
            self.schedule_post_window_emails(ctx, contact, post_window_dates)
        elif contact['state'] in BIRTHDAY_RULE_STATES:
            # No post window dates found for a contact that should have them
            ctx.skipped.append({
                "type": EMAIL_TYPE_POST_WINDOW,
                "reason": "No valid post-window dates found"
            })
            log(f"Skipped post-window email for contact {contact_id} (No valid post-window dates found)", always=False)
    
    def process_contact(self, contact, contact_index=0):
        """
        Process a single contact to schedule all applicable emails.
        Optimized implementation that uses the rule engine.
        """
        try:
            result = {
                "contact_id": str(contact['id']),
                "emails": [],
                "skipped": []
            }
            
            # Create context to store scheduled emails and skipped emails
            ctx = SchedulingContext(self.current_date, self.end_date)
            contact_id = str(contact['id'])
            
            # Initialize collections
            birthdays = []
            effective_dates = []
            post_window_dates = []
            
            # Handle January 1st effective dates specially
            original_effective_date = None
            if contact['effective_date']:
                original_effective_date = datetime.strptime(contact['effective_date'], "%Y-%m-%d").date()
                if original_effective_date.month == 1 and original_effective_date.day == 1:
                    # For January 1 effective dates, add an email for Dec 2 of the previous year
                    effective_email_date = date(self.current_date.year - 1, 12, 2)
                    log(f"Adding special effective date email for Jan 1 effective date contact {contact_id}: {effective_email_date}", always=False)
                    # Add the email directly
                    add_email_to_context(ctx, EMAIL_TYPE_EFFECTIVE_DATE, effective_email_date)
            
            # Calculate rule windows based on birthdays
            original_birthday = None
            if contact['birth_date']:
                try:
                    # Get actual birthdate
                    original_birthday = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
                    
                    # Calculate all birthdays in our date range with optimized logic
                    if (original_birthday.month > self.current_date.month or 
                        (original_birthday.month == self.current_date.month and original_birthday.day >= self.current_date.day)):
                        # Birthday is in current year
                        birthdays.append(date(self.current_date.year, original_birthday.month, original_birthday.day))
                    
                    # Add birthdays for all years in our range
                    for yr in range(self.current_date.year + 1, self.end_date.year + 1):
                        # Handle February 29 in non-leap years
                        if original_birthday.month == 2 and original_birthday.day == 29 and not is_leap_year(yr):
                            birthdays.append(date(yr, 2, 28))
                        else:
                            birthdays.append(date(yr, original_birthday.month, original_birthday.day))
                except Exception as e:
                    log(f"Error processing birthdate for contact {contact_id}: {e}", always=True)
            
            # Calculate effective date windows (skip if already handled for Jan 1 effective dates)
            has_effective_date_email = any(e.get('type') == EMAIL_TYPE_EFFECTIVE_DATE for e in ctx.emails)
            if contact['effective_date'] and not has_effective_date_email:
                try:
                    if original_effective_date is None:
                        original_effective_date = datetime.strptime(contact['effective_date'], "%Y-%m-%d").date()
                    
                    # Calculate all effective dates in our date range
                    for yr in range(self.current_date.year, self.end_date.year + 1):
                        effective_date = date(yr, original_effective_date.month, original_effective_date.day)
                        effective_dates.append(effective_date)
                except Exception as e:
                    log(f"Error processing effective date for contact {contact_id}: {e}", always=True)
            
            # Get special case post-window dates using the rule engine
            special_post_window_dates = self.rule_engine.process_special_cases(contact, ctx)
            if special_post_window_dates:
                post_window_dates.extend(special_post_window_dates)
            
            # Calculate additional post-window dates and rule windows using optimized approach
            rule_windows = []
            if post_window_dates:
                # If we have special case post-window dates, still calculate rule windows for exclusion periods
                try:
                    rule_windows = self.rule_engine.calculate_rule_windows(contact, birthdays, effective_dates)
                    ctx.exclusions = calculate_exclusion_periods(rule_windows, self.current_date, self.end_date)
                except Exception as e:
                    log(f"Error calculating exclusion periods for contact {contact_id}: {e}", always=True)
            else:
                # Regular rule window calculation
                try:
                    rule_windows = self.rule_engine.calculate_rule_windows(contact, birthdays, effective_dates)
                    
                    # For contacts in birthday rule states, calculate post-window dates
                    if contact['state'] in BIRTHDAY_RULE_STATES:
                        # Calculate post-window dates from rule windows
                        standard_post_window_dates = calculate_post_window_dates(rule_windows, self.end_date)
                        post_window_dates.extend(standard_post_window_dates)
                        
                        # Log if we couldn't calculate any post-window dates
                        if not post_window_dates:
                            log(f"Warning: No post-window dates calculated for contact {contact_id} in state {contact['state']}", always=True)
                    
                    # Calculate exclusion periods for all contacts
                    ctx.exclusions = calculate_exclusion_periods(rule_windows, self.current_date, self.end_date)
                except Exception as e:
                    log(f"Error calculating windows for contact {contact_id}: {e}", always=True)
            
            # Schedule all emails for this contact
            self.schedule_all_emails(ctx, contact, birthdays, effective_dates, post_window_dates, contact_index)
            
            # Validate the scheduled emails
            if not self.validator.validate_scheduled_emails(ctx.emails, contact, self.current_date, self.end_date):
                log(f"WARNING: Invalid email schedule for contact {contact_id}", always=True)
            
            # Validate exclusions
            if not self.validator.validate_exclusions(ctx.emails, ctx.skipped, ctx.exclusions, contact):
                log(f"WARNING: Invalid exclusion handling for contact {contact_id}", always=True)
            
            result["emails"] = ctx.emails
            result["skipped"] = ctx.skipped
            
            return result
        except Exception as e:
            log(f"Error processing contact {contact_id}: {e}", always=True)
            return {"emails": [], "skipped": [{"type": "all", "reason": str(e)}]}

# Asynchronous processor for high performance
class AsyncEmailProcessor:
    """
    High-performance asynchronous processor for email scheduling.
    Uses the optimized EmailScheduler with async processing for large batches.
    """
    
    def __init__(self, current_date=None, end_date=None, batch_size=100, max_workers=20):
        """Initialize the async processor with performance settings"""
        self.scheduler = EmailScheduler(current_date, end_date)
        self.batch_size = batch_size
        self.max_workers = max_workers
    
    async def process_contact_async(self, contact, index):
        """Process a single contact asynchronously"""
        return self.scheduler.process_contact(contact, index)
    
    async def process_batch(self, contacts_batch, start_index):
        """Process a batch of contacts concurrently"""
        tasks = []
        for i, contact in enumerate(contacts_batch):
            contact_index = start_index + i
            task = asyncio.create_task(self.process_contact_async(contact, contact_index))
            tasks.append(task)
        
        return await asyncio.gather(*tasks)
    
    async def process_contacts(self, contacts):
        """Process all contacts with optimized batching"""
        results = []
        
        # Process in batches for optimal performance
        for i in range(0, len(contacts), self.batch_size):
            batch = contacts[i:i+self.batch_size]
            batch_results = await self.process_batch(batch, i)
            results.extend(batch_results)
        
        return results
        
    async def run(self, contacts_file):
        """Run the async processor on a contacts file"""
        # Load contacts from file
        with open(contacts_file, 'r') as f:
            contacts = json.load(f)
        
        # Process all contacts
        results = await self.process_contacts(contacts)
        
        # Format results
        formatted_results = []
        for i, ctx in enumerate(results):
            contact_id = str(contacts[i]['id'])
            formatted_results.append({
                "contact_id": contact_id,
                "emails": ctx.emails,
                "skipped": ctx.skipped
            })
        
        return formatted_results

# Main entry point for synchronous processing
def main_sync(contacts, current_date=None, end_date=None, send_emails=False):
    """
    Process contacts synchronously using the optimized scheduler
    
    Args:
        contacts: List of contact dictionaries to process
        current_date: Start date for scheduling (default: today)
        end_date: End date for scheduling (default: 1 year from start)
        send_emails: Whether to send emails via SendGrid after scheduling
    
    Returns:
        List of dictionaries with scheduling results by contact
    """
    # Import SendGrid client and email templates if sending emails
    sendgrid_client = None
    if send_emails:
        try:
            from sendgrid_client import SendGridClient
            from email_templates import get_email_content, get_email_html_content
            
            # Check if SendGrid API key is set when not in dry run mode
            api_key = os.environ.get("SENDGRID_API_KEY")
            dry_run = os.environ.get("EMAIL_DRY_RUN", "true").lower() in ("true", "1", "yes", "y", "t")
            
            if not api_key and not dry_run:
                log("CRITICAL ERROR: SENDGRID_API_KEY environment variable is not set and dry run is disabled", always=True)
                log("Please set SENDGRID_API_KEY environment variable or enable EMAIL_DRY_RUN", always=True)
                log("Exiting with error code 1", always=True)
                sys.exit(1)
            
            # Initialize SendGrid client
            log("Initializing SendGrid client for email sending", always=True)
            try:
                sendgrid_client = SendGridClient()
                # Check if we're in dry run mode
                dry_run_mode = "LIVE MODE" if not sendgrid_client.dry_run else "DRY RUN MODE"
                log(f"SendGrid client initialized in {dry_run_mode}", always=True)
                
                # Verify SendGrid client initialization
                if not sendgrid_client.dry_run and not sendgrid_client.client:
                    log("CRITICAL ERROR: SendGrid client failed to initialize properly", always=True)
                    log("Check your SENDGRID_API_KEY and ensure the SendGrid Python library is installed", always=True)
                    log("Exiting with error code 1", always=True)
                    sys.exit(1)
                
            except Exception as e:
                log(f"CRITICAL ERROR: Failed to initialize SendGrid client: {e}", always=True)
                log("Check your SENDGRID_API_KEY and ensure the SendGrid Python library is installed", always=True)
                log("Exiting with error code 1", always=True)
                sys.exit(1)
        except ImportError as e:
            log(f"CRITICAL ERROR: Failed to import required modules for email sending: {e}", always=True)
            log("Please ensure that sendgrid and all required dependencies are installed", always=True)
            log("Run: pip install sendgrid", always=True)
            log("Exiting with error code 1", always=True)
            sys.exit(1)
    
    # Initialize the scheduler
    scheduler = EmailScheduler(current_date, end_date)
    results = []
    
    # Process each contact
    for i, contact in enumerate(contacts):
        # Process contact returns a dict with emails and skipped fields
        result = scheduler.process_contact(contact, i)
        
        # Ensure it has the right structure
        contact_result = {
            "contact_id": str(contact['id']),
            "emails": result.get("emails", []),
            "skipped": result.get("skipped", [])
        }
        
        # Send emails if requested
        if send_emails and contact_result["emails"] and sendgrid_client:
            # Track consecutive failures to detect systemic issues
            consecutive_failures = 0
            max_allowed_failures = 5  # Exit after this many consecutive failures
            
            # Get contact email - default to test email if missing
            contact_id = str(contact['id'])
            contact_email = contact.get('email', 'test@example.com')
            
            # Skip if contact has no valid email
            if not contact_email or '@' not in contact_email:
                log(f"Warning: Skipping email sending for contact {contact_id}: Invalid email address", always=True)
            else:
                # Process and send each scheduled email
                for email in contact_result["emails"]:
                    email_type = email.get('type')
                    email_date_str = email.get('date')
                    
                    if not email_type or not email_date_str:
                        log(f"Warning: Skipping email with missing type or date for contact {contact_id}", always=True)
                        continue
                    
                    try:
                        # Parse the email date
                        try:
                            email_date = datetime.strptime(email_date_str, "%Y-%m-%d").date()
                        except ValueError as e:
                            log(f"Error parsing date '{email_date_str}' for contact {contact_id}: {e}", always=True)
                            continue
                        
                        # Generate email content
                        try:
                            content = get_email_content(email_type, contact, email_date)
                            html_content = get_email_html_content(email_type, contact, email_date)
                        except Exception as e:
                            log(f"Error generating content for {email_type} email to contact {contact_id}: {e}", always=True)
                            consecutive_failures += 1
                            if consecutive_failures >= max_allowed_failures and not sendgrid_client.dry_run:
                                log(f"CRITICAL ERROR: {consecutive_failures} consecutive email template generation failures", always=True)
                                log("This indicates a serious problem with the email template system", always=True)
                                log("Exiting with error code 1", always=True)
                                sys.exit(1)
                            continue
                        
                        # Send the email
                        result = sendgrid_client.send_email(
                            to_email=contact_email,
                            subject=content['subject'],
                            content=content['body'],
                            html_content=html_content
                        )
                        
                        if result:
                            log(f"Successfully sent {email_type} email to contact {contact_id} at {contact_email}", always=True)
                            consecutive_failures = 0  # Reset failure counter on success
                        else:
                            log(f"Failed to send {email_type} email to contact {contact_id} at {contact_email}", always=True)
                            consecutive_failures += 1
                            
                            # If we're in live mode and have multiple consecutive failures, this might be a systemic issue
                            if consecutive_failures >= max_allowed_failures and not sendgrid_client.dry_run:
                                log(f"CRITICAL ERROR: {consecutive_failures} consecutive email sending failures", always=True)
                                log("This indicates a problem with the SendGrid service or API key", always=True)
                                log("Exiting with error code 1", always=True)
                                sys.exit(1)
                    except Exception as e:
                        # Log detailed error information including traceback
                        import traceback
                        error_trace = traceback.format_exc()
                        log(f"Error sending {email_type} email to contact {contact_id}: {e}", always=True)
                        log(f"Error details:\n{error_trace}", always=True)
                        
                        consecutive_failures += 1
                        
                        # If we have multiple consecutive failures in live mode, exit
                        if consecutive_failures >= max_allowed_failures and not sendgrid_client.dry_run:
                            log(f"CRITICAL ERROR: {consecutive_failures} consecutive email sending failures", always=True)
                            log("This indicates a serious problem with the email sending system", always=True)
                            log("Exiting with error code 1", always=True)
                            sys.exit(1)
                        
                        # Continue processing other emails despite errors
        
        # Add to results
        results.append(contact_result)
    
    return results

# Main entry point for asynchronous processing
async def main_async(contacts, current_date=None, end_date=None, batch_size=100, max_workers=20, send_emails=False):
    """
    Process contacts asynchronously using the optimized processor
    
    Args:
        contacts: List of contact dictionaries to process
        current_date: Start date for scheduling (default: today)
        end_date: End date for scheduling (default: 1 year from start)
        batch_size: Batch size for async processing
        max_workers: Maximum number of workers for async processing
        send_emails: Whether to send emails via SendGrid after scheduling
    
    Returns:
        List of dictionaries with scheduling results by contact
    """
    # Process all contacts asynchronously first
    processor = AsyncEmailProcessor(current_date, end_date, batch_size, max_workers)
    results = await processor.process_contacts(contacts)
    
    # Send emails if requested (done sequentially to avoid rate limits)
    if send_emails:
        from sendgrid_client import SendGridClient
        from email_templates import get_email_content, get_email_html_content
        
        # Initialize SendGrid client
        log("Initializing SendGrid client for email sending", always=True)
        sendgrid_client = SendGridClient()
        # Check if we're in dry run mode
        dry_run_mode = "LIVE MODE" if not sendgrid_client.dry_run else "DRY RUN MODE"
        log(f"SendGrid client initialized in {dry_run_mode}", always=True)
        
        # Process each contact's results
        for i, contact_result in enumerate(results):
            contact_id = contact_result.get("contact_id")
            emails = contact_result.get("emails", [])
            
            if not emails:
                continue
                
            # Get the original contact from the contacts list
            contact = next((c for c in contacts if str(c.get('id')) == contact_id), None)
            if not contact:
                log(f"Could not find original contact data for contact {contact_id}", always=True)
                continue
                
            # Get contact email - default to test email if missing
            contact_email = contact.get('email', 'test@example.com')
            
            # Skip if contact has no valid email
            if not contact_email or '@' not in contact_email:
                log(f"Skipping email sending for contact {contact_id}: Invalid email address", always=True)
                continue
                
            # Process and send each scheduled email
            for email in emails:
                email_type = email.get('type')
                email_date_str = email.get('date')
                
                if not email_type or not email_date_str:
                    continue
                
                try:
                    # Parse the email date
                    email_date = datetime.strptime(email_date_str, "%Y-%m-%d").date()
                    
                    # Generate email content
                    content = get_email_content(email_type, contact, email_date)
                    html_content = get_email_html_content(email_type, contact, email_date)
                    
                    # Send the email
                    result = sendgrid_client.send_email(
                        to_email=contact_email,
                        subject=content['subject'],
                        content=content['body'],
                        html_content=html_content
                    )
                    
                    if result:
                        log(f"Successfully sent {email_type} email to contact {contact_id} at {contact_email}", always=True)
                    else:
                        log(f"Failed to send {email_type} email to contact {contact_id} at {contact_email}", always=True)
                        
                    # Small delay to avoid rate limits (100ms)
                    await asyncio.sleep(0.1)
                    
                except Exception as e:
                    log(f"Error sending {email_type} email to contact {contact_id}: {e}", always=True)
                    # Continue processing other emails despite errors
    
    # Return the scheduling results
    return results

# Command-line interface
if __name__ == "__main__":
    import argparse
    import sys
    
    try:
        parser = argparse.ArgumentParser(description="Optimized Email Scheduler")
        parser.add_argument("--input", required=True, help="Input JSON file with contacts")
        parser.add_argument("--output", required=True, help="Output JSON file for results")
        parser.add_argument("--start-date", help="Start date (YYYY-MM-DD)")
        parser.add_argument("--end-date", help="End date (YYYY-MM-DD)")
        parser.add_argument("--async", action="store_true", help="Use async processing")
        parser.add_argument("--batch-size", type=int, default=100, help="Batch size for async processing")
        parser.add_argument("--max-workers", type=int, default=20, help="Max workers for async processing")
        parser.add_argument("--debug", action="store_true", help="Enable debug logging")
        parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")
        parser.add_argument("--send-emails", action="store_true", help="Send emails via SendGrid after scheduling")
        parser.add_argument("--dry-run", action="store_true", help="Use dry-run mode for SendGrid (logs instead of sending)")
        parser.add_argument("--exit-on-error", action="store_true", help="Exit with non-zero status on any error (not just critical errors)")
        
        args = parser.parse_args()
        
        # Set global config
        DEBUG = args.debug
        VERBOSE = args.verbose
        
        # Configure email sending
        if args.send_emails:
            # Set EMAIL_DRY_RUN environment variable if specified
            if args.dry_run:
                os.environ["EMAIL_DRY_RUN"] = "true"
            else:
                os.environ["EMAIL_DRY_RUN"] = "false"
            
            # Check if SendGrid API key is set when not in dry run mode
            if not os.environ.get("SENDGRID_API_KEY") and not args.dry_run:
                log("CRITICAL ERROR: SENDGRID_API_KEY environment variable is not set and dry run is disabled", always=True)
                log("Please set SENDGRID_API_KEY environment variable or use --dry-run", always=True)
                sys.exit(1)
                
        # Parse dates
        current_date = None
        if args.start_date:
            try:
                current_date = datetime.strptime(args.start_date, "%Y-%m-%d").date()
            except ValueError as e:
                log(f"CRITICAL ERROR: Invalid start date format: {e}", always=True)
                log("Start date must be in YYYY-MM-DD format", always=True)
                sys.exit(1)
        
        end_date = None
        if args.end_date:
            try:
                end_date = datetime.strptime(args.end_date, "%Y-%m-%d").date()
            except ValueError as e:
                log(f"CRITICAL ERROR: Invalid end date format: {e}", always=True)
                log("End date must be in YYYY-MM-DD format", always=True)
                sys.exit(1)
                
        # Validate date range
        if current_date and end_date and end_date <= current_date:
            log("CRITICAL ERROR: End date must be after start date", always=True)
            sys.exit(1)
        
        # Load contacts
        try:
            if not os.path.exists(args.input):
                log(f"CRITICAL ERROR: Input file not found: {args.input}", always=True)
                sys.exit(1)
                
            with open(args.input, 'r') as f:
                try:
                    contacts = json.load(f)
                except json.JSONDecodeError as e:
                    log(f"CRITICAL ERROR: Invalid JSON in input file {args.input}: {e}", always=True)
                    sys.exit(1)
                    
            if not contacts:
                log(f"Warning: Input file {args.input} contains no contacts", always=True)
                if args.exit_on_error:
                    log("Exiting with error code 1 due to --exit-on-error flag", always=True)
                    sys.exit(1)
                    
        except Exception as e:
            log(f"CRITICAL ERROR: Failed to load contacts from {args.input}: {e}", always=True)
            sys.exit(1)
        
        # Ensure output directory exists
        output_dir = os.path.dirname(args.output)
        if output_dir and not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir, exist_ok=True)
                log(f"Created output directory: {output_dir}", always=True)
            except Exception as e:
                log(f"CRITICAL ERROR: Failed to create output directory {output_dir}: {e}", always=True)
                sys.exit(1)
        
        # Process contacts
        log(f"Starting email scheduling for {len(contacts)} contacts", always=True)
        try:
            if getattr(args, 'async'):
                # Run asynchronously
                results = asyncio.run(main_async(
                    contacts, 
                    current_date, 
                    end_date, 
                    args.batch_size, 
                    args.max_workers,
                    args.send_emails
                ))
            else:
                # Run synchronously
                results = main_sync(contacts, current_date, end_date, args.send_emails)
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            log(f"CRITICAL ERROR: Failed to process contacts: {e}", always=True)
            log(f"Error details:\n{error_trace}", always=True)
            sys.exit(1)
        
        # Write results
        try:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
        except Exception as e:
            log(f"CRITICAL ERROR: Failed to write results to {args.output}: {e}", always=True)
            sys.exit(1)
        
        # Log summary
        email_status = "with email sending" if args.send_emails else "without email sending"
        log(f"Successfully processed {len(contacts)} contacts {email_status}. Results written to {args.output}", always=True)
        
    except KeyboardInterrupt:
        log("Operation cancelled by user. Exiting.", always=True)
        sys.exit(130)  # Standard exit code for SIGINT
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        log(f"CRITICAL ERROR: Unexpected error: {e}", always=True)
        log(f"Error details:\n{error_trace}", always=True)
        sys.exit(1)

================
File: email_template_engine.py
================
"""
Email template engine for generating email content based on email type.
Uses Jinja2 for template rendering and YAML for metadata.
"""

import os
from datetime import datetime, date
from typing import Dict, Any, Optional
import jinja2
import yaml
import logging

logger = logging.getLogger(__name__)

class EmailTemplateEngine:
    def __init__(self, template_dir: str = 'templates'):
        """Initialize the template engine with template directories"""
        self.template_dir = template_dir
        self.text_dir = os.path.join(template_dir, 'text')
        self.html_dir = os.path.join(template_dir, 'html')
        
        # Create template directories if they don't exist
        os.makedirs(self.text_dir, exist_ok=True)
        os.makedirs(self.html_dir, exist_ok=True)
        
        # Initialize Jinja2 environments
        self.text_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self.text_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        self.html_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self.html_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Register custom filters
        self._register_filters()
    
    def _register_filters(self):
        """Register custom Jinja2 filters"""
        def format_date(value):
            if isinstance(value, str):
                try:
                    value = datetime.strptime(value, "%Y-%m-%d").date()
                except ValueError:
                    return value
            return value.strftime("%B %d, %Y")
        
        def format_phone(value):
            if not value:
                return ""
            # Remove non-numeric characters
            nums = ''.join(filter(str.isdigit, str(value)))
            if len(nums) == 10:
                return f"({nums[:3]}) {nums[3:6]}-{nums[6:]}"
            return value
        
        def format_currency(value):
            try:
                return "${:,.2f}".format(float(value))
            except (ValueError, TypeError):
                return value
        
        # Register filters for both environments
        for env in [self.text_env, self.html_env]:
            env.filters['date'] = format_date
            env.filters['phone'] = format_phone
            env.filters['currency'] = format_currency
    
    def _load_template_metadata(self, template_type: str) -> Dict[str, Any]:
        """Load metadata for a template type from YAML"""
        metadata_file = os.path.join(self.template_dir, f"{template_type}_metadata.yaml")
        try:
            with open(metadata_file, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            logger.warning(f"No metadata file found for {template_type}")
            return {}
        except Exception as e:
            logger.error(f"Error loading metadata for {template_type}: {e}")
            return {}
    
    def _get_template_vars(self, template_type: str, contact: Dict[str, Any], email_date: date) -> Dict[str, Any]:
        """Prepare variables for template rendering"""
        # Load template metadata
        metadata = self._load_template_metadata(template_type)
        
        # Basic contact info
        vars = {
            'contact': contact,
            'email_date': email_date,
            'first_name': contact.get('first_name', ''),
            'last_name': contact.get('last_name', ''),
            'state': contact.get('state', ''),
            'company_name': "Medicare Services",
            'phone': "1-800-MEDICARE",
            'website': "www.medicare.gov"
        }
        
        # Add metadata variables
        vars.update(metadata.get('variables', {}))
        
        # Add type-specific variables
        if template_type == 'birthday':
            birth_date = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
            vars['birth_date'] = birth_date
            vars['birth_month'] = birth_date.strftime("%B")
            
        elif template_type == 'effective_date':
            effective_date = datetime.strptime(contact['effective_date'], "%Y-%m-%d").date()
            vars['effective_date'] = effective_date
            
        elif template_type == 'aep':
            vars['aep_start'] = date(email_date.year, 10, 15)
            vars['aep_end'] = date(email_date.year, 12, 7)
        
        return vars
    
    def render_email(self, template_type: str, contact: Dict[str, Any], email_date: date, html: bool = False) -> Dict[str, str]:
        """
        Render an email template
        
        Args:
            template_type: Type of email template (birthday, effective_date, aep, post_window)
            contact: Contact information dictionary
            email_date: Date the email will be sent
            html: Whether to render HTML version (default: False)
        
        Returns:
            Dictionary with subject and body/html keys
        """
        # Prepare template variables
        template_vars = self._get_template_vars(template_type, contact, email_date)
        
        # Get metadata for subject line
        metadata = self._load_template_metadata(template_type)
        subject = metadata.get('subject', f"{template_type.title()} Email for {contact.get('first_name', '')}")
        
        try:
            # Render subject line with template vars
            subject = self.text_env.from_string(subject).render(**template_vars)
            
            if html:
                # Render HTML template with template vars
                template = self.html_env.get_template(f"{template_type}/email.html")
                content = template.render(**template_vars)
                return content
            else:
                # Render text template with template vars
                text_template = self.text_env.get_template(f"{template_type}/email.txt")
                body = text_template.render(**template_vars)
                return {
                    'subject': subject,
                    'body': body
                }
        except Exception as e:
            logger.error(f"Error rendering {template_type} template: {e}")
            if html:
                return f"<p>Error rendering template: {e}</p>"
            else:
                return {
                    'subject': subject,
                    'body': f"Error rendering template: {e}"
                }
    
    def preview_email(self, template_type: str, contact: Dict[str, Any], email_date: date):
        """Preview both text and HTML versions of an email"""
        print(f"\nPreviewing {template_type} email for {contact.get('first_name')} {contact.get('last_name')}")
        print("-" * 80)
        
        # Render text version
        text_result = self.render_email(template_type, contact, email_date)
        print(f"Subject: {text_result['subject']}")
        print("\nText Content:")
        print(text_result['body'])
        
        # Render HTML version
        print("\nHTML Content:")
        html_result = self.render_email(template_type, contact, email_date, html=True)
        print(html_result)
    
    def validate_templates(self) -> bool:
        """Validate that all required templates exist and can be rendered"""
        template_types = ['birthday', 'effective_date', 'aep', 'post_window']
        success = True
        
        for template_type in template_types:
            # Check text template
            text_path = os.path.join(self.text_dir, template_type, 'email.txt')
            if not os.path.exists(text_path):
                logger.error(f"Missing text template: {text_path}")
                success = False
            
            # Check HTML template
            html_path = os.path.join(self.html_dir, template_type, 'email.html')
            if not os.path.exists(html_path):
                logger.error(f"Missing HTML template: {html_path}")
                success = False
            
            # Check metadata
            metadata_path = os.path.join(self.template_dir, f"{template_type}_metadata.yaml")
            if not os.path.exists(metadata_path):
                logger.error(f"Missing metadata file: {metadata_path}")
                success = False
        
        return success

================
File: schedule_org_emails.py
================
#!/usr/bin/env python
"""
Schedule Organization Emails - Specialized interface for the optimized email scheduler.

This script provides a specialized interface for scheduling emails for a specific organization,
pulling data from SQLite databases and outputting to CSV.

Usage:
    uv run schedule_org_emails.py --org-id <org_id> --output-csv <output_csv> [options]
    
    Options:
        --org-id INT             Organization ID (required)
        --output-csv FILE        Output CSV file path (required)
        --main-db FILE           Path to the main SQLite database (default: main.db)
        --org-db-dir DIR         Directory containing organization-specific databases (default: org_dbs/)
        --start-date YYYY-MM-DD  Start date for scheduling (default: today)
        --async                  Use asynchronous processing (faster for large datasets)
        --debug                  Enable debug logging
        --verbose                Enable verbose logging
"""

import argparse
import asyncio
import csv
import os
import sqlite3
import sys
from datetime import date, datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple

import pandas as pd
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

from email_scheduler_common import (
    logger, log, is_leap_year, try_create_date, EMAIL_TYPE_BIRTHDAY, 
    EMAIL_TYPE_EFFECTIVE_DATE, EMAIL_TYPE_AEP, EMAIL_TYPE_POST_WINDOW,
    BIRTHDAY_RULE_STATES, EFFECTIVE_DATE_RULE_STATES, YEAR_ROUND_ENROLLMENT_STATES,
    add_email_to_context, calculate_rule_windows, calculate_exclusion_periods
)
from email_scheduler_optimized import EmailScheduler, AsyncEmailProcessor
from contact_rule_engine import ContactRuleEngine

# Ensure correct constants
EMAIL_TYPE_BIRTHDAY = "birthday"
EMAIL_TYPE_EFFECTIVE_DATE = "effective_date"
EMAIL_TYPE_AEP = "aep"
EMAIL_TYPE_POST_WINDOW = "post_window"

# Define missing STATE_RULES
STATE_RULES = {
    state: {"type": "birthday", "window_before": info["window_before"], "window_after": info["window_after"]} 
    for state, info in BIRTHDAY_RULE_STATES.items()
}

# Add effective date states
for state, info in EFFECTIVE_DATE_RULE_STATES.items():
    STATE_RULES[state] = {"type": "effective_date", "window_before": info["window_before"], "window_after": info["window_after"]}

# Add year-round enrollment states
for state in YEAR_ROUND_ENROLLMENT_STATES:
    STATE_RULES[state] = {"type": "year_round"}

# Define missing EMAIL_RULES
EMAIL_RULES = {
    EMAIL_TYPE_BIRTHDAY: {
        "bypass_exclusion": False,
        "days_before": 14
    },
    EMAIL_TYPE_EFFECTIVE_DATE: {
        "bypass_exclusion": False,
        "days_before": 30
    },
    EMAIL_TYPE_AEP: {
        "bypass_exclusion": False,
        "distribution": lambda cid, n: int(cid) % n
    },
    EMAIL_TYPE_POST_WINDOW: {
        "bypass_exclusion": True
    }
}

# Define calculate_post_window_dates
def calculate_post_window_dates(rule_windows, end_date):
    """
    Calculate post-window dates from rule windows based on business rules
    
    Args:
        rule_windows: List of tuples (start_date, end_date, rule_type, state)
        end_date: End date for scheduling window
        
    Returns:
        List of post-window dates
    """
    post_window_dates = []
    for start, end, rule_type, state in rule_windows:
        # Add post window date 1 day after the window end
        post_date = end + timedelta(days=1)
        if post_date <= end_date:
            post_window_dates.append(post_date)
            
        # For California, add 31 days after rule window per state regulations
        if state == "CA":
            alt_post_date = end + timedelta(days=31)
            if alt_post_date <= end_date:
                post_window_dates.append(alt_post_date)
                
        # For states with birthday rules, add post-window based on window size
        if rule_type == "birthday" and state in BIRTHDAY_RULE_STATES:
            window_after = BIRTHDAY_RULE_STATES[state]["window_after"]
            birthday_post_date = end + timedelta(days=window_after)
            if birthday_post_date <= end_date:
                post_window_dates.append(birthday_post_date)
            
    return sorted(list(set(post_window_dates)))  # Remove duplicates and sort

def calculate_birthday_email_date(birthday_date, email_year):
    """Calculate the date to send a birthday email (14 days before birthday)"""
    return birthday_date - timedelta(days=14)

def calculate_effective_date_email(effective_date, current_date):
    """Calculate the date to send an effective date email (30 days before)"""
    return effective_date - timedelta(days=30)

# Helper function to check if a date is within an exclusion period
def is_date_excluded(date_obj, exclusions, email_type=None, state=None):
    """
    Check if a date is in an exclusion period
    
    Args:
        date_obj: The date to check
        exclusions: List of exclusion periods
        email_type: Type of email (to apply special rules)
        state: State code (to apply special rules)
        
    Returns:
        True if date is excluded, False otherwise
    """
    # If exclusion list is empty (for states without rule windows like Kansas), 
    # always return False - no exclusions apply
    if not exclusions:
        return False
        
    # Special bypass rules:
    # 1. For birthday emails in non-special rule states, bypass exclusion checks
    if email_type == "birthday" and state and state not in BIRTHDAY_RULE_STATES:
        return False
        
    # 2. For effective date emails in special rule states, bypass exclusion checks
    if email_type == "effective_date" and state and state in EFFECTIVE_DATE_RULE_STATES:
        return False
    
    # Normal exclusion check
    for exclusion in exclusions:
        if exclusion.start <= date_obj <= exclusion.end_date:
            return True
    return False

# Create a simplified EmailScheduler implementation that works with our setup
class SimpleEmailScheduler(EmailScheduler):
    def __init__(self, current_date=None, end_date=None):
        self.current_date = current_date or date.today()
        self.end_date = end_date or (self.current_date + timedelta(days=365))
        self.rule_engine = ContactRuleEngine()
        
        # Validator for scheduled emails
        self.validator = type('MockValidator', (), {
            'validate_scheduled_emails': lambda *args: True,
            'validate_exclusions': lambda *args: True
        })()
    
    def _precompute_aep_dates(self):
        """Precompute AEP dates for the date range"""
        aep_dates = {}
        for yr in range(self.current_date.year, self.end_date.year + 1):
            # Default AEP dates - distribute across August and September
            dates = []
            for month in [8, 9]:  # August and September
                for week in range(4):  # 4 weeks per month
                    # Calculate date for this week (every Thursday)
                    week_date = date(yr, month, 1)
                    while week_date.weekday() != 3:  # 3 = Thursday
                        week_date += timedelta(days=1)
                    week_date += timedelta(weeks=week)
                    if week_date.month == month:  # Only add if still in target month
                        dates.append(week_date)
            aep_dates[yr] = dates
        return aep_dates
    
    def process_contact(self, contact, contact_index=0):
        """Process a single contact to schedule all applicable emails"""
        result = {
            "contact_id": str(contact['id']),
            "emails": [],
            "skipped": []
        }
        
        try:
            # Init context for tracking emails and dates
            from email_scheduler_optimized import SchedulingContext
            ctx = SchedulingContext(self.current_date, self.end_date)
            
            # Skip blank contacts
            if not contact.get('birth_date') and not contact.get('effective_date'):
                result["skipped"].append({
                    "type": "all", 
                    "reason": "Missing both birth_date and effective_date"
                })
                return result
            
            # Calculate rule windows and exclusion periods
            rule_windows = calculate_rule_windows(contact, [], [], self.current_date, self.end_date)
            
            # Get state and check if it's year-round
            state = contact.get('state', 'CA')
            
            # Skip only if it's a year-round enrollment state
            if state in YEAR_ROUND_ENROLLMENT_STATES:
                # Skip all emails for year-round enrollment states
                for email_type in [EMAIL_TYPE_BIRTHDAY, EMAIL_TYPE_EFFECTIVE_DATE, EMAIL_TYPE_AEP, EMAIL_TYPE_POST_WINDOW]:
                    result["skipped"].append({
                        "type": email_type,
                        "reason": "Year-round enrollment state"
                    })
                return result
            
            # Get latest window end date for post-window calculations (if there are any rule windows)
            latest_window_end = None
            if rule_windows:
                latest_window_end = max(end for _, end, _, _ in rule_windows)
            
            # Calculate exclusion periods
            exclusion_periods = calculate_exclusion_periods(rule_windows, self.current_date, self.end_date)
            
            # Process birthdays
            birthday_scheduled = False
            if contact.get('birth_date'):
                try:
                    # Get actual birthdate
                    if isinstance(contact['birth_date'], str):
                        birthday = datetime.strptime(contact['birth_date'], "%Y-%m-%d").date()
                    elif isinstance(contact['birth_date'], date):
                        birthday = contact['birth_date']
                    else:
                        log(f"Invalid birth_date format for contact {contact['id']}: {contact['birth_date']}", always=True)
                        result["skipped"].append({
                            "type": EMAIL_TYPE_BIRTHDAY,
                            "reason": "Invalid birth_date format"
                        })
                        birthday = None
                    
                    if birthday:
                        # For IL residents, check age before scheduling birthday email
                        if state == "IL":
                            # Calculate age
                            age = self.current_date.year - birthday.year
                            if self.current_date.month < birthday.month or (self.current_date.month == birthday.month and self.current_date.day < birthday.day):
                                age -= 1
                                
                            # Skip birthday emails for IL residents 76+ years old
                            if age >= 76:
                                result["skipped"].append({
                                    "type": EMAIL_TYPE_BIRTHDAY,
                                    "reason": "Illinois resident over 76 years old"
                                })
                                birthday = None

                        if birthday:
                            # Calculate all birthdays in our date range
                            birthdays = []
                            # Current year birthday if not already passed
                            if (birthday.month > self.current_date.month or 
                                (birthday.month == self.current_date.month and birthday.day >= self.current_date.day)):
                                birthdays.append(date(self.current_date.year, birthday.month, birthday.day))
                            
                            # Add birthdays for future years
                            for yr in range(self.current_date.year + 1, self.end_date.year + 1):
                                if birthday.month == 2 and birthday.day == 29 and not is_leap_year(yr):
                                    birthdays.append(date(yr, 2, 28))
                                else:
                                    birthdays.append(date(yr, birthday.month, birthday.day))
                            
                            # Schedule birthday emails (14 days before each birthday)
                            for birthday_date in birthdays:
                                email_date = calculate_birthday_email_date(birthday_date, birthday_date.year)
                                
                                # Only schedule if email date is within our range and not excluded
                                if self.current_date <= email_date <= self.end_date:
                                    # For birthday emails, bypass exclusion for non-special rule states
                                    # This ensures that non-special states like Alaska still get birthday emails
                                    bypass_exclusion = state not in BIRTHDAY_RULE_STATES
                                    
                                    # Check if date would be excluded by normal rules
                                    would_be_excluded = is_date_excluded(email_date, exclusion_periods, "birthday", state)
                                    
                                    # Log exclusion status for debugging
                                    if would_be_excluded:
                                        log(f"Birthday email for contact {contact['id']} on {email_date} would be excluded, bypass_exclusion={bypass_exclusion}", always=DEBUG)
                                    
                                    if bypass_exclusion or not would_be_excluded:
                                        log(f"Scheduling birthday email for contact {contact['id']} (state={state}) on {email_date}", always=DEBUG)
                                        result["emails"].append({
                                            "type": "birthday",  # Ensure lowercase consistent with frontend
                                            "date": email_date.isoformat()
                                        })
                                        birthday_scheduled = True
                                    else:
                                        log(f"Skipping birthday email for contact {contact['id']} on {email_date} due to exclusion period", always=DEBUG)
                            # If no birthdays were scheduled, provide a reason
                            if not birthday_scheduled:
                                result["skipped"].append({
                                    "type": "birthday",
                                    "reason": "No birthdays in scheduling window or all dates excluded"
                                })
                except Exception as e:
                    log(f"Error processing birthdate for contact {contact['id']}: {e}", always=True)
                    result["skipped"].append({
                        "type": "birthday",
                        "reason": f"Error processing birth_date: {str(e)}"
                    })
            else:
                # Skip birthday emails if no birth date
                result["skipped"].append({
                    "type": "birthday",
                    "reason": "No birth date provided"
                })
            
            # Process effective dates
            effective_date_scheduled = False
            if contact.get('effective_date'):
                try:
                    # Get actual effective date
                    if isinstance(contact['effective_date'], str):
                        effective_date = datetime.strptime(contact['effective_date'], "%Y-%m-%d").date()
                    elif isinstance(contact['effective_date'], date):
                        effective_date = contact['effective_date']
                    else:
                        log(f"Invalid effective_date format for contact {contact['id']}: {contact['effective_date']}", always=True)
                        result["skipped"].append({
                            "type": "effective_date",
                            "reason": "Invalid effective_date format"
                        })
                        effective_date = None
                    
                    if effective_date:
                        # Calculate all effective dates in our date range
                        effective_dates = []
                        # Start with current year if not already passed
                        if (effective_date.month > self.current_date.month or 
                            (effective_date.month == self.current_date.month and effective_date.day >= self.current_date.day)):
                            effective_dates.append(date(self.current_date.year, effective_date.month, effective_date.day))
                        
                        # Add effective dates for future years
                        for yr in range(self.current_date.year + 1, self.end_date.year + 1):
                            effective_dates.append(date(yr, effective_date.month, effective_date.day))
                        
                        # Schedule effective date emails (30 days before each date)
                        for eff_date in effective_dates:
                            email_date = calculate_effective_date_email(eff_date, self.current_date)
                            
                            # Only schedule if email date is within our range and not excluded
                            if self.current_date <= email_date <= self.end_date:
                                # For effective date emails, bypass exclusion for special rule states like Missouri
                                # This ensures that states like Missouri still get effective date emails
                                bypass_exclusion = state in EFFECTIVE_DATE_RULE_STATES
                                
                                # Check if date would be excluded by normal rules
                                would_be_excluded = is_date_excluded(email_date, exclusion_periods, "effective_date", state)
                                
                                # Log exclusion status for debugging
                                if would_be_excluded:
                                    log(f"Effective date email for contact {contact['id']} on {email_date} would be excluded, bypass_exclusion={bypass_exclusion}", always=DEBUG)
                                
                                if bypass_exclusion or not would_be_excluded:
                                    log(f"Scheduling effective date email for contact {contact['id']} (state={state}) on {email_date}", always=DEBUG)
                                    result["emails"].append({
                                        "type": "effective_date",  # Ensure lowercase consistent with frontend
                                        "date": email_date.isoformat()
                                    })
                                    effective_date_scheduled = True
                                else:
                                    log(f"Skipping effective date email for contact {contact['id']} on {email_date} due to exclusion period", always=DEBUG)
                        # If no effective dates were scheduled, provide a reason
                        if not effective_date_scheduled:
                            result["skipped"].append({
                                "type": "effective_date",
                                "reason": "No effective dates in scheduling window or all dates excluded"
                            })
                except Exception as e:
                    log(f"Error processing effective date for contact {contact['id']}: {e}", always=True)
                    result["skipped"].append({
                        "type": "effective_date",
                        "reason": f"Error processing effective_date: {str(e)}"
                    })
            else:
                # Skip effective date emails if no effective date
                result["skipped"].append({
                    "type": "effective_date",
                    "reason": "No effective date provided"
                })
            
            # Schedule AEP emails
            aep_scheduled = False
            for yr in range(self.current_date.year, self.end_date.year + 1):
                # Use August/September AEP dates from the config
                aep_dates_for_year = self.rule_engine.get_aep_dates(yr)
                if not aep_dates_for_year:
                    continue
                
                # Distribute contacts evenly across the AEP weeks
                week_index = int(contact['id']) % len(aep_dates_for_year)
                aep_date = aep_dates_for_year[week_index]
                
                if aep_date >= self.current_date and aep_date <= self.end_date:
                    if not is_date_excluded(aep_date, exclusion_periods, "aep", state):
                        result["emails"].append({
                            "type": "aep",  # Ensure lowercase consistent with frontend
                            "date": str(aep_date)
                        })
                        aep_scheduled = True
                        break  # Only schedule one AEP email per contact
            
            if not aep_scheduled:
                result["skipped"].append({
                    "type": "aep",
                    "reason": "No suitable AEP date found"
                })
            
            # Schedule post-window emails
            post_window_scheduled = False
            post_window_dates = calculate_post_window_dates(rule_windows, self.end_date)
            if post_window_dates:
                for post_date in sorted(post_window_dates):
                    if post_date >= self.current_date and post_date <= self.end_date:
                        # Post-window emails bypass exclusion checks
                        result["emails"].append({
                            "type": "post_window",  # Ensure lowercase consistent with frontend
                            "date": str(post_date)
                        })
                        post_window_scheduled = True
                        break  # Only schedule one post-window email
            
            if not post_window_scheduled:
                result["skipped"].append({
                    "type": "post_window",
                    "reason": "No valid post-window dates found"
                })
            
            return result
            
        except Exception as e:
            log(f"Error processing contact {contact['id']}: {e}", always=True)
            result["skipped"].append({
                "type": "all",
                "reason": str(e)
            })
            return result

# Create simplified async processor
class SimpleAsyncEmailProcessor:
    """
    Simple asynchronous processor for email scheduling
    """
    
    def __init__(self, current_date=None, end_date=None, batch_size=100, max_workers=20):
        """Initialize the async processor with performance settings"""
        self.scheduler = SimpleEmailScheduler(current_date, end_date)
        self.batch_size = batch_size
        self.max_workers = max_workers
    
    async def process_contact_async(self, contact, index):
        """Process a single contact asynchronously"""
        return self.scheduler.process_contact(contact, index)
    
    async def process_batch(self, contacts_batch, start_index):
        """Process a batch of contacts concurrently"""
        tasks = []
        for i, contact in enumerate(contacts_batch):
            contact_index = start_index + i
            task = asyncio.create_task(self.process_contact_async(contact, contact_index))
            tasks.append(task)
        
        return await asyncio.gather(*tasks)
    
    async def process_contacts(self, contacts):
        """Process all contacts with optimized batching"""
        results = []
        
        # Process in batches for optimal performance
        for i in range(0, len(contacts), self.batch_size):
            batch = contacts[i:i+self.batch_size]
            batch_results = await self.process_batch(batch, i)
            results.extend(batch_results)
        
        return results

# Use our simplified scheduler
AsyncEmailProcessor.scheduler = SimpleEmailScheduler

# Global configuration
VERBOSE = False
DEBUG = False

def connect_to_db(db_path: str) -> sqlite3.Connection:
    """
    Connect to SQLite database and set row factory for dictionary results
    
    Args:
        db_path: Path to the SQLite database file
        
    Returns:
        SQLite connection object
    """
    if not os.path.exists(db_path):
        log(f"Database not found: {db_path}", always=True)
        sys.exit(1)
    
    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        log(f"Error connecting to database {db_path}: {e}", always=True)
        sys.exit(1)

def get_organization_details(main_db_path: str, org_id: int) -> Dict[str, Any]:
    """
    Get organization details from the main database
    
    Args:
        main_db_path: Path to the main database
        org_id: Organization ID
        
    Returns:
        Organization details as a dictionary
    """
    log(f"Getting organization details for org_id: {org_id}", always=True)
    
    conn = connect_to_db(main_db_path)
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE id = ?", (org_id,))
        org = cursor.fetchone()
        
        if not org:
            log(f"Organization with ID {org_id} not found in the database", always=True)
            sys.exit(1)
            
        return dict(org)
    except sqlite3.Error as e:
        log(f"Error retrieving organization details: {e}", always=True)
        sys.exit(1)
    finally:
        conn.close()

def get_contacts_from_org_db(org_db_path: str, org_id: int) -> List[Dict[str, Any]]:
    """
    Get contacts from the organization's database
    
    Args:
        org_db_path: Path to the organization's database
        org_id: Organization ID
        
    Returns:
        List of contacts as dictionaries
        
    Raises:
        ValueError: If critical columns are missing
        sqlite3.Error: If database errors occur
    """
    log(f"Getting contacts from organization database: {org_db_path}", always=True)
    
    conn = connect_to_db(org_db_path)
    try:
        cursor = conn.cursor()
        
        # Check if the contacts table exists and has the required columns
        cursor.execute("PRAGMA table_info(contacts)")
        columns = [column['name'] for column in cursor.fetchall()]
        
        critical_columns = ['id', 'email']  # These must exist
        optional_columns = ['first_name', 'last_name', 'birth_date', 'state', 'effective_date', 'zip_code']
        
        missing_critical = [col for col in critical_columns if col not in columns]
        if missing_critical:
            raise ValueError(f"Missing critical columns in contacts table: {', '.join(missing_critical)}")
            
        missing_optional = [col for col in optional_columns if col not in columns]
        if missing_optional:
            log(f"Missing optional columns in contacts table: {', '.join(missing_optional)}", always=True)
        
        # Build query based on available columns
        select_parts = []
        
        # Handle ID column specially
        if 'id' in columns:
            select_parts.append('id')
        else:
            select_parts.append('rowid as id')
            
        # Add email (required)
        select_parts.append('email')
        
        # Add optional columns if they exist
        for col in optional_columns:
            if col in columns:
                select_parts.append(col)
                
        query = f"SELECT {', '.join(select_parts)} FROM contacts"
        cursor.execute(query)
        
        contacts = []
        for row in cursor.fetchall():
            contact = dict(row)
            contact['organization_id'] = org_id
            
            # Only set defaults for optional fields
            if 'first_name' not in contact:
                contact['first_name'] = None
            if 'last_name' not in contact:
                contact['last_name'] = None
            if 'birth_date' not in contact:
                contact['birth_date'] = None
            if 'effective_date' not in contact:
                contact['effective_date'] = None
            if 'zip_code' not in contact:
                contact['zip_code'] = None
                
            # Don't set a default state - we'll determine it from ZIP code later
            if 'state' not in contact:
                contact['state'] = None
                
            contacts.append(contact)
            
        log(f"Retrieved {len(contacts)} contacts from organization database", always=True)
        return contacts
    except sqlite3.Error as e:
        log(f"Error retrieving contacts: {e}", always=True)
        raise
    finally:
        conn.close()

def parse_date_flexible(date_str: str) -> Optional[date]:
    """
    Parse a date string flexibly, handling both dash and slash formats.
    Supports formats: YYYY-MM-DD, YYYY/MM/DD, MM/DD/YYYY, MM-DD-YYYY
    
    Args:
        date_str: Date string to parse
        
    Returns:
        datetime.date object if successful, None if parsing fails
    """
    if not date_str:
        return None
        
    formats = [
        "%Y-%m-%d",  # YYYY-MM-DD
        "%Y/%m/%d",  # YYYY/MM/DD
        "%m/%d/%Y",  # MM/DD/YYYY
        "%m-%d-%Y"   # MM-DD-YYYY
    ]
    
    for fmt in formats:
        try:
            return datetime.strptime(date_str, fmt).date()
        except ValueError:
            continue
    
    return None

def format_contact_data(contacts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Format contact data for compatibility with the email scheduler
    
    Args:
        contacts: List of contacts from the database
        
    Returns:
        Formatted contact data ready for scheduling
    """
    log("Formatting contact data for scheduler", always=True)
    
    formatted_contacts = []
    for contact in contacts:
        # Always try to determine state from ZIP code first
        state = None
        if contact.get('zip_code'):
            from app import get_state_from_zip
            state = get_state_from_zip(contact['zip_code'])
        
        # If we couldn't get state from ZIP, check if existing state is valid
        if not state and contact.get('state'):
            from app import ALL_STATES
            if contact['state'] in ALL_STATES:
                state = contact['state']
        
        # Default to CA if we still don't have a valid state
        if not state:
            log(f"Could not determine valid state for contact {contact.get('id')}, defaulting to CA", always=False)
            state = 'CA'
        
        # Ensure required fields exist
        formatted_contact = {
            'id': contact.get('id'),
            'contact_id': str(contact.get('id')),
            'first_name': contact.get('first_name', 'Unknown'),
            'last_name': contact.get('last_name', 'Unknown'),
            'email': contact.get('email', f"contact{contact.get('id')}@example.com"),
            'birth_date': contact.get('birth_date'),
            'effective_date': contact.get('effective_date'),
            'state': state,
            'organization_id': contact.get('organization_id')
        }
        
        # Skip contacts with missing critical data
        if not formatted_contact['birth_date'] and not formatted_contact['effective_date']:
            log(f"Skipping contact {formatted_contact['id']}: Missing both birth_date and effective_date", always=False)
            continue
            
        # Convert date fields if needed
        for date_field in ['birth_date', 'effective_date']:
            if formatted_contact[date_field]:
                if not isinstance(formatted_contact[date_field], date):
                    if isinstance(formatted_contact[date_field], str):
                        parsed_date = parse_date_flexible(formatted_contact[date_field])
                        if parsed_date:
                            formatted_contact[date_field] = parsed_date.isoformat()
                        else:
                            log(f"Warning: Could not parse {date_field} for contact {formatted_contact['id']}: {formatted_contact[date_field]}", always=True)
                            formatted_contact[date_field] = None
                    else:
                        formatted_contact[date_field] = formatted_contact[date_field].isoformat()
                
        formatted_contacts.append(formatted_contact)
        
    log(f"Formatted {len(formatted_contacts)} contacts for scheduling", always=True)
    return formatted_contacts

def generate_link(org_id: int, contact_id: str, email_type: str, email_date: str) -> str:
    """
    Generate a tracking link for the email using quote ID system
    
    Args:
        org_id: Organization ID
        contact_id: Contact ID
        email_type: Type of email (birthday, effective_date, aep, post_window)
        email_date: Scheduled date for the email
        
    Returns:
        Generated URL for tracking
    """
    import hashlib
    import os

    # Convert contact_id to int for quote ID generation
    contact_id_int = int(contact_id)
    
    # Get quote secret from environment with default fallback
    quote_secret = os.environ.get('QUOTE_SECRET', 'your-default-secret-key')
    
    # Create data string to hash - EXACTLY matching TypeScript implementation
    # Convert numbers to strings first to ensure exact string concatenation
    org_id_str = str(org_id)
    contact_id_str = str(contact_id_int)
    data_to_hash = f"{org_id_str}-{contact_id_str}-{quote_secret}"
    
    # Generate hash using hashlib - encode as UTF-8 to match Node.js behavior
    hash_value = hashlib.sha256(data_to_hash.encode('utf-8')).hexdigest()[:8]
    
    # Combine components into quote ID
    quote_id = f"{org_id}-{contact_id_int}-{hash_value}"
    
    # Get base URL from environment or use default
    base_url = os.environ.get('EMAIL_SCHEDULER_BASE_URL', 'https://maxretain.com')
    
    # Ensure quote ID is properly URL encoded
    from urllib.parse import quote
    quote_id_enc = quote(quote_id)
    
    # Construct tracking URL with quote ID
    return f"{base_url.rstrip('/')}/compare?id={quote_id_enc}"

def write_results_to_csv(results: List[Dict[str, Any]], contacts: List[Dict[str, Any]], 
                         org_id: int, output_csv: str) -> None:
    """
    Write scheduling results to CSV
    
    Args:
        results: Results from the email scheduler
        contacts: Original contact data
        org_id: Organization ID
        output_csv: Path to the output CSV file
    """
    log(f"Writing results to CSV: {output_csv}", always=True)
    
    # Create a lookup dictionary for contacts
    contact_dict = {str(contact['id']): contact for contact in contacts}
    
    # Prepare data for CSV, using a set to track unique entries
    seen_entries = set()  # Track unique entries to prevent duplicates
    csv_data = []
    
    for result in results:
        contact_id = result['contact_id']
        contact = contact_dict.get(contact_id, {})
        
        # Process scheduled emails
        for email in result.get('emails', []):
            email_type = email.get('type', '')
            # Ensure date is a string
            email_date = str(email.get('date', ''))
            
            # Create a unique key for this email entry
            unique_key = f"{contact_id}-{email_type}-{email_date}"
            if unique_key in seen_entries:
                continue
            seen_entries.add(unique_key)
            
            # Generate complete link
            link = generate_link(org_id, contact_id, email_type, email_date)
            
            row = {
                'org_id': org_id,
                'contact_id': contact_id,
                'email': contact.get('email', f"contact{contact_id}@example.com"),
                'first_name': contact.get('first_name', 'Unknown'),
                'last_name': contact.get('last_name', 'Unknown'),
                'state': contact.get('state', 'CA'),
                'birth_date': contact.get('birth_date', ''),
                'effective_date': contact.get('effective_date', ''),
                'email_type': email_type,
                'email_date': email_date,
                'link': link,
                'skipped': 'No',
                'reason': email.get('reason', '')
            }
            csv_data.append(row)
            
        # Process skipped emails
        for skipped in result.get('skipped', []):
            email_type = skipped.get('type', 'all')
            reason = skipped.get('reason', 'Unknown reason')
            
            # Create a unique key for this skipped entry
            unique_key = f"{contact_id}-{email_type}-skipped-{reason}"
            if unique_key in seen_entries:
                continue
            seen_entries.add(unique_key)
            
            row = {
                'org_id': org_id,
                'contact_id': contact_id,
                'email': contact.get('email', f"contact{contact_id}@example.com"),
                'first_name': contact.get('first_name', 'Unknown'),
                'last_name': contact.get('last_name', 'Unknown'),
                'state': contact.get('state', 'CA'),
                'birth_date': contact.get('birth_date', ''),
                'effective_date': contact.get('effective_date', ''),
                'email_type': email_type,
                'email_date': '',  # Empty string for skipped emails
                'link': '',  # No link for skipped emails
                'skipped': 'Yes',
                'reason': reason
            }
            csv_data.append(row)
    
    # Define column order
    columns = [
        'org_id', 'contact_id', 'email', 'first_name', 'last_name',
        'state', 'birth_date', 'effective_date',
        'email_type', 'email_date', 'link', 'skipped', 'reason'
    ]
    
    # Use pandas to write the CSV with specified column order
    try:
        df = pd.DataFrame(csv_data)
        df = df[columns]  # Reorder columns
        
        # Replace any remaining nan values with empty strings
        df = df.fillna('')
        
        # Convert all date fields to strings to ensure consistent format
        if 'email_date' in df.columns:
            df['email_date'] = df['email_date'].astype(str)
        if 'birth_date' in df.columns:
            df['birth_date'] = df['birth_date'].astype(str)
        if 'effective_date' in df.columns:
            df['effective_date'] = df['effective_date'].astype(str)
            
        df.to_csv(output_csv, index=False)
        log(f"Successfully wrote {len(csv_data)} rows to {output_csv}", always=True)
    except Exception as e:
        log(f"Error writing CSV: {e}", always=True)
        sys.exit(1)

async def process_contacts_async(contacts: List[Dict[str, Any]], current_date: date, 
                                end_date: date) -> List[Dict[str, Any]]:
    """
    Process contacts asynchronously using the SimpleEmailScheduler
    
    Args:
        contacts: Formatted contact data
        current_date: Start date for scheduling
        end_date: End date for scheduling
        
    Returns:
        Scheduling results
    """
    log("Processing contacts asynchronously", always=True)
    
    # Initialize the async email processor with our custom scheduler
    processor = SimpleAsyncEmailProcessor(current_date, end_date, batch_size=100, max_workers=20)
    results = await processor.process_contacts(contacts)
    
    # Process post-window emails based on business rules
    for i, result in enumerate(results):
        if i < len(contacts):
            contact = contacts[i]
            state = contact.get('state', 'CA')
            
            # Post-window emails should only be scheduled for states with specific rules
            # This is already handled by the calculate_rule_windows function which will
            # return an empty list for states without specific rules
            if state in BIRTHDAY_RULE_STATES or state in EFFECTIVE_DATE_RULE_STATES:
                has_post_window = any(email.get('type') == EMAIL_TYPE_POST_WINDOW for email in result.get('emails', []))
                
                if not has_post_window:
                    # Calculate post-window date based on state rules
                    window_after = None
                    if state in BIRTHDAY_RULE_STATES:
                        window_after = BIRTHDAY_RULE_STATES[state]["window_after"]
                    elif state in EFFECTIVE_DATE_RULE_STATES:
                        window_after = EFFECTIVE_DATE_RULE_STATES[state]["window_after"]
                        
                    if window_after is not None:
                        # Find the latest rule window end date
                        rule_windows = calculate_rule_windows(contact, [], [], current_date, end_date)
                        if rule_windows:
                            latest_window_end = max(end for _, end, _, _ in rule_windows)
                            post_date = latest_window_end + timedelta(days=window_after + 1)
                            
                            if current_date <= post_date <= end_date:
                                result['emails'].append({
                                    "type": EMAIL_TYPE_POST_WINDOW,
                                    "date": str(post_date),
                                    "reason": f"Post-window email based on {state} state rules"
                                })
            else:
                # For states without specific rules, ensure there are no post-window emails
                # and add a skip reason if needed
                has_skip_reason = any(skip.get('type') == EMAIL_TYPE_POST_WINDOW for skip in result.get('skipped', []))
                if not has_skip_reason:
                    result.setdefault('skipped', []).append({
                        "type": EMAIL_TYPE_POST_WINDOW,
                        "reason": f"No post-window emails for state {state} - no rule windows"
                    })
    
    return results

def process_contacts_sync(contacts: List[Dict[str, Any]], current_date: date, 
                         end_date: date) -> List[Dict[str, Any]]:
    """
    Process contacts synchronously using the SimpleEmailScheduler
    
    Args:
        contacts: Formatted contact data
        current_date: Start date for scheduling
        end_date: End date for scheduling
        
    Returns:
        Scheduling results
    """
    log("Processing contacts synchronously", always=True)
    
    # Initialize the email scheduler with the date range
    scheduler = SimpleEmailScheduler(current_date, end_date)
    results = []
    
    # Process each contact
    for i, contact in enumerate(contacts):
        contact_id = str(contact['id'])
        try:
            # Process the contact using the scheduler
            result = scheduler.process_contact(contact, i)
            
            # Ensure contact_id is included
            if not result.get('contact_id'):
                result['contact_id'] = contact_id
            
            # Apply the same post-window email logic as in the async processor
            state = contact.get('state', 'CA')
            
            # Post-window emails should only be scheduled for states with specific rules
            if state in BIRTHDAY_RULE_STATES or state in EFFECTIVE_DATE_RULE_STATES:
                has_post_window = any(email.get('type') == EMAIL_TYPE_POST_WINDOW for email in result.get('emails', []))
                
                if not has_post_window:
                    # Calculate post-window date based on state rules
                    window_after = None
                    if state in BIRTHDAY_RULE_STATES:
                        window_after = BIRTHDAY_RULE_STATES[state]["window_after"]
                    elif state in EFFECTIVE_DATE_RULE_STATES:
                        window_after = EFFECTIVE_DATE_RULE_STATES[state]["window_after"]
                        
                    if window_after is not None:
                        # Find the latest rule window end date
                        rule_windows = calculate_rule_windows(contact, [], [], current_date, end_date)
                        if rule_windows:
                            latest_window_end = max(end for _, end, _, _ in rule_windows)
                            post_date = latest_window_end + timedelta(days=window_after + 1)
                            
                            if current_date <= post_date <= end_date:
                                result['emails'].append({
                                    "type": EMAIL_TYPE_POST_WINDOW,
                                    "date": str(post_date),
                                    "reason": f"Post-window email based on {state} state rules"
                                })
            else:
                # For states without specific rules, ensure there are no post-window emails
                # and add a skip reason if needed
                has_skip_reason = any(skip.get('type') == EMAIL_TYPE_POST_WINDOW for skip in result.get('skipped', []))
                if not has_skip_reason:
                    result.setdefault('skipped', []).append({
                        "type": EMAIL_TYPE_POST_WINDOW,
                        "reason": f"No post-window emails for state {state} - no rule windows"
                    })
                
            # Add to results
            results.append(result)
            
        except Exception as e:
            log(f"Error processing contact {contact_id}: {e}", always=True)
            # Add error result
            results.append({
                "contact_id": contact_id,
                "emails": [],
                "skipped": [{"type": "all", "reason": str(e)}]
            })
        
    return results

def main():
    """Main entry point for the script"""
    parser = argparse.ArgumentParser(description="Schedule emails for a specific organization")
    parser.add_argument("--org-id", type=int, required=True, help="Organization ID")
    parser.add_argument("--output-csv", required=True, help="Output CSV file path")
    parser.add_argument("--main-db", default="main.db", help="Path to the main SQLite database")
    parser.add_argument("--org-db-dir", default="org_dbs/", help="Directory containing organization-specific databases")
    parser.add_argument("--start-date", help="Start date (YYYY-MM-DD)")
    parser.add_argument("--async", action="store_true", help="Use asynchronous processing")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging", default=True)
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging", default=True)
    
    args = parser.parse_args()
    
    # Set global config
    global DEBUG, VERBOSE
    DEBUG = args.debug
    VERBOSE = args.verbose
    
    # Parse start date
    current_date = None
    if args.start_date:
        try:
            current_date = datetime.strptime(args.start_date, "%Y-%m-%d").date()
        except ValueError as e:
            log(f"Invalid start date format: {e}", always=True)
            log("Start date must be in YYYY-MM-DD format", always=True)
            sys.exit(1)
    else:
        current_date = date.today()
    
    # Set end date to two years from start date
    end_date = current_date + timedelta(days=730)  # 2 years (365 * 2 + leap days)
    
    # Get organization details
    org = get_organization_details(args.main_db, args.org_id)
    log(f"Processing organization: {org['name']} (ID: {org['id']})", always=True)
    
    # Get contacts from organization database
    org_db_path = os.path.join(args.org_db_dir, f"org-{args.org_id}.db")
    contacts = get_contacts_from_org_db(org_db_path, args.org_id)
    
    # Format contact data for the scheduler
    formatted_contacts = format_contact_data(contacts)
    
    if not formatted_contacts:
        log("No valid contacts found for scheduling", always=True)
        sys.exit(1)
    
    # Process contacts
    try:
        log(f"Scheduling emails for {len(formatted_contacts)} contacts from {current_date} to {end_date}", always=True)
        
        results = []
        
        if getattr(args, 'async'):
            # Run asynchronously using the SimpleEmailScheduler
            results = asyncio.run(process_contacts_async(formatted_contacts, current_date, end_date))
        else:
            # Run synchronously using the SimpleEmailScheduler
            results = process_contacts_sync(formatted_contacts, current_date, end_date)
            
        # Count scheduled emails
        scheduled_count = sum(len(result.get('emails', [])) for result in results)
        skipped_count = sum(len(result.get('skipped', [])) for result in results)
        
        log(f"Scheduled {scheduled_count} emails, skipped {skipped_count} emails", always=True)
        
        # Write results to CSV
        write_results_to_csv(results, formatted_contacts, args.org_id, args.output_csv)
        
        log("Email scheduling completed successfully", always=True)
        
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        log(f"Error scheduling emails: {e}", always=True)
        log(f"Error details:\n{error_trace}", always=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

================
File: send_scheduled_emails.py
================
"""
Main script for sending scheduled emails.
Reads scheduled emails from the output JSON and sends them via SendGrid.
"""

import os
import json
import argparse
from datetime import date, datetime, timedelta
import time
from typing import Dict, List, Any, Optional

from email_scheduler_common import logger
from sendgrid_client import SendGridClient
from email_template_engine import EmailTemplateEngine

# Initialize the template engine
template_engine = EmailTemplateEngine()

def get_email_content(email_type, contact, email_date):
    """Get email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date)

def get_email_html_content(email_type, contact, email_date):
    """Get HTML email content using the template engine"""
    return template_engine.render_email(email_type, contact, email_date, html=True)

def load_scheduled_emails(input_file: str) -> List[Dict[str, Any]]:
    """Load scheduled emails from JSON file"""
    try:
        with open(input_file, 'r') as f:
            data = json.load(f)
        return data
    except Exception as e:
        logger.error(f"Error loading scheduled emails from {input_file}: {e}")
        return []

def load_contact_details(contact_id: str, contacts_file: str) -> Optional[Dict[str, Any]]:
    """Load contact details from contacts file"""
    try:
        with open(contacts_file, 'r') as f:
            contacts = json.load(f)
        
        # Find the contact by ID
        for contact in contacts:
            if str(contact.get('id')) == str(contact_id):
                return contact
        
        logger.error(f"Contact {contact_id} not found in contacts file")
        return None
    except Exception as e:
        logger.error(f"Error loading contact details from {contacts_file}: {e}")
        return None

def send_scheduled_emails(
    scheduled_data: List[Dict[str, Any]], 
    contacts_file: str,
    dry_run: bool = True,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    limit: Optional[int] = None,
    delay: float = 0.0
):
    """Send scheduled emails using SendGrid"""
    # Initialize the SendGrid client
    client = SendGridClient(dry_run=dry_run)
    
    # Default to today if no start date provided
    if start_date is None:
        start_date = date.today()
    
    # Default to one year from start date if no end date provided
    if end_date is None:
        end_date = start_date + timedelta(days=365)
    
    # Track stats
    total_emails = 0
    successful_emails = 0
    failed_emails = 0
    
    # Process each contact's scheduled emails
    for contact_data in scheduled_data:
        contact_id = contact_data.get('contact_id')
        scheduled_emails = contact_data.get('emails', [])
        
        if not contact_id or not scheduled_emails:
            continue
        
        # Load contact details
        contact = load_contact_details(contact_id, contacts_file)
        if not contact:
            logger.warning(f"Skipping emails for contact {contact_id}: Contact details not found")
            continue
        
        # Ensure contact has an email address
        if not contact.get('email'):
            logger.warning(f"Skipping emails for contact {contact_id}: No email address")
            continue
        
        to_email = contact['email']
        
        # Process scheduled emails for this contact
        for email in scheduled_emails:
            email_type = email.get('type')
            email_date_str = email.get('date')
            
            if not email_type or not email_date_str:
                continue
            
            # Parse the email date
            try:
                email_date = datetime.strptime(email_date_str, "%Y-%m-%d").date()
            except:
                logger.error(f"Invalid date format for email: {email_date_str}")
                continue
            
            # Skip emails outside our date range
            if email_date < start_date or email_date > end_date:
                continue
            
            # Generate email content
            try:
                content = get_email_content(email_type, contact, email_date)
                html_content = get_email_html_content(email_type, contact, email_date)
                
                # Send the email
                total_emails += 1
                result = client.send_email(
                    to_email=to_email,
                    subject=content['subject'],
                    content=content['body'],
                    html_content=html_content,
                    dry_run=dry_run
                )
                
                if result:
                    successful_emails += 1
                    logger.info(f"Email {email_type} for contact {contact_id} scheduled on {email_date_str} sent successfully")
                else:
                    failed_emails += 1
                    logger.error(f"Failed to send {email_type} email for contact {contact_id} scheduled on {email_date_str}")
                
                # Add a delay if specified (helps with rate limits)
                if delay > 0 and total_emails < len(scheduled_data):
                    time.sleep(delay)
                
                # Check if we've hit the limit
                if limit and total_emails >= limit:
                    logger.info(f"Reached email limit of {limit}, stopping")
                    break
                
            except Exception as e:
                logger.error(f"Error sending {email_type} email for contact {contact_id}: {e}")
                failed_emails += 1
        
        # Check if we've hit the limit
        if limit and total_emails >= limit:
            break
    
    # Log summary
    logger.info(f"Email sending complete: {successful_emails} successful, {failed_emails} failed, {total_emails} total")
    
    return {
        "total": total_emails,
        "successful": successful_emails,
        "failed": failed_emails
    }

def main():
    """Main entry point for the script"""
    parser = argparse.ArgumentParser(description="Send scheduled emails using SendGrid")
    parser.add_argument("--input", required=True, help="Input JSON file with scheduled emails")
    parser.add_argument("--contacts", required=True, help="JSON file with contact details")
    parser.add_argument("--start-date", help="Start date for emails (YYYY-MM-DD)")
    parser.add_argument("--end-date", help="End date for emails (YYYY-MM-DD)")
    parser.add_argument("--limit", type=int, help="Maximum number of emails to send")
    parser.add_argument("--delay", type=float, default=0.0, help="Delay between emails in seconds")
    parser.add_argument("--live", action="store_true", help="Send actual emails (default is dry-run)")
    
    args = parser.parse_args()
    
    # Parse dates if provided
    start_date = None
    if args.start_date:
        start_date = datetime.strptime(args.start_date, "%Y-%m-%d").date()
    
    end_date = None
    if args.end_date:
        end_date = datetime.strptime(args.end_date, "%Y-%m-%d").date()
    
    # Determine dry_run mode (default to True - dry run)
    dry_run = not args.live
    
    # Load scheduled emails
    scheduled_data = load_scheduled_emails(args.input)
    
    # Send emails
    mode = "LIVE" if not dry_run else "DRY RUN"
    logger.info(f"Starting email sending in {mode} mode")
    
    result = send_scheduled_emails(
        scheduled_data=scheduled_data,
        contacts_file=args.contacts,
        dry_run=dry_run,
        start_date=start_date,
        end_date=end_date,
        limit=args.limit,
        delay=args.delay
    )
    
    logger.info(f"Email sending complete: {result['successful']} successful, {result['failed']} failed, {result['total']} total")

if __name__ == "__main__":
    main()

================
File: sendgrid_client.py
================
"""
SendGrid integration module for email scheduler.
Provides functionality to send emails via SendGrid API with support for dry-run mode.
"""

import os
import logging
from typing import Dict, Any, Optional, Union
import sendgrid
from sendgrid.helpers.mail import Mail, Email, To, Content, HtmlContent
from email_scheduler_common import logger

# Default configuration values
DEFAULT_FROM_EMAIL = "medicare@example.com"
DEFAULT_FROM_NAME = "Medicare Services" 
DEFAULT_DRY_RUN = "true"

class SendGridClient:
    """Client for interacting with SendGrid API to send emails."""
    
    def __init__(self, api_key: Optional[str] = None, dry_run: Optional[bool] = None):
        """
        Initialize the SendGrid client with API key and settings.
        
        Args:
            api_key: SendGrid API key (if None, reads from SENDGRID_API_KEY env var)
            dry_run: Whether to operate in dry-run mode (if None, reads from EMAIL_DRY_RUN env var)
        """
        # Use provided API key or read from environment
        self.api_key = api_key or os.environ.get("SENDGRID_API_KEY")
        
        # Set up dry run mode (default to True if not specified)
        if dry_run is None:
            dry_run_env = os.environ.get("EMAIL_DRY_RUN", DEFAULT_DRY_RUN).lower()
            self.dry_run = dry_run_env in ("true", "1", "yes", "y", "t")
        else:
            self.dry_run = dry_run
        
        # Default sender details
        self.from_email = os.environ.get("FROM_EMAIL", DEFAULT_FROM_EMAIL)
        self.from_name = os.environ.get("FROM_NAME", DEFAULT_FROM_NAME)
        
        # Initialize SendGrid client if API key is available and not in dry-run mode
        self.client = None
        if not self.dry_run and self.api_key:
            try:
                self.client = sendgrid.SendGridAPIClient(api_key=self.api_key)
            except Exception as e:
                logger.error(f"Failed to initialize SendGrid client: {e}")
    
    def send_email(
        self, 
        to_email: str, 
        subject: str, 
        content: str, 
        html_content: Optional[str] = None,
        dry_run: Optional[bool] = None
    ) -> bool:
        """
        Send an email via SendGrid or log it in dry-run mode.
        
        Args:
            to_email: Recipient email address
            subject: Email subject line
            content: Plain text email content
            html_content: Optional HTML content for the email
            dry_run: Override instance dry_run setting for this specific email
            
        Returns:
            Boolean indicating success
        """
        # Determine dry run mode for this specific email
        use_dry_run = self.dry_run if dry_run is None else dry_run
        
        # Validate email address format (basic check)
        if not to_email or '@' not in to_email:
            logger.error(f"Invalid email address: {to_email}")
            return False
        
        # In dry-run mode, just log the email
        if use_dry_run:
            logger.info(f"[DRY RUN] Would send email to: {to_email}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info(f"[DRY RUN] From: {self.from_name} <{self.from_email}>")
            logger.info(f"[DRY RUN] Content (first 100 chars): {content[:100]}...")
            return True
        
        # Ensure we have API key for live mode
        if not self.api_key:
            logger.error("Cannot send email: SendGrid API key not provided")
            return False
        
        # Ensure client is initialized
        if not self.client:
            logger.error("SendGrid client not initialized")
            return False
        
        try:
            # Create email message
            from_email = Email(self.from_email, self.from_name)
            to_email = To(to_email)
            
            # Use HTML content if provided, otherwise use plain text
            if html_content:
                content = HtmlContent(html_content)
            else:
                content = Content("text/plain", content)
            
            # Construct the message
            message = Mail(from_email, to_email, subject, content)
            
            # Send the email
            response = self.client.send(message)
            
            # Check response
            status_code = response.status_code
            
            if 200 <= status_code < 300:  # Success status codes
                logger.info(f"Email sent successfully to {to_email.email}, status: {status_code}")
                return True
            else:
                logger.error(f"Failed to send email to {to_email.email}, status: {status_code}")
                return False
            
        except Exception as e:
            logger.error(f"Error sending email to {to_email}: {str(e)}")
            return False

# Convenience function to send a single email
def send_email(
    to_email: str, 
    subject: str, 
    content: str, 
    html_content: Optional[str] = None,
    dry_run: Optional[bool] = None
) -> bool:
    """
    Convenience function to send a single email without managing client instance.
    
    Args:
        to_email: Recipient email address
        subject: Email subject line
        content: Plain text email content
        html_content: Optional HTML content for the email
        dry_run: Whether to operate in dry-run mode
        
    Returns:
        Boolean indicating success
    """
    client = SendGridClient(dry_run=dry_run)
    return client.send_email(to_email, subject, content, html_content, dry_run)

================
File: timeline_data_helper.py
================
#!/usr/bin/env python
"""
Timeline Data Helper - Preprocesses CSV data for the email timeline visualization.

This script reads the output from schedule_org_emails.py, computes exclusion windows, 
and generates a modified CSV file that includes all necessary timeline visualization data.

Usage:
    python timeline_data_helper.py --input-csv scheduled_emails.csv --output-csv timeline_data.csv [options]
    
    Options:
        --input-csv FILE          Input CSV file with scheduled emails (required)
        --output-csv FILE         Output CSV file for timeline visualization (required)
        --contact-id INT          Filter by specific contact ID (optional)
        --include-exclusions      Include calculated exclusion windows (default: True)
"""

import argparse
import csv
from datetime import date, datetime, timedelta
import json
import sys
import os


# Constants from email_scheduler_common.py
BIRTHDAY_RULE_STATES = {
    "CA": {"window_before": 30, "window_after": 30},  # 60-day period starting 30 days before birthday
    "ID": {"window_before": 0, "window_after": 63},   # 63-day period starting on birthday
    "IL": {"window_before": 0, "window_after": 45},   # 45-day period starting on birthday
    "KY": {"window_before": 0, "window_after": 60},   # 60-day period following birthday
    "LA": {"window_before": 30, "window_after": 63},  # 93-day period starting 30 days before birthday
    "MD": {"window_before": 0, "window_after": 31},   # 31-day period starting on birthday
    "NV": {"window_before": 0, "window_after": 60},   # 60-day period starting first day of birth month
    "OK": {"window_before": 0, "window_after": 60},   # 60-day period starting on birthday
    "OR": {"window_before": 0, "window_after": 31}    # 31-day period starting on birthday
}

EFFECTIVE_DATE_RULE_STATES = {
    "MO": {"window_before": 30, "window_after": 33}   # 63-day period starting 30 days before anniversary
}

PRE_WINDOW_EXCLUSION_DAYS = 60

def parse_date(date_str):
    """Parse a date string in various formats to a datetime object"""
    if not date_str or date_str.strip() == '':
        return None
        
    # Try different formats
    formats = ['%Y-%m-%d', '%m/%d/%Y', '%m-%d-%Y']
    
    for fmt in formats:
        try:
            return datetime.strptime(date_str, fmt).date()
        except ValueError:
            continue
    
    print(f"Warning: Could not parse date '{date_str}'")
    return None

def calculate_rule_windows(contact):
    """Calculate rule windows based on contact's state and dates"""
    windows = []
    state = contact['state']
    
    # Parse birth date and effective date
    birth_date = parse_date(contact['birth_date'])
    effective_date = parse_date(contact['effective_date'])
    
    if not birth_date and not effective_date:
        return windows
    
    # Get current date and end date (2 years from now)
    current_date = date.today()
    end_date = current_date + timedelta(days=365 * 2)
    
    # Calculate birthdays in our date range
    birthdays = []
    if birth_date:
        for year in range(current_date.year, end_date.year + 1):
            try:
                birthday = date(year, birth_date.month, birth_date.day)
                if birthday >= current_date - timedelta(days=365) and birthday <= end_date:
                    birthdays.append(birthday)
            except ValueError:
                # Handle Feb 29 in non-leap years
                if birth_date.month == 2 and birth_date.day == 29 and not is_leap_year(year):
                    birthday = date(year, 2, 28)
                    if birthday >= current_date - timedelta(days=365) and birthday <= end_date:
                        birthdays.append(birthday)
    
    # Calculate effective dates in our date range
    effective_dates = []
    if effective_date:
        for year in range(current_date.year, end_date.year + 1):
            try:
                eff_date = date(year, effective_date.month, effective_date.day)
                if eff_date >= current_date - timedelta(days=365) and eff_date <= end_date:
                    effective_dates.append(eff_date)
            except ValueError:
                # Handle Feb 29 in non-leap years
                if effective_date.month == 2 and effective_date.day == 29 and not is_leap_year(year):
                    eff_date = date(year, 2, 28)
                    if eff_date >= current_date - timedelta(days=365) and eff_date <= end_date:
                        effective_dates.append(eff_date)
    
    # Process birthday rule states
    if state in BIRTHDAY_RULE_STATES:
        window_before = BIRTHDAY_RULE_STATES[state]["window_before"]
        window_after = BIRTHDAY_RULE_STATES[state]["window_after"]
        
        for bd in birthdays:
            # Special handling for Nevada (first day of birth month)
            if state == "NV":
                bd = date(bd.year, bd.month, 1)
            
            # Calculate rule window
            window_start = bd - timedelta(days=window_before)
            window_end = bd + timedelta(days=window_after)
            
            windows.append({
                "type": "birthday",
                "start_date": window_start.isoformat(),
                "end_date": window_end.isoformat(),
                "description": f"{state} birthday rule window ({window_before} days before, {window_after} days after)"
            })
    
    # Process effective date rule states
    if state in EFFECTIVE_DATE_RULE_STATES:
        window_before = EFFECTIVE_DATE_RULE_STATES[state]["window_before"]
        window_after = EFFECTIVE_DATE_RULE_STATES[state]["window_after"]
        
        for ed in effective_dates:
            # Calculate rule window
            window_start = ed - timedelta(days=window_before)
            window_end = ed + timedelta(days=window_after)
            
            windows.append({
                "type": "effective_date",
                "start_date": window_start.isoformat(),
                "end_date": window_end.isoformat(),
                "description": f"{state} effective date rule window ({window_before} days before, {window_after} days after)"
            })
    
    return windows

def calculate_exclusion_periods(rule_windows):
    """Calculate exclusion periods from rule windows"""
    exclusions = []
    
    for window in rule_windows:
        # Parse dates
        window_start = parse_date(window["start_date"])
        window_end = parse_date(window["end_date"])
        
        # Calculate extended exclusion (PRE_WINDOW_EXCLUSION_DAYS before window to window end)
        exclusion_start = window_start - timedelta(days=PRE_WINDOW_EXCLUSION_DAYS)
        exclusion_end = window_end
        
        exclusions.append({
            "type": "exclusion",
            "start_date": exclusion_start.isoformat(),
            "end_date": exclusion_end.isoformat(),
            "description": f"Exclusion period for {window['type']} rule window"
        })
    
    return exclusions

def is_leap_year(year):
    """Check if a year is a leap year"""
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    return year % 4 == 0

def read_csv(file_path):
    """Read CSV file and return as list of dictionaries"""
    data = []
    
    with open(file_path, 'r') as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            data.append(row)
    
    return data

def write_csv(data, file_path):
    """Write list of dictionaries to CSV file"""
    if not data:
        print("No data to write to CSV")
        return
    
    # Get fieldnames from first row
    fieldnames = list(data[0].keys())
    
    with open(file_path, 'w', newline='') as csv_file:
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(data)
    
    print(f"Wrote {len(data)} rows to {file_path}")

def process_data(input_csv, output_csv, contact_id=None, include_exclusions=True):
    """Process data and write to output CSV"""
    # Read input CSV
    data = read_csv(input_csv)
    print(f"Read {len(data)} rows from {input_csv}")
    
    # Filter by contact_id if specified
    if contact_id:
        data = [row for row in data if row['contact_id'] == str(contact_id)]
        print(f"Filtered to {len(data)} rows for contact {contact_id}")
    
    # Group by contact
    contacts = {}
    for row in data:
        contact_id = row['contact_id']
        
        if contact_id not in contacts:
            contacts[contact_id] = {
                'org_id': row['org_id'],
                'contact_id': contact_id,
                'email': row['email'],
                'first_name': row['first_name'],
                'last_name': row['last_name'],
                'state': row['state'],
                'birth_date': row['birth_date'],
                'effective_date': row['effective_date'],
                'emails': []
            }
        
        # Add email to contact if it's an email type
        if 'email_type' in row and row['email_type']:
            email_type = row['email_type'].lower()
            if '(skipped)' in email_type:
                email_type = email_type.replace(' (skipped)', '')
                skipped = 'Yes'
            else:
                skipped = row.get('skipped', 'No')
                
            contacts[contact_id]['emails'].append({
                'type': email_type,
                'date': row.get('email_date', ''),
                'skipped': skipped,
                'reason': row.get('reason', ''),
                'link': row.get('link', '')
            })
    
    # Calculate rule windows and exclusion periods
    output_data = []
    
    for contact_id, contact in contacts.items():
        rule_windows = calculate_rule_windows(contact)
        exclusion_periods = []
        
        if include_exclusions:
            exclusion_periods = calculate_exclusion_periods(rule_windows)
        
        # Add emails to output data
        for email in contact['emails']:
            output_row = {
                'org_id': contact['org_id'],
                'contact_id': contact['contact_id'],
                'email': contact['email'],
                'first_name': contact['first_name'],
                'last_name': contact['last_name'],
                'state': contact['state'],
                'birth_date': contact['birth_date'],
                'effective_date': contact['effective_date'],
                'item_type': email['type'],
                'date': email['date'],
                'end_date': '',  # Emails are single-point events
                'skipped': email['skipped'],
                'reason': email['reason'],
                'link': email['link'],
                'description': f"{email['type'].title()} email" + (" (skipped)" if email['skipped'] == 'Yes' else "")
            }
            
            output_data.append(output_row)
        
        # Add rule windows to output data
        for window in rule_windows:
            output_row = {
                'org_id': contact['org_id'],
                'contact_id': contact['contact_id'],
                'email': contact['email'],
                'first_name': contact['first_name'],
                'last_name': contact['last_name'],
                'state': contact['state'],
                'birth_date': contact['birth_date'],
                'effective_date': contact['effective_date'],
                'item_type': 'rule_window',
                'date': window['start_date'],
                'end_date': window['end_date'],
                'skipped': 'No',
                'reason': '',
                'link': '',
                'description': window['description']
            }
            
            output_data.append(output_row)
        
        # Add exclusion periods to output data
        for exclusion in exclusion_periods:
            output_row = {
                'org_id': contact['org_id'],
                'contact_id': contact['contact_id'],
                'email': contact['email'],
                'first_name': contact['first_name'],
                'last_name': contact['last_name'],
                'state': contact['state'],
                'birth_date': contact['birth_date'],
                'effective_date': contact['effective_date'],
                'item_type': 'exclusion',
                'date': exclusion['start_date'],
                'end_date': exclusion['end_date'],
                'skipped': 'No',
                'reason': '',
                'link': '',
                'description': exclusion['description']
            }
            
            output_data.append(output_row)
    
    # Write output CSV
    write_csv(output_data, output_csv)

def main():
    parser = argparse.ArgumentParser(description="Process email schedule data for timeline visualization")
    parser.add_argument("--input-csv", required=True, help="Input CSV file with scheduled emails")
    parser.add_argument("--output-csv", required=True, help="Output CSV file for timeline visualization")
    parser.add_argument("--contact-id", type=int, help="Filter by specific contact ID")
    parser.add_argument("--include-exclusions", action="store_true", default=True, help="Include calculated exclusion windows")
    
    args = parser.parse_args()
    
    # Check that input file exists
    if not os.path.exists(args.input_csv):
        print(f"Error: Input file {args.input_csv} does not exist")
        sys.exit(1)
    
    # Process data
    process_data(args.input_csv, args.output_csv, args.contact_id, args.include_exclusions)

if __name__ == "__main__":
    main()



================================================================
End of Codebase
================================================================
